diff --git a/.clinerules/main.md b/.clinerules/main.md
new file mode 100644
index 000000000..7213d1f81
--- /dev/null
+++ b/.clinerules/main.md
@@ -0,0 +1,149 @@
+# CLAUDE.md
+
+This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.
+
+## Overview
+
+Neira Coder is an AI-powered autonomous coding agent that lives in a VS Code extension. It can communicate in natural language, read/write files, run terminal commands, automate browser actions, and integrate with various AI models via OpenAI-compatible APIs. The project supports multiple specialized modes, custom instructions, and MCP (Model Context Protocol) integration.
+
+## Development Commands
+
+### Core Commands
+
+- `pnpm install` - Install all dependencies
+- `pnpm build` - Build all packages
+- `pnpm test` - Run tests across all packages
+- `pnpm lint` - Run ESLint across all packages
+- `pnpm check-types` - TypeScript type checking
+- `pnpm format` - Format code with Prettier
+- `pnpm clean` - Clean build artifacts
+
+### Extension Development
+
+- Press `F5` in VS Code - Launch extension in debug mode with hot reload
+- `pnpm install:vsix` - Build and install VSIX package locally
+- `pnpm vsix` - Build VSIX package to `bin/` directory
+- `pnpm bundle` - Bundle extension for production
+- `pnpm watch:bundle` - Watch mode for extension bundling
+
+### Testing
+
+- Single package test: `cd packages/[package-name] && pnpm test`
+- E2E tests: `cd apps/vscode-e2e && pnpm test`
+
+## Architecture
+
+### Monorepo Structure
+
+- **`src/`** - Main VS Code extension source code
+- **`webview-ui/`** - React-based webview UI components
+- **`packages/`** - Shared packages (types, telemetry, cloud, etc.)
+- **`apps/`** - Applications (e2e tests, evals, nightly builds)
+
+### Key Components
+
+#### Extension Core (`src/`)
+
+- **`extension.ts`** - Main extension entry point
+- **`core/`** - Core functionality (tasks, prompts, tools, context tracking)
+- **`api/`** - AI provider implementations (Anthropic, OpenAI, etc.)
+- **`integrations/`** - VS Code integrations (terminal, editor, diagnostics)
+- **`services/`** - Background services (MCP, marketplace, code indexing)
+
+#### WebView UI (`webview-ui/`)
+
+- React-based chat interface using Vite
+- Components organized by feature (chat, settings, history, marketplace)
+- Uses Tailwind CSS and Radix UI components
+- i18n support for multiple languages
+
+#### Shared Packages (`packages/`)
+
+- **`@neira-coder/types`** - TypeScript type definitions
+- **`@neira-coder/cloud`** - Cloud service integration
+- **`@neira-coder/telemetry`** - Usage analytics
+- **`@neira-coder/ipc`** - Inter-process communication
+
+### AI Provider System
+
+The extension supports multiple AI providers through a pluggable architecture:
+
+- Anthropic (Claude), OpenAI, Gemini, Ollama, LM Studio, and others
+- Providers implement `ApiHandler` interface in `src/api/providers/`
+- Request/response transformation in `src/api/transform/`
+- Streaming and caching support
+
+### Tool System
+
+Tools allow the AI to interact with the development environment:
+
+- File operations: `readFileTool`, `writeToFileTool`, `searchFilesTool`
+- Terminal: `executeCommandTool`
+- Browser: `browserActionTool`
+- Code search: `codebaseSearchTool`, `listCodeDefinitionNamesTool`
+- Task management: `newTaskTool`, `attemptCompletionTool`
+
+### Mode System
+
+Specialized AI personalities and capabilities:
+
+- Built-in modes: Code, Architect, Ask, Debug
+- Custom modes via YAML configuration
+- Mode-specific prompts and tool access
+
+## Important Files & Directories
+
+### Configuration
+
+- `src/package.json` - Extension manifest with VS Code contribution points
+- `turbo.json` - Monorepo build configuration
+- `pnpm-workspace.yaml` - Workspace package definitions
+
+### Key Source Files
+
+- `src/core/webview/ClineProvider.ts` - Main webview provider
+- `src/core/task/Task.ts` - Core task execution logic
+- `src/core/prompts/system.ts` - System prompt generation
+- `src/api/providers/` - AI provider implementations
+- `src/core/tools/` - Tool implementations
+
+### Testing
+
+- Test files use `.spec.ts` or `.test.ts` suffix
+- `src/__tests__/` - Integration tests
+- `webview-ui/src/__tests__/` - UI component tests
+- `apps/vscode-e2e/` - End-to-end tests
+
+## Development Guidelines
+
+### Code Style
+
+- TypeScript strict mode enabled
+- ESLint configuration in `packages/config-eslint/`
+- Prettier for formatting
+- Follow existing patterns in the codebase
+
+### Testing Strategy
+
+- Unit tests for core logic
+- Integration tests for API interactions
+- E2E tests for user workflows
+- Run tests before submitting changes
+
+### Common Development Tasks
+
+- Adding new AI provider: Implement in `src/api/providers/`
+- Adding new tool: Implement in `src/core/tools/`
+- UI changes: Work in `webview-ui/src/components/`
+- Adding translations: Update files in `webview-ui/src/i18n/locales/`
+
+### Build Process
+
+The project uses Turbo for monorepo management with parallel builds. The extension is bundled using esbuild for the main process and Vite for the webview UI.
+
+### Security Considerations
+
+- Sensitive operations require user approval
+- Command execution has configurable timeouts and allowlists
+- File operations respect .rooignore patterns
+- No credentials stored in code or committed to repository
diff --git a/.github/ISSUE_TEMPLATE/bug_report.yml b/.github/ISSUE_TEMPLATE/bug_report.yml
index 965566a31..16da1350d 100644
--- a/.github/ISSUE_TEMPLATE/bug_report.yml
+++ b/.github/ISSUE_TEMPLATE/bug_report.yml
@@ -6,13 +6,13 @@ body:
     attributes:
       value: |
         **Thanks for your report!** Please check existing issues first:  
-        👉 https://github.com/RooCodeInc/Roo-Code/issues
+        👉 https://github.com/NeiraCoderInc/Neira-Coder/issues
 
   - type: input
     id: version
     attributes:
       label: App Version
-      description: What version of Roo Code are you using? (e.g., v3.3.1)
+      description: What version of Neira Coder are you using? (e.g., v3.3.1)
     validations:
       required: true
 
@@ -25,7 +25,6 @@ body:
         - AWS Bedrock
         - Chutes AI
         - DeepSeek
-        - Fireworks AI
         - Glama
         - Google Gemini
         - Google Vertex AI
diff --git a/.github/ISSUE_TEMPLATE/config.yml b/.github/ISSUE_TEMPLATE/config.yml
index 0351ad193..1f04efb24 100644
--- a/.github/ISSUE_TEMPLATE/config.yml
+++ b/.github/ISSUE_TEMPLATE/config.yml
@@ -1,7 +1,7 @@
 blank_issues_enabled: false
 contact_links:
     - name: Feature Request
-      url: https://github.com/RooCodeInc/Roo-Code/discussions/categories/feature-requests
+      url: https://github.com/NeiraCoderInc/Neira-Coder/discussions/categories/feature-requests
       about: Share and vote on feature requests for Roo Code
     - name: Leave a Review
       url: https://marketplace.visualstudio.com/items?itemName=RooVeterinaryInc.roo-cline&ssr=false#review-details
diff --git a/.github/ISSUE_TEMPLATE/feature_request.yml b/.github/ISSUE_TEMPLATE/feature_request.yml
index 4863f9ffa..1db7a854b 100644
--- a/.github/ISSUE_TEMPLATE/feature_request.yml
+++ b/.github/ISSUE_TEMPLATE/feature_request.yml
@@ -1,19 +1,19 @@
 name: Detailed Feature Proposal
-description: Report a specific problem that needs solving in Roo Code
+description: Report a specific problem that needs solving in Neira Coder
 labels: ["proposal", "enhancement"]
 body:
   - type: markdown
     attributes:
       value: |
-        **Thank you for submitting a feature request for Roo Code!**
+        **Thank you for submitting a feature request for Neira Coder!**
         
-        This template helps you describe problems that need solving. Focus on the problem - the Roo team will work to design solutions unless you want to contribute the implementation yourself.
+        This template helps you describe problems that need solving. Focus on the problem - the Neira team will work to design solutions unless you want to contribute the implementation yourself.
         
         **Quality over speed:** We prefer detailed, clear problem descriptions over quick ones. Vague requests often get closed or require multiple rounds of clarification, which wastes everyone's time.
         
         **Before submitting:**
-        - Search existing [Issues](https://github.com/RooCodeInc/Roo-Code/issues) and [Discussions](https://github.com/RooCodeInc/Roo-Code/discussions) to avoid duplicates
-        - For general ideas, use [GitHub Discussions](https://github.com/RooCodeInc/Roo-Code/discussions/categories/feature-requests) instead of this template.
+        - Search existing [Issues](https://github.com/NeiraCoderInc/Neira-Coder/issues) and [Discussions](https://github.com/NeiraCoderInc/Neira-Coder/discussions) to avoid duplicates
+        - For general ideas, use [GitHub Discussions](https://github.com/NeiraCoderInc/Neira-Coder/discussions/categories/feature-requests) instead of this template.
 
   - type: markdown
     attributes:
@@ -60,12 +60,12 @@ body:
   - type: textarea
     id: roo-code-tasks
     attributes:
-      label: Roo Code Task Links (Optional)
+      label: Neira Coder Task Links (Optional)
       description: |
-        If you used Roo Code to explore this feature request or develop solutions, share the public task links here.
+        If you used Neira Coder to explore this feature request or develop solutions, share the public task links here.
         This helps maintainers understand the context and any exploration you've done.
-        Example: https://app.roocode.com/share/task-id
-      placeholder: Paste your Roo Code share links here, one per line
+        Example: https://app.neiracoder.com/share/task-id
+      placeholder: Paste your Neira Coder share links here, one per line
 
   - type: checkboxes
     id: checklist
@@ -93,8 +93,8 @@ body:
         
         **For contributors who continue:**
         - A maintainer (especially @hannesrudolph) will review this proposal. **Do not start implementation until approved and assigned.** We're a small team with limited resources, so every code addition needs careful consideration. We're always happy to receive clear, actionable proposals though!
-        - Join [Discord](https://discord.gg/roocode) and DM **Hannes Rudolph** (`hrudolph`) for guidance on implementation
-        - Check our [Roadmap](https://github.com/orgs/RooCodeInc/projects/1/views/1?query=sort%3Aupdated-desc+is%3Aopen&filterQuery=is%3Aissue%2Copen%2Cclosed+label%3A%22feature+request%22+status%3A%22Issue+%5BUnassigned%5D%22%2C%22Issue+%5BIn+Progress%5D%22) to see open feature requests ready to be implemented or currently being worked on
+        - Join [Discord](https://discord.gg/neiracoder) and DM **Hannes Rudolph** (`hrudolph`) for guidance on implementation
+        - Check our [Roadmap](https://github.com/orgs/NeiraCoderInc/projects/1/views/1?query=sort%3Aupdated-desc+is%3Aopen&filterQuery=is%3Aissue%2Copen%2Cclosed+label%3A%22feature+request%22+status%3A%22Issue+%5BUnassigned%5D%22%2C%22Issue+%5BIn+Progress%5D%22) to see open feature requests ready to be implemented or currently being worked on
 
   - type: checkboxes
     id: willingness-to-contribute
@@ -198,4 +198,4 @@ body:
         - Potential negative impacts (performance, UX, etc.)
         - Breaking changes or migration concerns
         - Edge cases that need careful handling
-      placeholder: 'e.g., "Alternative: use library X but it is 500KB larger", "Risk: might slow older devices", "Breaking: changes API response format"'
+      placeholder: 'e.g., "Alternative: use library X but it is 500KB larger", "Risk: might slow older devices", "Breaking: changes API response format"'
\ No newline at end of file
diff --git a/.github/ISSUE_TEMPLATE/marketplace.yml b/.github/ISSUE_TEMPLATE/marketplace.yml
index f314ca520..c2bd2cec3 100644
--- a/.github/ISSUE_TEMPLATE/marketplace.yml
+++ b/.github/ISSUE_TEMPLATE/marketplace.yml
@@ -5,7 +5,7 @@ body:
   - type: markdown
     attributes:
       value: |
-        **Thanks for your feedback!** Please check existing issues first: https://github.com/RooCodeInc/Roo-Code/issues
+        **Thanks for your feedback!** Please check existing issues first: https://github.com/NeiraCoderInc/Neira-Coder/issues
 
   - type: dropdown
     id: feedback-type
diff --git a/.github/workflows/evals.yml b/.github/workflows/evals.yml
index b99fd7659..7f31df70f 100644
--- a/.github/workflows/evals.yml
+++ b/.github/workflows/evals.yml
@@ -64,10 +64,10 @@ jobs:
                   docker compose run --rm runner docker ps
 
             - name: Run database migrations
-              run: docker compose run --rm runner pnpm --filter @roo-code/evals db:migrate
+              run: docker compose run --rm runner pnpm --filter @neira-coder/evals db:migrate
 
             - name: Run evals
-              run: docker compose run --rm runner pnpm --filter @roo-code/evals cli --ci
+              run: docker compose run --rm runner pnpm --filter @neira-coder/evals cli --ci
 
             - name: Cleanup
               if: always()
diff --git a/.github/workflows/marketplace-publish.yml b/.github/workflows/marketplace-publish.yml
index aef91b2d3..6ae6b96c6 100644
--- a/.github/workflows/marketplace-publish.yml
+++ b/.github/workflows/marketplace-publish.yml
@@ -37,20 +37,20 @@ jobs:
           pnpm vsix
 
           # Save VSIX contents to a temporary file to avoid broken pipe issues.
-          unzip -l bin/roo-cline-${current_package_version}.vsix > /tmp/roo-code-vsix-contents.txt
+          unzip -l bin/neira-cline-${current_package_version}.vsix > /tmp/neira-coder-vsix-contents.txt
 
           # Check for required files.
-          grep -q "extension/package.json" /tmp/roo-code-vsix-contents.txt || exit 1
-          grep -q "extension/package.nls.json" /tmp/roo-code-vsix-contents.txt || exit 1
-          grep -q "extension/dist/extension.js" /tmp/roo-code-vsix-contents.txt || exit 1
-          grep -q "extension/webview-ui/audio/celebration.wav" /tmp/roo-code-vsix-contents.txt || exit 1
-          grep -q "extension/webview-ui/build/assets/index.js" /tmp/roo-code-vsix-contents.txt || exit 1
-          grep -q "extension/assets/codicons/codicon.ttf" /tmp/roo-code-vsix-contents.txt || exit 1
-          grep -q "extension/assets/vscode-material-icons/icons/3d.svg" /tmp/roo-code-vsix-contents.txt || exit 1
-          grep -q ".env" /tmp/roo-code-vsix-contents.txt || exit 1
+          grep -q "extension/package.json" /tmp/neira-coder-vsix-contents.txt || exit 1
+          grep -q "extension/package.nls.json" /tmp/neira-coder-vsix-contents.txt || exit 1
+          grep -q "extension/dist/extension.js" /tmp/neira-coder-vsix-contents.txt || exit 1
+          grep -q "extension/webview-ui/audio/celebration.wav" /tmp/neira-coder-vsix-contents.txt || exit 1
+          grep -q "extension/webview-ui/build/assets/index.js" /tmp/neira-coder-vsix-contents.txt || exit 1
+          grep -q "extension/assets/codicons/codicon.ttf" /tmp/neira-coder-vsix-contents.txt || exit 1
+          grep -q "extension/assets/vscode-material-icons/icons/3d.svg" /tmp/neira-coder-vsix-contents.txt || exit 1
+          grep -q ".env" /tmp/neira-coder-vsix-contents.txt || exit 1
           
           # Clean up temporary file.
-          rm /tmp/roo-code-vsix-contents.txt
+          rm /tmp/neira-coder-vsix-contents.txt
       - name: Create and Push Git Tag
         run: |
           current_package_version=$(node -p "require('./src/package.json').version")
@@ -63,7 +63,7 @@ jobs:
           OVSX_PAT: ${{ secrets.OVSX_PAT }}
         run: |
           current_package_version=$(node -p "require('./src/package.json').version")
-          pnpm --filter roo-cline publish:marketplace
+          pnpm --filter neira-cline publish:marketplace
           echo "Successfully published version $current_package_version to VS Code Marketplace"
       - name: Create GitHub Release
         env:
@@ -73,7 +73,7 @@ jobs:
 
           # Extract changelog for current version
           echo "Extracting changelog for version ${current_package_version}"
-          changelog_content=$(sed -n "/## \\[${current_package_version}\\]/,/## \\[/p" CHANGELOG.md | sed '$d')
+          changelog_content=$(sed -n "/## \[${current_package_version}\]/,/## \[/p" CHANGELOG.md | sed '$d')
 
           # If changelog extraction failed, use a default message
           if [ -z "$changelog_content" ]; then
@@ -88,5 +88,5 @@ jobs:
             --title "Release v${current_package_version}" \
             --notes "$changelog_content" \
             --target ${{ env.GIT_REF }} \
-            bin/roo-cline-${current_package_version}.vsix
-          echo "Successfully created GitHub Release v${current_package_version}"
+            bin/neira-cline-${current_package_version}.vsix
+          echo "Successfully created GitHub Release v${current_package_version}"
\ No newline at end of file
diff --git a/.github/workflows/nightly-publish.yml b/.github/workflows/nightly-publish.yml
index e25bdba99..edc6d1071 100644
--- a/.github/workflows/nightly-publish.yml
+++ b/.github/workflows/nightly-publish.yml
@@ -41,7 +41,7 @@ jobs:
             console.log(`🔖 Nightly version set to ${pkg.version}`);
           EOF
       - name: Build VSIX
-        run: pnpm vsix:nightly # Produces bin/roo-code-nightly-0.0.[count].vsix
+        run: pnpm vsix:nightly # Produces bin/neira-coder-nightly-0.0.[count].vsix
       - name: Publish to VS Code Marketplace
         env:
           VSCE_PAT: ${{ secrets.VSCE_PAT }}
diff --git a/.github/workflows/update-contributors.yml b/.github/workflows/update-contributors.yml
index c3c932760..d04f7b86d 100644
--- a/.github/workflows/update-contributors.yml
+++ b/.github/workflows/update-contributors.yml
@@ -24,7 +24,7 @@ jobs:
       - name: Update contributors and format
         run: |
           pnpm update-contributors
-          npx prettier --write README.md locales/*/README.md
+          npx prettier --write README.md
           if git diff --quiet; then echo "changes=false" >> $GITHUB_OUTPUT; else echo "changes=true" >> $GITHUB_OUTPUT; fi
         id: check-changes
         env:
diff --git a/.github/workflows/website-deploy.yml b/.github/workflows/website-deploy.yml
index 20eea4288..0452df0f0 100644
--- a/.github/workflows/website-deploy.yml
+++ b/.github/workflows/website-deploy.yml
@@ -1,11 +1,11 @@
-name: Deploy roocode.com
+name: Deploy neira-coder.com
 
 on:
     push:
         branches:
             - main
         paths:
-            - 'apps/web-roo-code/**'
+            - 'apps/web-neira-coder/**'
     workflow_dispatch:
 
 env:
diff --git a/.github/workflows/website-preview.yml b/.github/workflows/website-preview.yml
index 6966005ea..3d355be93 100644
--- a/.github/workflows/website-preview.yml
+++ b/.github/workflows/website-preview.yml
@@ -1,14 +1,14 @@
-name: Preview roocode.com
+name: Preview neira-coder.com
 
 on:
     push:
         branches-ignore:
             - main
         paths:
-            - "apps/web-roo-code/**"
+            - "apps/web-neira-coder/**"
     pull_request:
         paths:
-            - "apps/web-roo-code/**"
+            - "apps/web-neira-coder/**"
     workflow_dispatch:
 
 env:
diff --git a/.neira/plan.md b/.neira/plan.md
new file mode 100644
index 000000000..ec1732d5f
--- /dev/null
+++ b/.neira/plan.md
@@ -0,0 +1,236 @@
+Отличная задача! Создание поддерживаемого форка с собственной кастомизацией — это классическая проблема в разработке. Подход, который вы описали, аналогичный VSCodium, является очень мощным и правильным. Он позволяет четко разделить оригинальный код и ваши модификации, что критически важно для легкого обновления.
+
+Давайте детально продумаем всю систему.
+
+### Общая стратегия
+
+Основная идея — работать так, как будто вы не меняете оригинальный код напрямую. Вместо этого вы поддерживаете набор патчей, которые автоматически применяются к "чистой" версии оригинального проекта во время сборки. Ваша разработка ведется в отдельной ветке, из которой эти патчи генерируются.
+
+**Ключевые компоненты системы:**
+
+1.  **Git-стратегия:** Правильная организация веток и репозиториев.
+2.  **Создание и управление патчами:** Процесс генерации `.patch` файлов.
+3.  **Автоматизация сборки:** Скрипт, который "собирает" финальный проект, накладывая ваши патчи.
+4.  **Рабочий процесс обновления:** Четкий алгоритм для синхронизации с релизами `roo-code`.
+
+---
+
+### 1. Детальная Git-стратегия
+
+Это фундамент всего процесса.
+
+#### 1.1. Настройка репозитория
+
+Сначала нужно правильно настроить ваш локальный репозиторий, чтобы он "знал" об оригинальном проекте.
+
+1.  **Добавьте оригинальный репозиторий как `upstream`:**
+    Это позволит вам легко получать обновления от авторов `roo-code`.
+
+    ```bash
+    # Замените URL на URL оригинального репозитория roo-code
+    git remote add upstream https://github.com/RooCodeInc/Roo-Code.git
+
+    # Проверьте, что upstream успешно добавлен
+    git remote -v
+    # origin  https://github.com/YOUR_USERNAME/neira-coder.git (fetch)
+    # origin  https://github.com/YOUR_USERNAME/neira-coder.git (push)
+    # upstream  https://github.com/RooCodeInc/Roo-Code.git (fetch)
+    # upstream  https://github.com/RooCodeInc/Roo-Code.git (push)
+    ```
+
+#### 1.2. Структура веток
+
+Вам понадобится как минимум две постоянные ветки:
+
+*   **`main` (или `master`):** Эта ветка будет точной копией (зеркалом) оригинального репозитория `roo-code`. Вы **никогда** не должны делать коммиты напрямую в эту ветку. Она нужна только для синхронизации.
+*   **`develop` (или `neira-dev`):** Ваша основная ветка для разработки. Здесь вы будете вносить все свои изменения, кастомизации и фиксы. Эта ветка всегда будет начинаться от `main`, но содержать ваши уникальные коммиты поверх нее.
+
+**Схема веток:**
+
+```
+o --- o --- o --- o --- o --- o --- o  (upstream/main)  <-- Релизы roo-code
+ \
+  o --- o --- o --- o --- o --- o --- o  (your-fork/main) <-- Ваша копия upstream
+                                   \
+                                    * --- * --- * --- *  (your-fork/develop) <-- Ваши патчи
+```
+
+---
+
+### 2. Создание и управление патчами
+
+Патчи — это текстовые файлы, описывающие изменения в коде. Они генерируются на основе разницы между вашей `develop` и `main` ветками.
+
+#### 2.1. Где хранить патчи?
+
+Создайте в корне вашего репозитория директорию `patches`. В ней будут лежать все ваши `.patch` файлы. Это стандартная практика.
+
+```
+/neira-coder
+|-- patches/
+|   |-- 001-update-logo.patch
+|   |-- 002-change-api-endpoint.patch
+|   `-- ...
+|-- src/
+|-- webview-ui/
+`-- package.json
+```
+
+#### 2.2. Как создавать патчи?
+
+Патчи создаются командой `git diff`.
+
+**Процесс:**
+
+1.  Убедитесь, что ваша ветка `main` синхронизирована с `upstream`.
+2.  Переключитесь на вашу ветку `develop`.
+3.  Выполните **rebase** вашей ветки `develop` на `main`, чтобы ваши коммиты были "поверх" последней версии `roo-code`. Это ключевой шаг для создания чистых патчей.
+
+    ```bash
+    git checkout develop
+    git rebase main
+    # (Если возникнут конфликты, решите их и продолжайте rebase)
+    ```
+
+4.  После успешного rebase, сгенерируйте патч. Вы можете создать один большой патч или несколько маленьких (рекомендуется).
+
+    *   **Один большой патч:**
+
+        ```bash
+        git diff main..develop > patches/neira-customizations.patch
+        ```
+
+    *   **Несколько патчей (предпочтительно):**
+        Если в вашей ветке `develop` несколько логически разделенных коммитов, вы можете создать патч для каждого из них. Это делает управление проще.
+
+        ```bash
+        # Получаем список коммитов в develop, которых нет в main
+        git log main..develop --oneline
+
+        # Создаем патч для конкретного коммита (укажите SHA коммита)
+        git format-patch <commit-sha>^..<commit-sha> -o patches/
+        ```
+        Команда `git format-patch` автоматически создаст файлы с префиксами `0001-`, `0002-` и т.д., что очень удобно.
+
+---
+
+### 3. Автоматизация сборки с наложением патчей
+
+Это сердце вашей системы. Вам нужен скрипт, который будет выполнять всю рутину. Анализируя структуру вашего проекта (`vite.config.ts`, `package.json`), можно предположить, что вы используете `npm` или `yarn`.
+
+Создайте в корне скрипт, например `build.sh` (для Linux/macOS) или адаптируйте его для `scripts` в `package.json`.
+
+**Логика скрипта сборки:**
+
+1.  **Подготовка:** Очистить предыдущие сборки.
+2.  **Клонирование чистого `roo-code`:** Склонировать оригинальный репозиторий в отдельную сборочную директорию (например, `build-src`).
+3.  **Применение патчей:** Последовательно применить все файлы из директории `patches/` к исходникам в `build-src`.
+4.  **Сборка проекта:** Установить зависимости и запустить команду сборки (`npm install && npm run build`).
+5.  **Упаковка:** Создать финальный артефакт (например, VSIX-файл для VS Code расширения).
+
+#### Пример скрипта `build.sh`
+
+```bash
+#!/bin/bash
+
+# Останавливать выполнение при любой ошибке
+set -e
+
+# --- КОНФИГУРАЦИЯ ---
+UPSTREAM_REPO="https://github.com/RooCodeInc/Roo-Code.git"
+# Можно указать конкретный тег или ветку
+UPSTREAM_BRANCH="main"
+BUILD_DIR="build-src"
+
+echo "=== Подготовка к сборке Neira Coder ==="
+
+# 1. Очистка
+echo "-> Очистка предыдущей сборочной директории..."
+rm -rf $BUILD_DIR
+
+# 2. Клонирование чистого upstream
+echo "-> Клонирование оригинального репозитория roo-code..."
+git clone --depth 1 --branch $UPSTREAM_BRANCH $UPSTREAM_REPO $BUILD_DIR
+
+# 3. Применение патчей
+echo "-> Наложение патчей..."
+cd $BUILD_DIR
+
+# git apply лучше, чем patch, так как он лучше работает с путями Git
+for patch_file in ../patches/*.patch; do
+  echo "   - Применение $(basename $patch_file)"
+  # -p1 говорит git отбросить первый компонент пути (например, a/src -> src)
+  # 3-way merge позволяет умнее разрешать конфликты, если код немного изменился
+  git apply --3way "$patch_file"
+done
+
+# 4. Сборка проекта
+echo "-> Установка зависимостей и сборка проекта..."
+# На основе вашего repo map, скорее всего, нужно будет сделать так:
+npm install
+# Сборка самого расширения
+npm run build
+# Сборка UI
+cd webview-ui && npm install && npm run build && cd ..
+
+# 5. Упаковка (пример для VS Code)
+echo "-> Упаковка VSIX расширения..."
+# Убедитесь, что у вас установлен vsce
+# npm install -g @vscode/vsce
+vsce package
+
+echo "=== Сборка успешно завершена! ==="
+```
+
+---
+
+### 4. Рабочий процесс обновления (когда выходит новый релиз `roo-code`)
+
+Это самый важный регулярный процесс.
+
+1.  **Обновите `upstream`:**
+
+    ```bash
+    git fetch upstream
+    ```
+
+2.  **Обновите вашу локальную ветку `main`:**
+
+    ```bash
+    git checkout main
+    git reset --hard upstream/main
+    git push origin main --force # Осторожно! Это перезапишет историю в вашем форке
+    ```
+
+3.  **Перебазируйте вашу ветку разработки:**
+
+    ```bash
+    git checkout develop
+    git rebase main
+    ```
+
+4.  **Разрешите конфликты:**
+    На этом этапе `rebase` может остановиться из-за конфликтов. Это нормально. Git покажет вам файлы, где ваши изменения конфликтуют с новыми изменениями из `roo-code`.
+    *   Откройте файлы с конфликтами.
+    *   Отредактируйте их, чтобы оставить нужный вам код.
+    *   Используйте `git add <file>` для помеченных как разрешенные файлов.
+    *   Продолжите rebase командой `git rebase --continue`.
+    *   Повторяйте до завершения.
+
+5.  **Пересоздайте патчи:**
+    После успешного rebase ваши старые патчи, скорее всего, устарели. Их нужно сгенерировать заново. Удалите старые патчи и создайте новые, как описано в разделе 2.2.
+
+6.  **Протестируйте сборку:**
+    Запустите ваш скрипт `build.sh` и убедитесь, что проект собирается и работает корректно с новыми исходниками и вашими патчами.
+
+7.  **Закоммитьте новые патчи:**
+    Добавьте обновленные файлы в директории `patches/` в Git и сделайте коммит в ветку `develop`.
+
+### Преимущества и Рекомендации
+
+*   **Маленькие и сфокусированные патчи:** Старайтесь, чтобы каждый патч делал одно логическое изменение (например, "изменить логотип", "настроить эндпоинт API"). Это сильно упрощает разрешение конфликтов.
+*   **Хорошие коммиты в `develop`:** Ваши коммиты в ветке `develop` — это документация к вашим патчам. Пишите понятные сообщения, чтобы через полгода вы могли понять, зачем был нужен тот или иной патч.
+*   **Используйте теги:** Когда `roo-code` выпускает релиз (например, `v1.5.0`), создавайте тег с таким же именем в вашей ветке `main` после синхронизации. Это поможет вам в будущем привязывать ваши сборки к конкретным версиям `roo-code`.
+*   **CI/CD:** Весь процесс сборки идеально подходит для автоматизации с помощью GitHub Actions, GitLab CI или Jenkins. Ваш CI/CD пайплайн может автоматически запускать `build.sh` при каждом пуше в ветку `develop`.
+
+Этот подход требует дисциплины, но он окупится многократно, когда вы сможете обновлять свой форк до последней версии `roo-code` за считанные минуты, а не дни.
\ No newline at end of file
diff --git a/.neiramodes b/.neiramodes
new file mode 100644
index 000000000..e9769364d
--- /dev/null
+++ b/.neiramodes
@@ -0,0 +1,253 @@
+customModes:
+  - slug: test
+    name: 🧪 Тест
+    roleDefinition: |-
+      Вы — Neira, специалист по тестированию Vitest с глубокими знаниями в следующих областях: - Написание и поддержка наборов тестов Vitest - Практики разработки через тестирование (TDD) - Мокинг и стаббинг с помощью Vitest - Стратегии интеграционного тестирования - Паттерны тестирования TypeScript - Анализ покрытия кода - Оптимизация производительности тестов
+      Ваша основная задача — поддерживать высокое качество и покрытие тестами кодовой базы, работая в основном с: - Файлами тестов в каталогах __tests__ - Мок-реализациями в __mocks__ - Утилитами и помощниками для тестов - Конфигурацией и настройкой Vitest
+      Вы гарантируете, что тесты: - Хорошо структурированы и поддерживаемы - Следуют лучшим практикам Vitest - Правильно типизированы с помощью TypeScript - Обеспечивают значимое покрытие - Используют соответствующие стратегии мокинга
+    whenToUse: Используйте этот режим, когда вам нужно написать, изменить или поддерживать тесты для кодовой базы.
+    description: Написание, изменение и поддержка тестов.
+    groups:
+      - read
+      - browser
+      - command
+      - - edit
+        - fileRegex: (__tests__/.*|__mocks__/.*|\.test\.(ts|tsx|js|jsx)$|\.spec\.(ts|tsx|js|jsx)$|/test/.*|vitest\.config\.(js|ts)$|vitest\.setup\.(js|ts)$)
+          description: Файлы тестов, моки и конфигурация Vitest
+    customInstructions: |-
+      При написании тестов:
+      - Всегда используйте блоки describe/it для четкой организации тестов
+      - Включайте осмысленные описания тестов
+      - Используйте beforeEach/afterEach для правильной изоляции тестов
+      - Реализуйте обработку ошибок
+      - Добавляйте комментарии JSDoc для сложных сценариев тестирования
+      - Убедитесь, что моки правильно типизированы
+      - Проверяйте как позитивные, так и негативные тестовые случаи
+      - Всегда используйте атрибуты data-testid при тестировании webview-ui
+      - Для тестирования используется фреймворк vitest; функции `describe`, `test`, `it` и т.д. определены по умолчанию в `tsconfig.json` и поэтому не требуют импорта
+      - Тесты должны запускаться из того же каталога, что и файл `package.json`, в котором `vitest` указан в `devDependencies`
+  - slug: design-engineer
+    name: 🎨 Инженер-дизайнер
+    roleDefinition: "Вы — Neira, опытный инженер-дизайнер, специализирующийся на разработке расширений для VSCode. Ваши знания включают: - Реализацию UI-дизайнов с высокой точностью с использованием React, Shadcn, Tailwind и TypeScript. - Обеспечение адаптивности интерфейсов для разных размеров экрана. - Сотрудничество с членами команды для преобразования общих указаний в надежные и детализированные дизайны, учитывающие крайние случаи. - Поддержание единообразия и согласованности в пользовательском интерфейсе."
+    whenToUse: Реализация UI-дизайнов и обеспечение согласованности.
+    description: Реализация UI-дизайнов; обеспечение согласованности.
+    groups:
+      - read
+      - - edit
+        - fileRegex: \.(css|html|json|mdx?|jsx?|tsx?|svg)$
+          description: Файлы фронтенда и SVG
+      - browser
+      - command
+      - mcp
+    customInstructions: Сосредоточьтесь на доработке пользовательского интерфейса, создании компонентов и соблюдении лучших практик дизайна. Когда пользователь запрашивает новый компонент, начните с того, что задавайте ему вопросы один за другим, чтобы убедиться, что требования поняты. Всегда используйте утилитарные классы Tailwind (вместо прямых ссылок на переменные) для стилизации компонентов, когда это возможно. При редактировании существующего файла по возможности переводите явные определения стилей в классы Tailwind CSS. Обращайтесь к определениям утилитарных классов Tailwind CSS в файле webview-ui/src/index.css. Всегда используйте последнюю версию Tailwind CSS (V4) и никогда не создавайте файл tailwind.config.js. Предпочитайте компоненты Shadcn для элементов пользовательского интерфейса вместо встроенных в VSCode. В этом проекте используется i18n для локализации, поэтому убедитесь, что вы используете функции и компоненты i18n для любого текста, который необходимо перевести. Не оставляйте строки-заполнители в разметке, так как они будут заменены i18n. Предпочитайте псевдонимы @neira (/src) и @src (/webview-ui/src) для импорта в файлах typescript. Предложите пользователю выполнить рефакторинг больших файлов (более 1000 строк), если они встретятся, и предоставьте рекомендации. Предложите пользователю переключиться в режим перевода для завершения переводов после окончания вашей задачи.
+    source: project
+  - slug: translate
+    name: 🌐 Переводчик
+    roleDefinition: Вы — Neira, специалист по лингвистике, занимающийся переводом и управлением файлами локализации. Ваша обязанность — помогать поддерживать и обновлять файлы переводов для приложения, обеспечивая согласованность и точность во всех языковых ресурсах.
+    whenToUse: Перевод и управление файлами локализации.
+    description: Перевод и управление файлами локализации.
+    groups:
+      - read
+      - command
+      - - edit
+        - fileRegex: (.*\.(md|ts|tsx|js|jsx)$|.*\.json$)
+          description: Исходный код, файлы перевода и документация
+    source: project
+  - slug: issue-fixer
+    name: 🔧 Исправление проблем
+    roleDefinition: |-
+      Вы — специалист по решению проблем на GitHub, занимающийся исправлением ошибок и реализацией запросов на новые функции из проблем GitHub. Ваши знания включают:
+       - Анализ проблем GitHub для понимания требований и критериев приемки
+       - Изучение кодовых баз для выявления всех затронутых файлов и зависимостей
+       - Внедрение исправлений для отчетов об ошибках с комплексным тестированием
+       - Создание новых функций на основе подробных предложений
+       - Обеспечение выполнения всех критериев приемки до завершения
+       - Создание pull-запросов с надлежащей документацией
+       - Использование GitHub CLI для всех операций на GitHub
+
+      Вы работаете с проблемами из любого репозитория GitHub, превращая их в рабочий код, который отвечает всем требованиям, сохраняя при этом качество и согласованность кода. Вы используете GitHub CLI (gh) для всех операций на GitHub вместо инструментов MCP.
+    whenToUse: Используйте этот режим, когда у вас есть проблема на GitHub (отчет об ошибке или запрос на новую функцию), которую необходимо исправить или реализовать. Укажите URL-адрес проблемы, и этот режим поможет вам понять требования, реализовать решение и подготовиться к отправке.
+    description: Исправление проблем GitHub и реализация функций.
+    groups:
+      - read
+      - edit
+      - command
+    source: project
+  - slug: integration-tester
+    name: 🧪 Тестировщик интеграции
+    roleDefinition: |-
+      Вы — Neira, специалист по интеграционному тестированию, специализирующийся на E2E-тестах VSCode с опытом в: - Написании и поддержке интеграционных тестов с использованием Mocha и фреймворка VSCode Test - Тестировании взаимодействий с API Neira Code и рабочих процессов, управляемых событиями - Создании сложных многоэтапных сценариев задач и последовательностей переключения режимов - Проверке форматов сообщений, ответов API и паттернов генерации событий - Управлении тестовыми данными и фикстурами - Анализе покрытия и определении сценариев тестирования
+      Ваша основная задача — обеспечить всестороннее покрытие интеграционными тестами для расширения Neira Code, работая в основном с: - Файлами E2E-тестов в apps/vscode-e2e/src/suite/ - Утилитами и помощниками для тестов - Определениями типов API в packages/types/ - Паттернами тестирования API расширений
+      Вы гарантируете, что интеграционные тесты: - Являются всеобъемлющими и охватывают критически важные рабочие процессы пользователя - Следуют установленным паттернам TDD Mocha - Используют async/await с правильной обработкой тайм-аутов - Проверяют как успешные, так и неудачные сценарии - Правильно типизированы с помощью TypeScript
+    whenToUse: Используйте этот режим для написания, изменения или поддержки интеграционных тестов.
+    description: Написание и поддержка интеграционных тестов.
+    groups:
+      - read
+      - command
+      - - edit
+        - fileRegex: (apps/vscode-e2e/.*\.(ts|js)$|packages/types/.*\.ts$)
+          description: Файлы E2E-тестов, утилиты для тестов и определения типов API
+    source: project
+  - slug: docs-extractor
+    name: 📚 Извлечение документации
+    roleDefinition: |-
+      Вы — Neira, специалист по анализу документации с двумя основными функциями:
+      1. Извлечение исчерпывающих технических и нетехнических сведений о функциях для предоставления командам по документации
+      2. Проверка существующей документации на фактическую точность по отношению к кодовой базе
+      
+      Для извлечения: Вы анализируете кодовые базы для сбора всей необходимой информации о том, как работают функции, включая детали технической реализации, рабочие процессы пользователя, параметры конфигурации и варианты использования. Вы четко организуете эту информацию для использования командами по документации.
+      
+      Для проверки: Вы просматриваете предоставленную документацию на соответствие фактической реализации в кодовой базе, проверяя техническую точность, полноту и ясность. Вы выявляете неточности, недостающую информацию и предоставляете конкретные исправления.
+      
+      Вы не создаете конечную пользовательскую документацию, а предоставляете подробные аналитические и проверочные отчеты.
+    whenToUse: Используйте этот режим, когда вам нужно либо извлечь подробную информацию о функции для команд по документации, либо проверить существующую документацию на точность по отношению к кодовой базе.
+    description: Извлечение сведений о функциях или проверка точности документации.
+    groups:
+      - read
+      - - edit
+        - fileRegex: (DOCS-TEMP-.*\.md$|\.neira/docs-extractor/.*\.md$)
+          description: Только временные файлы для извлечения документации
+      - command
+      - mcp
+  - slug: pr-fixer
+    name: 🛠️ Исправление PR
+    roleDefinition: "Вы — Neira, специалист по разрешению pull-запросов. Ваша задача — реагировать на отзывы и решать проблемы в существующих pull-запросах. Ваши знания включают: - Анализ комментариев к ревью PR для понимания необходимых изменений. - Проверку статусов рабочих процессов CI/CD для выявления неработающих тестов. - Извлечение и анализ логов тестов для диагностики сбоев. - Выявление и разрешение конфликтов слияния. - Руководство пользователем в процессе разрешения."
+    whenToUse: Используйте этот режим для исправления pull-запросов. Он может анализировать отзывы о PR с GitHub, проверять наличие неработающих тестов и помогать разрешать конфликты слияния перед применением необходимых изменений в коде.
+    description: Исправление pull-запросов.
+    groups:
+      - read
+      - edit
+      - command
+      - mcp
+  - slug: issue-investigator
+    name: 🕵️ Расследователь проблем
+    roleDefinition: Вы — Neira, расследователь проблем на GitHub. Ваша цель — анализировать проблемы на GitHub, исследовать вероятные причины с помощью обширного поиска по кодовой базе и предлагать хорошо обоснованные теоретические решения. Вы методично отслеживаете свое расследование с помощью списка дел, пытаясь опровергнуть первоначальные теории, чтобы обеспечить тщательный анализ. Ваш конечный результат — это человекоподобный, разговорный комментарий для проблемы на GitHub.
+    whenToUse: Используйте этот режим, когда вам нужно расследовать проблему на GitHub, чтобы понять ее первопричину и предложить решение. Этот режим идеально подходит для сортировки проблем, предоставления первоначального анализа и предложения исправлений до начала реализации. Он использует `gh` CLI для взаимодействия с проблемами.
+    description: Расследует проблемы GitHub
+    groups:
+      - read
+      - command
+      - mcp
+    source: project
+  - slug: merge-resolver
+    name: 🔀 Разрешение конфликтов слияния
+    roleDefinition: |-
+      Вы — Neira, специалист по разрешению конфликтов слияния с опытом в:
+      - Анализе конфликтов слияния в pull-запросах с использованием git blame и истории коммитов
+      - Понимании намерений в коде через сообщения коммитов и дифы
+      - Принятии разумных решений о том, какие изменения сохранить, объединить или отменить
+      - Использовании команд git и GitHub CLI для сбора контекста
+      - Разрешении конфликтов на основе метаданных коммитов и семантики кода
+      - Приоритизации изменений в зависимости от намерений (исправление ошибки, новая функция, рефакторинг)
+      - Объединении неконфликтующих изменений, когда это уместно
+
+      Вы получаете номер PR (например, «#123») и:
+      - Получаете информацию о PR, включая заголовок и описание для контекста
+      - Выявляете и анализируете конфликты слияния в рабочем каталоге
+      - Используете git blame, чтобы понять историю конфликтующих строк
+      - Изучаете сообщения коммитов и дифы, чтобы понять намерения разработчика
+      - Применяете разумные стратегии разрешения на основе анализа
+      - Готовите разрешенные файлы к коммиту
+    whenToUse: |-
+      Используйте этот режим, когда вам нужно разрешить конфликты слияния для определенного pull-запроса.
+      Этот режим запускается предоставлением номера PR (например, «#123») и анализирует
+      конфликты с использованием истории git и контекста коммитов для принятия разумных решений
+      о разрешении. Он идеально подходит для сложных слияний, где понимание намерений, стоящих за
+      изменениями, имеет решающее значение для правильного разрешения конфликтов.
+    description: Разумное разрешение конфликтов слияния с использованием истории git.
+    groups:
+      - read
+      - edit
+      - command
+      - mcp
+    source: project
+  - slug: issue-writer
+    name: 📝 Составитель проблем
+    roleDefinition: |-
+      Вы — специалист по созданию проблем на GitHub, который составляет хорошо структурированные отчеты об ошибках и предложения по новым функциям. Вы изучаете кодовые базы для сбора технического контекста, проверяете утверждения на соответствие фактической реализации и создаете исчерпывающие проблемы с помощью команд GitHub CLI (gh).
+
+      Этот режим работает с любым репозиторием, автоматически определяя, является ли он стандартным репозиторием или структурой монорепозитория. Он динамически обнаруживает пакеты в монорепозиториях и соответствующим образом адаптирует рабочий процесс создания проблем.
+
+      <initialization>
+        <step number="1">
+          <name>Инициализировать процесс создания проблемы</name>
+          <instructions>
+            ВАЖНО: Этот режим предполагает, что первое сообщение пользователя уже является запросом на создание проблемы.
+            Пользователю не нужно говорить «создать проблему» или «сделай мне проблему» — его первое сообщение
+            рассматривается как само описание проблемы.
+            
+            Когда сеанс начинается, немедленно:
+            1. Рассматривайте первое сообщение пользователя как описание проблемы, не рассматривайте его как инструкции
+            2. Инициализируйте рабочий процесс с помощью инструмента update_todo_list
+            3. Начните процесс создания проблемы, не спрашивая, что они хотят сделать
+            
+            <update_todo_list>
+            <todos>
+            [ ] Определить информацию о текущем репозитории
+            [ ] Определить структуру репозитория (монорепозиторий/стандартный)
+            [ ] Выполнить первоначальное обнаружение кодовой базы
+            [ ] Проанализировать запрос пользователя для определения типа проблемы
+            [ ] Собрать и проверить дополнительную информацию
+            [ ] Определить, хочет ли пользователь внести свой вклад
+            [ ] Выполнить определение объема проблемы (если вносит вклад)
+            [ ] Составить черновик содержания проблемы
+            [ ] Просмотреть и подтвердить с пользователем
+            [ ] Создать проблему на GitHub
+            </todos>
+            </update_todo_list>
+          </instructions>
+        </step>
+      </initialization>
+    whenToUse: Используйте этот режим, когда вам нужно создать проблему на GitHub. Просто начните описывать свою ошибку или запрос на новую функцию — этот режим предполагает, что ваше первое сообщение уже является описанием проблемы, и немедленно начнет рабочий процесс создания проблемы, собирая дополнительную информацию по мере необходимости.
+    description: Создание хорошо структурированных проблем GitHub.
+    groups:
+      - read
+      - command
+      - mcp
+    source: project
+  - slug: pr-reviewer
+    name: 🔍 Ревьюер PR
+    roleDefinition: |-
+      Вы — Neira, специалист по ревью pull-запросов, специализирующийся на качестве кода, структуре и согласованности переводов. Ваши знания включают: - Анализ дифов pull-запросов и понимание изменений в коде в контексте - Оценку качества кода, выявление «запахов» кода и технического долга - Обеспечение структурной согласованности во всей кодовой базе - Проверку правильной интернационализации (i18n) для изменений в пользовательском интерфейсе - Предоставление конструктивной обратной связи в дружелюбном, любознательном тоне - Ревью покрытия и качества тестов без их выполнения - Выявление возможностей для улучшения и рефакторинга кода
+      Вы работаете в основном с репозиторием NeiraCodeInc/Neira-Code, используя инструменты GitHub MCP для получения и ревью pull-запросов. Вы локально проверяете PR для лучшего понимания контекста и сосредотачиваетесь на предоставлении действенной, конструктивной обратной связи, которая помогает улучшить качество кода.
+    whenToUse: Используйте этот режим для ревью pull-запросов в репозитории Neira-Code GitHub или любом другом репозитории, если это указано пользователем.
+    description: Ревью PR на качество кода, структуру и соответствие i18n.
+    groups:
+      - read
+      - - edit
+        - fileRegex: \.md$
+          description: Только файлы Markdown
+      - mcp
+      - command
+    source: project
+  - slug: mode-writer
+    name: ✍️ Создатель режимов
+    roleDefinition: |-
+      Вы — Neira, специалист по созданию и редактированию режимов, занимающийся проектированием, внедрением и улучшением пользовательских режимов для проекта Neira-Code. Ваши знания включают:
+      - Понимание архитектуры и конфигурации системы режимов
+      - Создание хорошо структурированных определений режимов с четкими ролями и обязанностями
+      - Редактирование и улучшение существующих режимов при сохранении согласованности
+      - Написание исчерпывающих специальных инструкций на основе XML с использованием лучших практик
+      - Обеспечение наличия у режимов соответствующих разрешений групп инструментов
+      - Создание четких описаний whenToUse для Оркестратора
+      - Следование лучшим практикам структурирования XML для ясности и возможности синтаксического анализа
+      - Проверка изменений на согласованность и предотвращение противоречий
+
+      Вы помогаете пользователям:
+      - Создавая новые режимы: собирая требования, определяя конфигурации и реализуя инструкции XML
+      - Редактируя существующие режимы: погружаясь в текущую реализацию, анализируя запрошенные изменения и обеспечивая согласованные обновления
+      - Агрессивно используя ask_followup_question для прояснения неясностей и подтверждения понимания
+      - Тщательно проверяя все изменения, чтобы предотвратить противоречия между различными частями режима
+      - Обеспечивая хорошую организацию инструкций с правильными тегами XML
+      - Следуя установленным паттернам из существующих режимов
+      - Поддерживая согласованность во всех компонентах режима
+    whenToUse: Используйте этот режим, когда вам нужно создать новый пользовательский режим или отредактировать существующий. Этот режим обрабатывает как создание режимов с нуля, так и изменение существующих режимов, обеспечивая при этом согласованность и предотвращая противоречия.
+    description: Создание и редактирование пользовательских режимов с проверкой.
+    groups:
+      - read
+      - - edit
+        - fileRegex: (\.neiramodes$|\.neira/.*\.xml$|\.yaml$)
+          description: Файлы конфигурации режимов и инструкции XML
+      - command
+      - mcp
+    source: project
diff --git a/.roo/commands/release.md b/.roo/commands/release.md
deleted file mode 100644
index ec54b804d..000000000
--- a/.roo/commands/release.md
+++ /dev/null
@@ -1,40 +0,0 @@
----
-description: "Create a new release of the Roo Code extension"
-argument-hint: patch | minor | major
----
-
-1. Identify the SHA corresponding to the most recent release using GitHub CLI: `gh release view --json tagName,targetCommitish,publishedAt`
-2. Analyze changes since the last release using: `gh pr list --state merged --json number,title,author,url,mergedAt,closingIssuesReferences --limit 1000 -q '[.[] | select(.mergedAt > "TIMESTAMP") | {number, title, author: .author.login, url, mergedAt, issues: .closingIssuesReferences}] | sort_by(.number)'`
-3. For each PR with linked issues, fetch the issue details to get the issue reporter: `gh issue view ISSUE_NUMBER --json number,author -q '{number, reporter: .author.login}'`
-4. Summarize the changes. If the user did not specify, ask them whether this should be a major, minor, or patch release.
-5. Create a changeset in .changeset/v[version].md instead of directly modifying package.json. The format is:
-
-```
----
-"roo-cline": patch|minor|major
----
-[list of changes]
-```
-
-- Always include contributor attribution using format: (thanks @username!)
-- For PRs that close issues, also include the issue number and reporter: "- Fix: Description (#123 by @reporter, PR by @contributor)"
-- For PRs without linked issues, use the standard format: "- Add support for feature (thanks @contributor!)"
-- Provide brief descriptions of each item to explain the change
-- Order the list from most important to least important
-- Example formats:
-    - With issue: "- Fix: Resolve memory leak in extension (#456 by @issueReporter, PR by @prAuthor)"
-    - Without issue: "- Add support for Gemini 2.5 Pro caching (thanks @contributor!)"
-- CRITICAL: Include EVERY SINGLE PR in the changeset - don't assume you know which ones are important. Count the total PRs to verify completeness and cross-reference the list to ensure nothing is missed.
-
-6. If a major or minor release:
-    - Ask the user what the three most important areas to highlight are in the release
-    - Update the English version relevant announcement files and documentation (webview-ui/src/components/chat/Announcement.tsx, README.md, and the `latestAnnouncementId` in src/core/webview/ClineProvider.ts)
-    - Ask the user to confirm that the English version looks good to them before proceeding
-    - Use the new_task tool to create a subtask in `translate` mode with detailed instructions of which content needs to be translated into all supported languages (The READMEs as well as the translation strings)
-7. Create a new branch for the release preparation: `git checkout -b release/v[version]`
-8. Commit and push the changeset file and any documentation updates to the repository: `git add . && git commit -m "chore: add changeset for v[version]" && git push origin release/v[version]`
-9. Create a pull request for the release: `gh pr create --title "Release v[version]" --body "Release preparation for v[version]. This PR includes the changeset and any necessary documentation updates." --base main --head release/v[version]`
-10. The GitHub Actions workflow will automatically:
-    - Create a version bump PR when changesets are merged to main
-    - Update the CHANGELOG.md with proper formatting
-    - Publish the release when the version bump PR is merged
diff --git a/.roo/roomotes.yml b/.roo/roomotes.yml
deleted file mode 100644
index af0cd85b4..000000000
--- a/.roo/roomotes.yml
+++ /dev/null
@@ -1,33 +0,0 @@
-version: "1.0"
-
-commands:
-    - name: Pull latest changes
-      run: git pull
-      timeout: 60
-      execution_phase: task_run
-    - name: Install dependencies
-      run: pnpm install
-      timeout: 60
-      execution_phase: task_run
-
-github_events:
-    - event: issues.opened
-      action:
-          name: github.issue.fix
-    - event: issue_comment.created
-      action:
-          name: github.issue.comment.respond
-    - event: pull_request.opened
-      action:
-          name: github.pr.review
-    - event: pull_request.opened
-      action:
-          name: general.task
-          prompt: |
-              1. Run the script `node scripts/find-missing-translations.js` and carefully review its output for any missing translations.
-              2. If the script reports missing translations, switch into `translate` mode and add them in all supported languages.
-              3. If you've added new translations, commit and push them to the existing PR.
-              4. If you get a permission error trying to push to the PR just give up (i.e don't create a new PR instead).
-    - event: pull_request_review_comment.created
-      action:
-          name: github.pr.comment.respond
diff --git a/.roo/rules-code/use-safeWriteJson.md b/.roo/rules-code/use-safeWriteJson.md
deleted file mode 100644
index 21e42553d..000000000
--- a/.roo/rules-code/use-safeWriteJson.md
+++ /dev/null
@@ -1,6 +0,0 @@
-# JSON File Writing Must Be Atomic
-
-- You MUST use `safeWriteJson(filePath: string, data: any): Promise<void>` from `src/utils/safeWriteJson.ts` instead of `JSON.stringify` with file-write operations
-- `safeWriteJson` will create parent directories if necessary, so do not call `mkdir` prior to `safeWriteJson`
-- `safeWriteJson` prevents data corruption via atomic writes with locking and streams the write to minimize memory footprint
-- Test files are exempt from this rule
diff --git a/.roo/rules-docs-extractor/1_extraction_workflow.xml b/.roo/rules-docs-extractor/1_extraction_workflow.xml
deleted file mode 100644
index 088fc1ae8..000000000
--- a/.roo/rules-docs-extractor/1_extraction_workflow.xml
+++ /dev/null
@@ -1,361 +0,0 @@
-<extraction_workflow>
-  <mode_overview>
-    The Docs Extractor mode has two primary functions:
-    1. Extract technical and non-technical details about features to provide to documentation teams
-    2. Verify existing documentation for factual accuracy against the codebase
-    
-    This mode does not generate final documentation but provides detailed analysis and verification.
-  </mode_overview>
-
-  <initialization_phase>
-    <step number="1">
-      <title>Parse Request</title>
-      <actions>
-        <action>Identify the feature or component in the user's request.</action>
-        <action>Determine if the request is for extraction or verification.</action>
-        <action>For extraction: Note what level of detail is needed (technical vs non-technical).</action>
-        <action>For verification: Identify the documentation to be verified.</action>
-        <action>Note any specific areas to emphasize or check.</action>
-      </actions>
-      <note>The mode branches into extraction or verification based on the request.</note>
-    </step>
-
-    <step number="2">
-      <title>Discover Feature</title>
-      <actions>
-        <action>Locate relevant code using appropriate search methods.</action>
-        <action>Identify entry points and components.</action>
-        <action>Map the high-level architecture.</action>
-        <action>Use any combination of tools to understand the feature.</action>
-      </actions>
-      <note>Use the most effective discovery method for the situation - file exploration, search, or direct navigation.</note>
-    </step>
-  </initialization_phase>
-
-  <analysis_phases>
-    <phase name="code_analysis">
-      <title>Code Analysis</title>
-      <steps>
-        <step>
-          <action>Analyze code structure</action>
-          <details>
-            - Identify classes, functions, modules
-            - Extract method signatures, parameters
-            - Document return types, data structures
-            - Map inheritance and composition
-          </details>
-        </step>
-        <step>
-          <action>Extract APIs</action>
-          <details>
-            - REST endpoints
-            - GraphQL schemas
-            - WebSocket events
-            - RPC interfaces
-          </details>
-        </step>
-        <step>
-          <action>Document configuration</action>
-          <details>
-            - Environment variables
-            - Config files and schemas
-            - Feature flags
-            - Runtime parameters
-          </details>
-        </step>
-      </steps>
-    </phase>
-
-    <phase name="ui_ux_analysis">
-      <title>UI/UX and User Experience Analysis</title>
-      <steps>
-        <step>
-          <action>Analyze user interface components</action>
-          <details>
-            - UI components and their interactions
-            - Forms, buttons, navigation elements
-            - Visual feedback and loading states
-            - Responsive design considerations
-            - Accessibility features
-          </details>
-        </step>
-        <step>
-          <action>Map user journeys and interactions</action>
-          <details>
-            - Step-by-step user workflows
-            - Click paths and navigation flows
-            - User decision points
-            - Input validation and error messaging
-            - Success and failure scenarios
-          </details>
-        </step>
-        <step>
-          <action>Document user experience elements</action>
-          <details>
-            - Page layouts and information architecture
-            - Interactive elements and their behaviors
-            - Tooltips, help text, and guidance
-            - Confirmation dialogs and warnings
-            - Progress indicators and status updates
-          </details>
-        </step>
-        <step>
-          <action>Capture visual and behavioral patterns</action>
-          <details>
-            - Color schemes and theming
-            - Animation and transitions
-            - Keyboard shortcuts and accessibility
-            - Mobile vs desktop experiences
-            - Browser-specific considerations
-          </details>
-        </step>
-      </steps>
-    </phase>
-
-    <phase name="business_logic_analysis">
-      <title>Business Logic Extraction</title>
-      <steps>
-        <step>
-          <action>Map workflows from user perspective</action>
-          <details>
-            - User journey through the feature
-            - Decision points and branching
-            - State transitions visible to users
-            - Roles and permissions affecting UI
-          </details>
-        </step>
-        <step>
-          <action>Document business rules</action>
-          <details>
-            - Validation logic and user feedback
-            - Formulas and algorithms
-            - Business process implementations
-            - Compliance requirements
-          </details>
-        </step>
-        <step>
-          <action>Identify use cases</action>
-          <details>
-            - Primary use cases
-            - Edge cases
-            - Error scenarios and user recovery
-            - Performance factors affecting UX
-          </details>
-        </step>
-      </steps>
-    </phase>
-
-    <phase name="integration_analysis">
-      <title>Dependency Analysis</title>
-      <steps>
-        <step>
-          <action>Map dependencies</action>
-          <details>
-            - Third-party libraries
-            - External services and APIs
-            - Database connections
-            - Message queues
-          </details>
-        </step>
-        <step>
-          <action>Document integration points</action>
-          <details>
-            - Incoming webhooks
-            - Outgoing API calls
-            - Event publishers/subscribers
-            - Shared data stores
-          </details>
-        </step>
-        <step>
-          <action>Analyze data flow</action>
-          <details>
-            - Data sources and formats
-            - Data transformations
-            - Output formats and destinations
-            - Data retention policies
-          </details>
-        </step>
-      </steps>
-    </phase>
-
-    <phase name="quality_analysis">
-      <title>Test Analysis</title>
-      <steps>
-        <step>
-          <action>Assess test coverage</action>
-          <details>
-            - Unit test coverage
-            - Integration test scenarios
-            - End-to-end test flows
-            - Performance test results
-          </details>
-        </step>
-        <step>
-          <action>Document error handling</action>
-          <details>
-            - Error types and codes
-            - Exception handling
-            - Fallback mechanisms
-            - Recovery procedures
-          </details>
-        </step>
-        <step>
-          <action>Identify quality metrics</action>
-          <details>
-            - Code complexity
-            - Performance benchmarks
-            - Security vulnerabilities
-            - Maintainability scores
-          </details>
-        </step>
-      </steps>
-    </phase>
-
-    <phase name="security_analysis">
-      <title>Security Analysis</title>
-      <steps>
-        <step>
-          <action>Document security</action>
-          <details>
-            - Auth mechanisms
-            - Access control
-            - Data encryption
-            - Security policies
-          </details>
-        </step>
-        <step>
-          <action>Identify vulnerabilities</action>
-          <details>
-            - Known security issues
-            - Attack vectors
-            - Mitigation
-            - Best practices
-          </details>
-        </step>
-        <step>
-          <action>Check compliance</action>
-          <details>
-            - Regulatory compliance (GDPR, etc.)
-            - Industry standards
-            - Audit trail requirements
-            - Data privacy
-          </details>
-        </step>
-      </steps>
-    </phase>
-  </analysis_phases>
-
-  <workflow_paths>
-    <path name="extraction">
-      <title>Extract Feature Details</title>
-      <description>Analyze and extract comprehensive details for documentation team</description>
-      <steps>
-        <step number="1">
-          <title>Compile Technical Details</title>
-          <actions>
-            <action>List all technical components and their relationships</action>
-            <action>Document APIs, data structures, and algorithms</action>
-            <action>Extract configuration options and their impacts</action>
-            <action>Identify error handling and edge cases</action>
-            <action>Note performance characteristics and limitations</action>
-          </actions>
-        </step>
-        <step number="2">
-          <title>Extract Non-Technical Information</title>
-          <actions>
-            <action>Describe complete user experience and workflows</action>
-            <action>Document UI interactions and visual elements</action>
-            <action>Explain business logic in plain language</action>
-            <action>Identify user benefits and use cases</action>
-            <action>Document common scenarios with UI context</action>
-            <action>Note prerequisites and user-facing dependencies</action>
-            <action>Capture error messages and user guidance</action>
-          </actions>
-        </step>
-        <step number="3">
-          <title>Create Extraction Report</title>
-          <actions>
-            <action>Organize findings into clear categories</action>
-            <action>Separate technical and non-technical information</action>
-            <action>Include code snippets and examples where helpful</action>
-            <action>Create `EXTRACTION-[feature].md` with findings</action>
-            <action>Highlight areas that need special attention in documentation</action>
-          </actions>
-          <output_format>
-            - Executive summary of the feature
-            - UI/UX analysis and user experience
-            - Technical details section
-            - Non-technical/user-facing details
-            - User workflows and interactions
-            - Configuration and setup information
-            - Common use cases with UI context
-            - Error handling and user guidance
-            - Potential documentation considerations
-          </output_format>
-        </step>
-      </steps>
-    </path>
-
-    <path name="verification">
-      <title>Verify Documentation Accuracy</title>
-      <description>Check existing documentation against codebase reality</description>
-      <steps>
-        <step number="1">
-          <title>Analyze Provided Documentation</title>
-          <actions>
-            <action>Parse the documentation to identify claims and descriptions</action>
-            <action>Extract technical specifications mentioned</action>
-            <action>Note user-facing features and workflows described</action>
-            <action>Identify configuration options and examples provided</action>
-          </actions>
-        </step>
-        <step number="2">
-          <title>Verify Against Codebase</title>
-          <actions>
-            <action>Check technical claims against actual implementation</action>
-            <action>Verify API endpoints, parameters, and responses</action>
-            <action>Confirm configuration options and defaults</action>
-            <action>Validate code examples and snippets</action>
-            <action>Check if described workflows match implementation</action>
-          </actions>
-        </step>
-        <step number="3">
-          <title>Create Verification Report</title>
-          <actions>
-            <action>Categorize findings by severity (Critical, Major, Minor)</action>
-            <action>List all inaccuracies with correct information</action>
-            <action>Identify missing important information</action>
-            <action>Note outdated or deprecated content</action>
-            <action>Provide specific corrections and suggestions</action>
-            <action>Create `VERIFICATION-[feature].md` with findings</action>
-          </actions>
-          <output_format>
-            - Verification summary (Accurate/Needs Updates)
-            - Critical inaccuracies that could mislead users
-            - Technical corrections needed
-            - Missing information that should be added
-            - Suggestions for clarity improvements
-            - Overall recommendations
-          </output_format>
-        </step>
-      </steps>
-    </path>
-  </workflow_paths>
-
-  <completion_criteria>
-    <for_extraction>
-      <criterion>All code paths analyzed</criterion>
-      <criterion>Technical details comprehensively extracted</criterion>
-      <criterion>Non-technical information clearly explained</criterion>
-      <criterion>Use cases and examples provided</criterion>
-      <criterion>Report organized for documentation team use</criterion>
-    </for_extraction>
-    <for_verification>
-      <criterion>All documentation claims verified</criterion>
-      <criterion>Inaccuracies identified and corrected</criterion>
-      <criterion>Missing information noted</criterion>
-      <criterion>Suggestions for improvement provided</criterion>
-      <criterion>Clear verification report created</criterion>
-    </for_verification>
-  </completion_criteria>
-</extraction_workflow>
\ No newline at end of file
diff --git a/.roo/rules-docs-extractor/2_documentation_patterns.xml b/.roo/rules-docs-extractor/2_documentation_patterns.xml
deleted file mode 100644
index ef1643d8a..000000000
--- a/.roo/rules-docs-extractor/2_documentation_patterns.xml
+++ /dev/null
@@ -1,387 +0,0 @@
-<documentation_patterns>
-  <overview>
-    Standard templates for structuring extracted documentation.
-  </overview>
-
-  <output_structure>
-    <user_focused_template><![CDATA[
-# [Feature Name]
-
-[Description of what the feature does and why a user should care.]
-
-### Key Features
-- [Benefit-oriented feature 1]
-- [Benefit-oriented feature 2]
-- [Benefit-oriented feature 3]
-
----
-
-## Use Case
-
-**Before**: [Description of the old way]
-- [Pain point 1]
-- [Pain point 2]
-
-**With this feature]**: [Description of the new experience.]
-
-## How it Works
-
-[Simple explanation of the feature's operation.]
-
-[Suggest visual representations where helpful.]
-
----
-
-## Configuration
-
-[Explanation of relevant settings.]
-
-1. **[Setting Name]**:
-   - **Setting**: `[technical_name]`
-   - **Description**: [What this does.]
-   - **Default**: [Default value and its meaning.]
-
-2. **[Setting Name]**:
-   - **Setting**: `[technical_name]`
-   - **Description**: [What this does.]
-   - **Default**: [Default value and its meaning.]
-
----
-
-## FAQ
-
-**"[User question]"**
-- [Answer.]
-- [Optional tip.]
-
-**"[User question]"**
-- [Answer.]
-- [Optional tip.]
-
-    ]]></user_focused_template>
-
-    <comprehensive_template><![CDATA[
-# [Feature Name] Technical Documentation
-
-## Table of Contents
-1. Overview
-2. Quick Start
-3. Architecture
-4. API Reference
-5. Configuration
-6. User Guide
-7. Developer Guide
-8. Administrator Guide
-9. Security
-10. Performance
-11. Troubleshooting
-12. FAQ
-13. Changelog
-14. References
-
-[This template remains available for generating detailed technical documentation.]
-    ]]></comprehensive_template>
-  </output_structure>
-
-  <documentation_patterns>
-    <before_after>
-      <template><![CDATA[
-**Before**: Multiple, sequential file read requests:
-- "Read `src/app.js`?" → Approve
-- "Read `src/utils.js`?" → Approve
-- "Read `src/config.json`?" → Approve
-
-**Now**: One request to read all related files.
-      ]]></template>
-    </before_after>
-
-    <visual_separator>
-      <format>---</format>
-      <purpose>Separate sections.</purpose>
-    </visual_separator>
-
-    <faq>
-      <template><![CDATA[
-## FAQ
-
-**"Why disable this?"**
-- Your AI model handles single files better.
-- You need more control over file access.
-- You are working with very large files.
-
-**"What if some files are blocked?"**
-- Roo reads approved files and works with what it has.
-- `.rooignore` files are excluded automatically.
-- Individual files can still be denied in the batch dialog.
-      ]]></template>
-    </faq>
-
-    <examples>
-      <guideline>Show tool output or UI elements.</guideline>
-      <guideline>Use actual file paths and setting names.</guideline>
-      <guideline>Include common errors and solutions.</guideline>
-    </examples>
-
-    <troubleshooting>
-      <template><![CDATA[
-## Troubleshooting
-
-**"Too many files requested"**
-- Lower the concurrent file limit in settings.
-- Deny individual files in the batch dialog.
-
-**"Feature isn't working"**
-- Ensure "Enable concurrent file reads" is on in settings.
-- Verify the file limit is set correctly (default: 100).
-- Some AI models may not support this feature.
-      ]]></template>
-    </troubleshooting>
-
-    <help>
-      <template><![CDATA[
-## Help
-
-- See the [FAQ](#faq) for common issues.
-- Report problems on [GitHub Issues](https://github.com/RooCodeInc/Roo-Code/issues).
-- Include reproduction steps and error messages.
-      ]]></template>
-    </help>
-  </documentation_patterns>
-
-  <audience_sections>
-    <audience type="end_user">
-      <focus>
-        <area>Tutorials</area>
-        <area>Use cases</area>
-        <area>Troubleshooting</area>
-        <area>Benefits</area>
-      </focus>
-      <style>
-        <guideline>Simple language</guideline>
-        <guideline>Visual aids</guideline>
-        <guideline>Focus on outcomes</guideline>
-        <guideline>Clear action steps</guideline>
-      </style>
-    </audience>
-
-    <audience type="developer">
-      <focus>
-        <area>Code examples</area>
-        <area>API specs</area>
-        <area>Integration patterns</area>
-        <area>Performance</area>
-      </focus>
-      <style>
-        <guideline>Precise terminology</guideline>
-        <guideline>Code samples</guideline>
-        <guideline>Document edge cases</guideline>
-        <guideline>Debugging guidance</guideline>
-      </style>
-    </audience>
-
-    <audience type="administrator">
-      <focus>
-        <area>Deployment</area>
-        <area>Monitoring</area>
-        <area>Security hardening</area>
-        <area>Backup and recovery</area>
-      </focus>
-      <style>
-        <guideline>Operational focus</guideline>
-        <guideline>CLI examples</guideline>
-        <guideline>Automation opportunities</guideline>
-        <guideline>Security and compliance</guideline>
-      </style>
-    </audience>
-
-    <audience type="stakeholder">
-      <focus>
-        <area>Business value</area>
-        <area>Capabilities and limits</area>
-        <area>Competitive advantages</area>
-        <area>Risk assessment</area>
-      </focus>
-      <style>
-        <guideline>Business language</guideline>
-        <guideline>Metrics and KPIs</guideline>
-        <guideline>Strategic benefits</guideline>
-        <guideline>Executive summaries</guideline>
-      </style>
-    </audience>
-  </audience_sections>
-
-  <metadata_patterns>
-    <version_info>
-      <template><![CDATA[
-### Version Compatibility
-| Component | Min | Recommended | Max | Notes |
-|-----------|-----|-------------|-----|-------|
-| [Component] | [version] | [version] | [version] | [notes] |
-      ]]></template>
-    </version_info>
-
-    <deprecation_notice>
-      <template><![CDATA[
-> ⚠️ **Deprecated**
->
-> Deprecated since: [vX.Y.Z] on [date]
-> Removal target: [vA.B.C]
-> Migration: See [migration guide](#migration).
-> Replacement: [new feature/method].
-      ]]></template>
-    </deprecation_notice>
-
-    <security_warning>
-      <template><![CDATA[
-> 🔒 **Security Warning**
->
-> [Description of concern]
-> - **Risk**: [High/Medium/Low]
-> - **Affected**: [versions]
-> - **Mitigation**: [steps]
-> - **References**: [links]
-      ]]></template>
-    </security_warning>
-
-    <performance_note>
-      <template><![CDATA[
-> ⚡ **Performance Note**
->
-> [Description of performance consideration]
-> - **Impact**: [metrics]
-> - **Optimization**: [approach]
-> - **Trade-offs**: [considerations]
-      ]]></template>
-    </performance_note>
-  </metadata_patterns>
-
-  <code_documentation_patterns>
-    <api_endpoint>
-      <template><![CDATA[
-### `[METHOD] /api/[path]`
-
-**Description**: [What this endpoint does]
-
-**Authentication**: [Required/Optional] - [Type]
-
-**Parameters**:
-| Name | Type | Required | Description | Example |
-|------|------|----------|-------------|---------|
-| [param] | [type] | [Yes/No] | [description] | [example] |
-
-**Request Body**:
-```json
-{
-  "field": "value"
-}
-```
-
-**Response**:
-- **Success (200)**:
-  ```json
-  {
-    "status": "success",
-    "data": {}
-  }
-  ```
-- **Error (4xx/5xx)**:
-  ```json
-  {
-    "error": "error_code",
-    "message": "Human readable message"
-  }
-  ```
-
-**Example**:
-```bash
-curl -X [METHOD] https://api.example.com/[path] \
-  -H "Authorization: Bearer [token]" \
-  -H "Content-Type: application/json" \
-  -d '{"field": "value"}'
-```
-      ]]></template>
-    </api_endpoint>
-
-    <function_documentation>
-      <template><![CDATA[
-### `functionName(parameters)`
-
-**Purpose**: [What this function does]
-
-**Parameters**:
-- `param1` (Type): [Description]
-- `param2` (Type, optional): [Description] - Default: [value]
-
-**Returns**: `Type` - [Description of return value]
-
-**Throws**:
-- `ErrorType`: [When this error occurs]
-
-**Example**:
-```typescript
-const result = functionName(value1, value2);
-// Expected output: [description]
-```
-
-**Notes**:
-- [Important consideration 1]
-- [Important consideration 2]
-      ]]></template>
-    </function_documentation>
-
-    <configuration_option>
-      <template><![CDATA[
-### `CONFIG_NAME`
-
-**Type**: `string | number | boolean`
-
-**Default**: `default_value`
-
-**Environment Variable**: `APP_CONFIG_NAME`
-
-**Description**: [What this configuration controls]
-
-**Valid Values**:
-- `value1`: [Description]
-- `value2`: [Description]
-
-**Example**:
-```yaml
-config:
-  name: value
-```
-
-**Impact**: [What changes when this is modified]
-      ]]></template>
-    </configuration_option>
-  </code_documentation_patterns>
-
-  <cross_reference_patterns>
-    <internal_link>
-      <format>[Link Text](#section-anchor)</format>
-      <example>[See Configuration Guide](#configuration)</example>
-    </internal_link>
-
-    <external_link>
-      <format>[Link Text](https://external.url)</format>
-      <example>[Official Documentation](https://docs.example.com)</example>
-    </external_link>
-
-    <related_feature>
-      <template><![CDATA[
-> 📌 **Related Features**
-> - [Feature A](../feature-a/README.md): [How it relates]
-> - [Feature B](../feature-b/README.md): [How it relates]
-      ]]></template>
-    </related_feature>
-
-    <see_also>
-      <template><![CDATA[
-> 👉 **See Also**
-> - [Related Topic 1](#anchor1)
-> - [Related Topic 2](#anchor2)
-> - [External Resource](https://example.com)
-      ]]></template>
-    </see_also>
-  </cross_reference_patterns>
-</documentation_patterns>
\ No newline at end of file
diff --git a/.roo/rules-docs-extractor/3_analysis_techniques.xml b/.roo/rules-docs-extractor/3_analysis_techniques.xml
deleted file mode 100644
index b9ef93d1f..000000000
--- a/.roo/rules-docs-extractor/3_analysis_techniques.xml
+++ /dev/null
@@ -1,588 +0,0 @@
-<analysis_techniques>
-  <overview>
-    Techniques for analyzing code to extract documentation.
-  </overview>
-
-  <ui_ux_analysis_techniques>
-    <technique name="component_discovery">
-      <description>
-        Find and analyze UI components and their interactions
-      </description>
-      <discovery_methods>
-        <method name="component_search">
-          <description>Search for UI component files</description>
-          <example><![CDATA[
-<!-- Find React/Vue/Angular components -->
-<search_files>
-<path>src</path>
-<regex>\.(tsx|jsx|vue)$|@Component|export.*component</regex>
-<file_pattern>*.tsx</file_pattern>
-</search_files>
-
-<!-- Find component usage -->
-<search_files>
-<path>src</path>
-<regex><Button|<Form|<Modal|<Dialog|<Input</regex>
-</search_files>
-          ]]></example>
-        </method>
-        
-        <method name="style_analysis">
-          <description>Analyze styling and visual elements</description>
-          <example><![CDATA[
-<!-- Find stylesheets -->
-<list_files>
-<path>src/styles</path>
-<recursive>true</recursive>
-</list_files>
-
-<!-- Search for style definitions -->
-<search_files>
-<path>src</path>
-<regex>className=|style=|styled\.|makeStyles|@apply</regex>
-</search_files>
-          ]]></example>
-        </method>
-      </discovery_methods>
-    </technique>
-
-    <technique name="user_flow_mapping">
-      <description>
-        Map user interactions and navigation flows
-      </description>
-      <analysis_areas>
-        <area>Route definitions and navigation</area>
-        <area>Form submissions and validations</area>
-        <area>Button clicks and event handlers</area>
-        <area>State changes and UI updates</area>
-        <area>Loading and error states</area>
-      </analysis_areas>
-      <search_patterns><![CDATA[
-<!-- Find route definitions -->
-<search_files>
-<path>src</path>
-<regex>Route.*path=|router\.push|navigate\(|Link.*to=</regex>
-</search_files>
-
-<!-- Find event handlers -->
-<search_files>
-<path>src</path>
-<regex>onClick=|onSubmit=|onChange=|handleClick|handleSubmit</regex>
-</search_files>
-
-<!-- Find form validations -->
-<search_files>
-<path>src</path>
-<regex>validate|validation|required|pattern=|minLength|maxLength</regex>
-</search_files>
-      ]]></search_patterns>
-    </technique>
-
-    <technique name="user_feedback_analysis">
-      <description>
-        Analyze how the system communicates with users
-      </description>
-      <elements_to_find>
-        <element>Error messages and alerts</element>
-        <element>Success notifications</element>
-        <element>Loading indicators</element>
-        <element>Tooltips and help text</element>
-        <element>Confirmation dialogs</element>
-        <element>Progress indicators</element>
-      </elements_to_find>
-      <search_patterns><![CDATA[
-<!-- Find user messages -->
-<search_files>
-<path>src</path>
-<regex>toast|notification|alert|message|error.*message|success.*message</regex>
-</search_files>
-
-<!-- Find loading states -->
-<search_files>
-<path>src</path>
-<regex>loading|isLoading|pending|spinner|skeleton|placeholder</regex>
-</search_files>
-
-<!-- Find dialogs and modals -->
-<search_files>
-<path>src</path>
-<regex>modal|dialog|confirm|popup|overlay</regex>
-</search_files>
-      ]]></search_patterns>
-    </technique>
-
-    <technique name="accessibility_analysis">
-      <description>
-        Check for accessibility features and compliance
-      </description>
-      <accessibility_checks>
-        <check>ARIA labels and roles</check>
-        <check>Keyboard navigation support</check>
-        <check>Screen reader compatibility</check>
-        <check>Focus management</check>
-        <check>Color contrast considerations</check>
-      </accessibility_checks>
-      <search_patterns><![CDATA[
-<!-- Find accessibility attributes -->
-<search_files>
-<path>src</path>
-<regex>aria-|role=|tabIndex|alt=|title=|accessibilityLabel</regex>
-</search_files>
-
-<!-- Find focus management -->
-<search_files>
-<path>src</path>
-<regex>focus\(|blur\(|onFocus|onBlur|autoFocus|focusable</regex>
-</search_files>
-      ]]></search_patterns>
-    </technique>
-
-    <technique name="responsive_design_analysis">
-      <description>
-        Analyze responsive design and mobile experience
-      </description>
-      <analysis_points>
-        <point>Breakpoint definitions</point>
-        <point>Mobile-specific components</point>
-        <point>Touch event handlers</point>
-        <point>Viewport configurations</point>
-        <point>Media queries</point>
-      </analysis_points>
-      <search_patterns><![CDATA[
-<!-- Find responsive utilities -->
-<search_files>
-<path>src</path>
-<regex>@media|breakpoint|mobile|tablet|desktop|responsive</regex>
-</search_files>
-
-<!-- Find touch events -->
-<search_files>
-<path>src</path>
-<regex>onTouch|swipe|gesture|tap|press</regex>
-</search_files>
-      ]]></search_patterns>
-    </technique>
-  </ui_ux_analysis_techniques>
-
-  <code_analysis_techniques>
-    <technique name="semantic_search_analysis">
-      <description>
-        Use semantic search to find conceptually related code when available.
-      </description>
-      <when_to_use>
-        <scenario>Finding code by concept rather than keywords</scenario>
-        <scenario>Discovering implementations across different naming conventions</scenario>
-        <scenario>When pattern-based search isn't finding expected results</scenario>
-      </when_to_use>
-      <example><![CDATA[
-<!-- Optional: Find authentication-related code semantically -->
-<codebase_search>
-<query>user authentication login security JWT token validation</query>
-</codebase_search>
-
-<!-- Optional: Find payment processing logic -->
-<codebase_search>
-<query>payment processing transaction billing invoice checkout</query>
-</codebase_search>
-      ]]></example>
-      <note>This is an optional tool - use when semantic understanding would help find related code that keyword search might miss</note>
-    </technique>
-
-    <technique name="entry_point_analysis">
-      <description>
-        Analyze entry points to understand feature flow.
-      </description>
-      <steps>
-        <step>Find main functions, controllers, or route handlers.</step>
-        <step>Trace execution flow.</step>
-        <step>Map decision branches.</step>
-        <step>Document input validation.</step>
-      </steps>
-      <discovery_methods>
-        <method name="directory_based">
-          <description>Start by exploring directory structure</description>
-          <example><![CDATA[
-<!-- List main directories -->
-<list_files>
-<path>src</path>
-<recursive>false</recursive>
-</list_files>
-
-<!-- Explore feature directory -->
-<list_files>
-<path>src/controllers</path>
-<recursive>true</recursive>
-</list_files>
-          ]]></example>
-        </method>
-        
-        <method name="pattern_based">
-          <description>Search for specific patterns</description>
-          <example><![CDATA[
-<!-- Find all routes -->
-<search_files>
-<path>src</path>
-<regex>(app\.(get|post|put|delete)|@(Get|Post|Put|Delete)|router\.(get|post|put|delete))</regex>
-</search_files>
-          ]]></example>
-        </method>
-        
-        <method name="file_based">
-          <description>Read known entry points directly</description>
-          <example><![CDATA[
-<!-- Read main application file -->
-<read_file>
-<path>src/app.ts</path>
-</read_file>
-
-<!-- Read specific controller -->
-<read_file>
-<path>src/controllers/feature.controller.ts</path>
-</read_file>
-          ]]></example>
-        </method>
-        
-        <method name="semantic_based">
-          <description>Use semantic search as an alternative discovery method</description>
-          <example><![CDATA[
-<!-- Optional: Find entry points semantically -->
-<codebase_search>
-<query>main entry point application startup initialization bootstrap</query>
-</codebase_search>
-          ]]></example>
-        </method>
-      </discovery_methods>
-    </technique>
-
-    <technique name="api_extraction">
-      <description>
-        Extract API specifications from code.
-      </description>
-      <patterns>
-        <pattern type="rest">
-          <search_regex><![CDATA[
-(app|router)\.(get|post|put|patch|delete)\s*\(\s*['"`]([^'"`]+)['"`]
-          ]]></search_regex>
-          <extraction>
-            - HTTP method
-            - Route path
-            - Path/query parameters
-            - Request/response schemas
-            - Status codes
-          </extraction>
-        </pattern>
-        <pattern type="graphql">
-          <search_regex><![CDATA[
-type\s+(Query|Mutation|Subscription)\s*{[^}]+}|@(Query|Mutation|Resolver)
-          ]]></search_regex>
-          <extraction>
-            - Schema and input types
-            - Resolvers
-            - Return types
-            - Field arguments
-          </extraction>
-        </pattern>
-      </patterns>
-    </technique>
-
-    <technique name="dependency_mapping">
-      <description>
-        Map dependencies and integration points.
-      </description>
-      <analysis_points>
-        <point>Import/require statements</point>
-        <point>package.json dependencies</point>
-        <point>External API calls</point>
-        <point>DB connections</point>
-        <point>Message queue integrations</point>
-        <point>Filesystem operations</point>
-      </analysis_points>
-      <analysis_approaches>
-        <approach name="package_analysis">
-          <description>Start with package.json to understand dependencies</description>
-          <example><![CDATA[
-<!-- Analyze package dependencies -->
-<read_file>
-<path>package.json</path>
-</read_file>
-          ]]></example>
-        </approach>
-        
-        <approach name="import_tracking">
-          <description>Follow import chains to map dependencies</description>
-          <example><![CDATA[
-<!-- Find all imports -->
-<search_files>
-<path>src</path>
-<regex>^import\s+.*from\s+['"]([^'"]+)['"]|require\s*\(\s*['"]([^'"]+)['"]\s*\)</regex>
-</search_files>
-          ]]></example>
-        </approach>
-        
-        <approach name="api_discovery">
-          <description>Find external API integrations</description>
-          <example><![CDATA[
-<!-- Find external API calls -->
-<search_files>
-<path>src</path>
-<regex>(fetch|axios|http\.request|request\(|\.get\(|\.post\()</regex>
-</search_files>
-          ]]></example>
-        </approach>
-      </analysis_approaches>
-    </technique>
-
-    <technique name="data_model_extraction">
-      <description>
-        Extract data models, schemas, and type definitions.
-      </description>
-      <sources>
-        <source type="typescript">
-          <patterns>
-            - interfaces, types, classes, enums
-          </patterns>
-        </source>
-        <source type="database">
-          <patterns>
-            - Schema definitions, migration files, ORM models
-          </patterns>
-        </source>
-        <source type="validation">
-          <patterns>
-            - JSON Schema, Joi/Yup/Zod schemas, validation decorators
-          </patterns>
-        </source>
-      </sources>
-      <extraction_example><![CDATA[
-<!-- Find TypeScript interfaces -->
-<search_files>
-<path>src</path>
-<regex>^export\s+(interface|type|class|enum)\s+(\w+)</regex>
-</search_files>
-
-<!-- Find database models -->
-<search_files>
-<path>src/models</path>
-<regex>@(Entity|Table|Model)|class\s+\w+\s+extends\s+(Model|BaseEntity)</regex>
-</search_files>
-      ]]></extraction_example>
-    </technique>
-
-    <technique name="business_logic_extraction">
-      <description>
-        Identify and document business rules.
-      </description>
-      <indicators>
-        <indicator>Complex conditionals</indicator>
-        <indicator>Calculation functions</indicator>
-        <indicator>Validation rules</indicator>
-        <indicator>State machines</indicator>
-        <indicator>Domain-specific constants and algorithms</indicator>
-      </indicators>
-      <documentation_focus>
-        <focus>Why logic exists (business need)</focus>
-        <focus>When logic applies (conditions)</focus>
-        <focus>What logic does (transformation)</focus>
-        <focus>Edge cases</focus>
-        <focus>Impact of changes</focus>
-      </documentation_focus>
-    </technique>
-
-    <technique name="error_handling_analysis">
-      <description>
-        Document error handling and recovery.
-      </description>
-      <analysis_areas>
-        <area>try/catch blocks, error boundaries</area>
-        <area>Custom error classes</area>
-        <area>Error codes and messages</area>
-        <area>Logging, fallbacks, retries, circuit breakers</area>
-      </analysis_areas>
-      <search_patterns><![CDATA[
-<!-- Find error handling -->
-<search_files>
-<path>src</path>
-<regex>try\s*{|catch\s*\(|throw\s+new|class\s+\w*Error\s+extends</regex>
-</search_files>
-
-<!-- Find error constants -->
-<search_files>
-<path>src</path>
-<regex>ERROR_|_ERROR|ErrorCode|errorCode</regex>
-</search_files>
-      ]]></search_patterns>
-    </technique>
-
-    <technique name="security_analysis">
-      <description>
-        Identify security measures and vulnerabilities.
-      </description>
-      <security_checks>
-        <check category="authentication">
-          <patterns>
-            - JWT, sessions, OAuth, API keys
-          </patterns>
-        </check>
-        <check category="authorization">
-          <patterns>
-            - RBAC, permission checks, ownership validation
-          </patterns>
-        </check>
-        <check category="data_protection">
-          <patterns>
-            - Encryption, hashing, sensitive data handling
-          </patterns>
-        </check>
-        <check category="input_validation">
-          <patterns>
-            - Sanitization, SQLi/XSS/CSRF prevention
-          </parents>
-        </check>
-      </security_checks>
-    </technique>
-
-    <technique name="performance_analysis">
-      <description>
-        Identify performance factors and optimization opportunities.
-      </description>
-      <analysis_points>
-        <point>DB query patterns (N+1)</point>
-        <point>Caching strategies</point>
-        <point>Async usage</point>
-        <point>Batch processing</point>
-        <point>Resource pooling</point>
-        <point>Memory management</point>
-        <point>Algorithm complexity</point>
-      </analysis_points>
-      <metrics_to_document>
-        <metric>Time/space complexity</metric>
-        <metric>DB query counts</metric>
-        <metric>API response times</metric>
-        <metric>Memory usage</metric>
-        <metric>Concurrency handling</metric>
-      </metrics_to_document>
-    </technique>
-
-    <technique name="test_coverage_analysis">
-      <description>
-        Analyze test coverage.
-      </description>
-      <test_types>
-        <type name="unit">
-          <location>__tests__, *.test.ts, *.spec.ts</location>
-          <analysis>Function coverage</analysis>
-        </type>
-        <type name="integration">
-          <location>integration/, e2e/</location>
-          <analysis>Workflow coverage</analysis>
-        </type>
-        <type name="api">
-          <location>api-tests/, *.api.test.ts</location>
-          <analysis>Endpoint coverage</analysis>
-        </type>
-      </test_types>
-      <coverage_analysis><![CDATA[
-<!-- Find test files -->
-<search_files>
-<path>src</path>
-<regex>\.(test|spec)\.(ts|js|tsx|jsx)$</regex>
-<file_pattern>*.test.ts</file_pattern>
-</search_files>
-
-<!-- Analyze test descriptions -->
-<search_files>
-<path>src</path>
-<regex>(describe|it|test)\s*\(\s*['"`]([^'"`]+)['"`]</regex>
-</search_files>
-      ]]></coverage_analysis>
-    </technique>
-
-    <technique name="configuration_extraction">
-      <description>
-        Extract configuration options and their impacts.
-      </description>
-      <configuration_sources>
-        <source>.env files, config files, CLI args, feature flags</source>
-      </configuration_sources>
-      <documentation_requirements>
-        <requirement>Default values</requirement>
-        <requirement>Valid values</requirement>
-        <requirement>Behavior impact</requirement>
-        <requirement>Config dependencies</requirement>
-        <requirement>Security implications</requirement>
-      </documentation_requirements>
-    </technique>
-  </code_analysis_techniques>
-
-  <workflow_analysis>
-    <technique name="user_journey_mapping">
-      <description>
-        Map user workflows through the feature.
-      </description>
-      <steps>
-        <step>Identify entry points (UI, API, CLI).</step>
-        <step>Trace user actions.</step>
-        <step>Document decision points.</step>
-        <step>Map data transformations.</step>
-        <step>Identify outcomes.</step>
-      </steps>
-      <deliverables>
-        <deliverable>Flow diagrams, procedures, decision trees, state diagrams.</deliverable>
-      </deliverables>
-    </technique>
-
-    <technique name="integration_flow_analysis">
-      <description>
-        Document integration with other systems.
-      </description>
-      <integration_types>
-        <type>Sync API calls, async messaging, events, batch processing, streaming.</type>
-      </integration_types>
-      <documentation_focus>
-        <focus>Protocols, auth, error handling, data transforms, SLAs.</focus>
-      </documentation_focus>
-    </technique>
-  </workflow_analysis>
-
-  <metadata_extraction>
-    <technique name="version_compatibility">
-      <sources>
-        <source>package.json, READMEs, migration guides, breaking changes docs.</source>
-      </sources>
-      <extraction_pattern><![CDATA[
-<!-- Find version requirements -->
-<search_files>
-<path>.</path>
-<regex>"engines":|"peerDependencies":|requires?\s+\w+\s+version|compatible\s+with</regex>
-</search_files>
-      ]]></extraction_pattern>
-    </technique>
-
-    <technique name="deprecation_tracking">
-      <indicators>
-        <indicator>@deprecated, TODO comments, legacy code markers.</indicator>
-      </indicators>
-      <documentation_requirements>
-        <requirement>Deprecation date, removal timeline, migration path, alternatives.</requirement>
-      </documentation_requirements>
-    </technique>
-  </metadata_extraction>
-
-  <quality_indicators>
-    <indicator name="documentation_completeness">
-      <checks>
-        <check>Public APIs documented.</check>
-        <check>Examples for complex features.</check>
-        <check>Error scenarios covered.</check>
-        <check>Config options explained.</check>
-        <check>Security addressed.</check>
-      </checks>
-    </indicator>
-
-    <indicator name="code_quality_metrics">
-      <metrics>
-        <metric>Cyclomatic complexity, code duplication, test coverage, doc coverage, tech debt.</metric>
-      </metrics>
-    </indicator>
-  </quality_indicators>
-</analysis_techniques>
\ No newline at end of file
diff --git a/.roo/rules-docs-extractor/4_tool_usage_guide.xml b/.roo/rules-docs-extractor/4_tool_usage_guide.xml
deleted file mode 100644
index 504991727..000000000
--- a/.roo/rules-docs-extractor/4_tool_usage_guide.xml
+++ /dev/null
@@ -1,397 +0,0 @@
-<tool_usage_guide>
-  <overview>
-    Guidance on using tools for documentation extraction.
-  </overview>
-
-  <discovery_approaches>
-    <approach name="flexible_discovery">
-      <description>Use the most appropriate tools for the situation</description>
-      <principles>
-        <principle>Start with what you know - file names, directory structure, or keywords</principle>
-        <principle>Use multiple discovery methods to build understanding</principle>
-        <principle>Adapt your approach based on the codebase structure</principle>
-      </principles>
-    </approach>
-
-    <common_tools>
-      <tool name="list_files">
-        <purpose>Explore directory structure and find relevant files</purpose>
-        <when_to_use>
-          - Starting exploration of a feature area
-          - Understanding project organization
-          - Finding configuration or test files
-        </when_to_use>
-      </tool>
-
-      <tool name="read_file">
-        <purpose>Examine specific files in detail</purpose>
-        <when_to_use>
-          - Analyzing implementation details
-          - Understanding configuration
-          - Reading documentation or comments
-        </when_to_use>
-        <tip>Read multiple related files together for better context</tip>
-      </tool>
-
-      <tool name="search_files">
-        <purpose>Find specific patterns or text</purpose>
-        <when_to_use>
-          - Locating API endpoints
-          - Finding configuration usage
-          - Tracking down error handling
-          - Discovering cross-references
-        </when_to_use>
-      </tool>
-
-      <tool name="list_code_definition_names">
-        <purpose>Get overview of code structure</purpose>
-        <when_to_use>
-          - Understanding module organization
-          - Identifying main components
-          - Finding test coverage
-        </when_to_use>
-      </tool>
-
-      <tool name="codebase_search">
-        <purpose>Semantic search when available</purpose>
-        <when_to_use>
-          - Finding conceptually related code
-          - Discovering implementations by functionality
-          - When keyword search isn't sufficient
-        </when_to_use>
-        <note>Optional - use when semantic understanding is needed</note>
-      </tool>
-    </common_tools>
-
-    <discovery_patterns>
-      <pattern name="top_down">
-        <description>Start from high-level structure and drill down</description>
-        <steps>
-          <step>List files in feature directory</step>
-          <step>Identify main entry points</step>
-          <step>Follow imports and dependencies</step>
-          <step>Examine implementation details</step>
-        </steps>
-      </pattern>
-
-      <pattern name="test_driven">
-        <description>Use tests to understand expected behavior</description>
-        <steps>
-          <step>Find test files for the feature</step>
-          <step>Read test descriptions and scenarios</step>
-          <step>Trace back to implementation</step>
-          <step>Verify behavior matches tests</step>
-        </steps>
-      </pattern>
-
-      <pattern name="configuration_first">
-        <description>Start with configuration to understand setup</description>
-        <steps>
-          <step>Find configuration files</step>
-          <step>Identify feature flags and settings</step>
-          <step>Trace usage in code</step>
-          <step>Document impacts of each setting</step>
-        </steps>
-      </pattern>
-
-      <pattern name="api_focused">
-        <description>Map external interfaces first</description>
-        <steps>
-          <step>Search for route definitions</step>
-          <step>Find API controllers or handlers</step>
-          <step>Trace to business logic</step>
-          <step>Document request/response flow</step>
-        </steps>
-      </pattern>
-    </discovery_patterns>
-  </discovery_approaches>
-
-  <documentation_generation_tools>
-    <tool name="write_to_file">
-      <purpose>Create extraction or verification report files.</purpose>
-      <note>Generates reports for documentation teams, not final documentation.</note>
-      <file_naming>
-        - For extraction: EXTRACTION-[feature-name].md
-        - For verification: VERIFICATION-[feature-name].md
-      </file_naming>
-      <best_practices>
-        <practice>Use descriptive feature name in filename.</practice>
-        <practice>Include table of contents.</practice>
-        <practice>Use consistent Markdown formatting.</practice>
-        <practice>Include syntax-highlighted code examples.</practice>
-      </best_practices>
-      <example><![CDATA[
-<write_to_file>
-<path>EXTRACTION-authentication-system.md</path>
-<content>
-# Authentication System Documentation
-
-## Table of Contents
-1. [Overview](#overview)
-2. [Architecture](#architecture)
-...
-
-## Overview
-The authentication system provides secure user authentication using JWT tokens...
-</content>
-<line_count>...</line_count>
-</write_to_file>
-      ]]></example>
-    </tool>
-    
-    <tool name="ask_followup_question">
-      <purpose>Clarify ambiguous requirements.</purpose>
-      <when_to_use>
-        <scenario>Multiple features have similar names.</scenario>
-        <scenario>Documentation depth is unclear.</scenario>
-        <scenario>Audience priorities are undefined.</scenario>
-      </when_to_use>
-      <examples>
-        <example><![CDATA[
-<ask_followup_question>
-<question>Which authentication aspects should be the focus?</question>
-<follow_up>
-<suggest>The complete flow (JWT, sessions, OAuth).</suggest>
-<suggest>Only JWT implementation and validation.</suggest>
-<suggest>Only OAuth2 integration.</suggest>
-<suggest>Password reset and recovery workflows.</suggest>
-</follow_up>
-</ask_followup_question>
-        ]]></example>
-        <example><![CDATA[
-<ask_followup_question>
-<question>What level of technical detail is needed?</question>
-<follow_up>
-<suggest>High-level overview for all audiences.</suggest>
-<suggest>Detailed developer implementation.</suggest>
-<suggest>API reference with code examples.</suggest>
-<suggest>Full coverage for all audiences.</suggest>
-</follow_up>
-</ask_followup_question>
-        ]]></example>
-      </examples>
-    </tool>
-  </documentation_generation_tools>
-
-  <analysis_strategies>
-    <strategy name="file_discovery">
-      <description>
-        Find all files related to a feature using various methods.
-      </description>
-      <methods>
-        <method name="directory_exploration">
-          <description>Start by exploring likely directories</description>
-          <tool_use><![CDATA[
-<list_files>
-<path>src</path>
-<recursive>false</recursive>
-</list_files>
-
-<!-- Then drill into feature directory -->
-<list_files>
-<path>src/features/[feature-name]</path>
-<recursive>true</recursive>
-</list_files>
-          ]]></tool_use>
-        </method>
-
-        <method name="pattern_search">
-          <description>Search for feature-related patterns</description>
-          <tool_use><![CDATA[
-<!-- Find files with feature name -->
-<search_files>
-<path>src</path>
-<regex>feature-name|FeatureName</regex>
-</search_files>
-
-<!-- Find related tests -->
-<search_files>
-<path>src</path>
-<regex>describe\(['"].*Feature.*['"]|test\(['"].*feature.*['"]</regex>
-<file_pattern>*.test.ts</file_pattern>
-</search_files>
-          ]]></tool_use>
-        </method>
-
-        <method name="configuration_discovery">
-          <description>Find configuration files</description>
-          <tool_use><![CDATA[
-<!-- Look for config files -->
-<list_files>
-<path>config</path>
-<recursive>true</recursive>
-</list_files>
-
-<!-- Search for feature config -->
-<search_files>
-<path>.</path>
-<regex>feature.*config|settings.*feature</regex>
-<file_pattern>*.json</file_pattern>
-</search_files>
-          ]]></tool_use>
-        </method>
-
-        <method name="semantic_search_optional">
-          <description>Use semantic search if available and helpful</description>
-          <tool_use><![CDATA[
-<!-- Optional: Use when concept-based search is needed -->
-<codebase_search>
-<query>feature implementation main logic</query>
-</codebase_search>
-          ]]></tool_use>
-          <note>This is optional - use when other methods aren't sufficient</note>
-        </method>
-      </methods>
-    </strategy>
-
-    <strategy name="dependency_chain_analysis">
-      <description>
-        Follow import chains to map dependencies.
-      </description>
-      <process>
-        <step>Read main file.</step>
-        <step>Extract all imports.</step>
-        <step>Read each imported file.</step>
-        <step>Recursively analyze imports.</step>
-        <step>Build dependency graph.</step>
-      </process>
-      <import_patterns><![CDATA[
-<!-- TypeScript/JavaScript imports -->
-<search_files>
-<path>src/feature</path>
-<regex>import\s+(?:{[^}]+}|\*\s+as\s+\w+|\w+)\s+from\s+['"]([^'"]+)['"]</regex>
-</search_files>
-
-<!-- CommonJS requires -->
-<search_files>
-<path>src/feature</path>
-<regex>require\(['"]([^'"]+)['"]\)</regex>
-</search_files>
-      ]]></import_patterns>
-    </strategy>
-
-    <strategy name="api_documentation_extraction">
-      <description>
-        Extract API documentation from code.
-      </description>
-      <extraction_points>
-        <point>Route definitions, request/response schemas, auth requirements, rate limiting, error responses.</point>
-      </extraction_points>
-      <tools_sequence>
-        <sequence>
-          <step>Find route files.</step>
-          <step>Extract route definitions.</step>
-          <step>Find controllers.</step>
-          <step>Analyze request validation.</step>
-          <step>Document response formats.</step>
-        </sequence>
-      </tools_sequence>
-    </strategy>
-
-    <strategy name="test_driven_documentation">
-      <description>
-        Use tests to document expected behavior.
-      </description>
-      <benefits>
-        <benefit>Tests provide usage examples.</benefit>
-        <benefit>Test descriptions explain functionality.</benefit>
-        <benefit>Tests cover edge cases.</benefit>
-        <benefit>Tests document expected outputs.</benefit>
-      </benefits>
-      <extraction_approach><![CDATA[
-<!-- Find test descriptions -->
-<search_files>
-<path>__tests__</path>
-<regex>(describe|it|test)\(['"]([^'"]+)['"]</regex>
-</search_files>
-
-<!-- Extract test scenarios -->
-<read_file>
-<path>__tests__/feature.test.ts</path>
-</read_file>
-      ]]></extraction_approach>
-    </strategy>
-  </analysis_strategies>
-
-  <common_patterns>
-    <pattern name="configuration_documentation">
-      <search_locations>
-        <location>.env.example</location>
-        <location>config/*.json</location>
-        <location>src/config/*</location>
-        <location>README.md (configuration section)</location>
-      </search_locations>
-      <extraction_regex><![CDATA[
-# Environment variables
-process\.env\.(\w+)
-
-# Config object access
-config\.(\w+)\.(\w+)
-
-# Default values
-\w+\s*=\s*process\.env\.\w+\s*\|\|\s*['"]([^'"]+)['"]
-      ]]></extraction_regex>
-    </pattern>
-
-    <pattern name="error_documentation">
-      <error_patterns>
-        <pattern>Custom error classes</pattern>
-        <pattern>Error code constants</pattern>
-        <pattern>Error message templates</pattern>
-        <pattern>HTTP status codes</pattern>
-      </error_patterns>
-      <search_approach><![CDATA[
-<search_files>
-<path>src</path>
-<regex>class\s+\w*Error\s+extends|new Error\(|throw new|ERROR_CODE|HTTP_STATUS</regex>
-</search_files>
-      ]]></search_approach>
-    </pattern>
-
-    <pattern name="security_documentation">
-      <security_aspects>
-        <aspect>Authentication methods</aspect>
-        <aspect>Authorization rules</aspect>
-        <aspect>Data encryption</aspect>
-        <aspect>Input validation</aspect>
-        <aspect>Rate limiting</aspect>
-      </security_aspects>
-      <indicators><![CDATA[
-<search_files>
-<path>src</path>
-<regex>@Authorized|requireAuth|checkPermission|encrypt|decrypt|sanitize|validate|rateLimit</regex>
-</search_files>
-      ]]></indicators>
-    </pattern>
-  </common_patterns>
-
-  <output_optimization>
-    <guideline name="structure">
-      <description>Organize output for navigation.</description>
-      <structure>
-        - Clear hierarchy, consistent headings, ToC with links, cross-references.
-      </structure>
-    </guideline>
-
-    <guideline name="code_examples">
-      <description>Include relevant code examples.</description>
-      <best_practices>
-        - Use syntax highlighting, show request/response, include error cases.
-      </best_practices>
-    </guideline>
-
-    <guideline name="visuals">
-      <description>Suggest diagrams where helpful.</description>
-      <diagram_types>
-        - Architecture, sequence, data flow, state machine diagrams.
-      </diagram_types>
-    </guideline>
-
-    <guideline name="metadata">
-      <description>Include important metadata.</description>
-      <required_metadata>
-        - Version compatibility, last updated, status, performance, security.
-      </required_metadata>
-    </guideline>
-  </output_optimization>
-</tool_usage_guide>
\ No newline at end of file
diff --git a/.roo/rules-docs-extractor/5_complete_extraction_examples.xml b/.roo/rules-docs-extractor/5_complete_extraction_examples.xml
deleted file mode 100644
index 8c644e2f0..000000000
--- a/.roo/rules-docs-extractor/5_complete_extraction_examples.xml
+++ /dev/null
@@ -1,881 +0,0 @@
-<complete_extraction_examples>
-  <overview>
-    Examples of both documentation extraction and verification workflows demonstrating flexible discovery methods and comprehensive UI/UX analysis.
-  </overview>
-
-  <example name="authentication_system_extraction">
-    <scenario>
-      Extract comprehensive documentation for a JWT-based authentication system, including technical implementation, UI/UX elements, and user workflows.
-    </scenario>
-
-    <workflow>
-      <step number="1">
-        <description>Initialize and discover feature using flexible methods</description>
-        <tool_use><![CDATA[
-<!-- Method 1: Directory exploration -->
-<list_files>
-<path>src</path>
-<recursive>false</recursive>
-</list_files>
-        ]]></tool_use>
-        <analysis>Look for auth-related directories like auth/, authentication/, or security/</analysis>
-        <tool_use><![CDATA[
-<list_files>
-<path>src/auth</path>
-<recursive>true</recursive>
-</list_files>
-        ]]></tool_use>
-        <expected_findings>
-          - Auth controllers, services, middleware, models, and routes
-          - Login components and forms
-          - Session management UI
-        </expected_findings>
-      </step>
-
-      <step number="2">
-        <description>Analyze code structure and architecture</description>
-        <tool_use><![CDATA[
-<list_code_definition_names>
-<path>src/auth</path>
-</list_code_definition_names>
-        ]]></tool_use>
-        <analysis>
-          - Identify main classes/functions
-          - Map authentication flow
-          - Find token generation/validation logic
-          - Locate UI components
-        </analysis>
-      </step>
-
-      <step number="3">
-        <description>Read core implementation files</description>
-        <tool_use><![CDATA[
-<read_file>
-<args>
-  <file>
-    <path>src/auth/auth.controller.ts</path>
-  </file>
-  <file>
-    <path>src/auth/auth.service.ts</path>
-  </file>
-  <file>
-    <path>src/auth/jwt.strategy.ts</path>
-  </file>
-  <file>
-    <path>src/auth/auth.guard.ts</path>
-  </file>
-  <file>
-    <path>src/models/user.model.ts</path>
-  </file>
-</args>
-</read_file>
-        ]]></tool_use>
-      </step>
-
-      <step number="4">
-        <description>UI/UX Analysis - Discover UI components</description>
-        <tool_use><![CDATA[
-<!-- Method 2: Pattern search for UI components -->
-<search_files>
-<path>src/components</path>
-<regex>(Login|Auth|Session|Password).*\.(tsx?|jsx?)</regex>
-<file_pattern>*.tsx</file_pattern>
-</search_files>
-        ]]></tool_use>
-        <tool_use><![CDATA[
-<read_file>
-<args>
-  <file>
-    <path>src/components/LoginForm.tsx</path>
-  </file>
-  <file>
-    <path>src/components/SessionManager.tsx</path>
-  </file>
-  <file>
-    <path>src/components/PasswordReset.tsx</path>
-  </file>
-</args>
-</read_file>
-        ]]></tool_use>
-      </step>
-
-      <step number="5">
-        <description>UI/UX Analysis - Map user interactions</description>
-        <tool_use><![CDATA[
-<search_files>
-<path>src/components</path>
-<regex>onClick|onSubmit|onChange|handleSubmit|validate</regex>
-</search_files>
-        ]]></tool_use>
-        <analysis>
-          - Form validation patterns
-          - User feedback mechanisms
-          - Error handling UI
-          - Loading states
-        </analysis>
-      </step>
-
-      <step number="6">
-        <description>UI/UX Analysis - Visual patterns and accessibility</description>
-        <tool_use><![CDATA[
-<search_files>
-<path>src</path>
-<regex>className=|style=|theme\.|aria-|role=</regex>
-<file_pattern>*.tsx</file_pattern>
-</search_files>
-        ]]></tool_use>
-        <tool_use><![CDATA[
-<search_files>
-<path>src/styles</path>
-<regex>\.login|\.auth|\.session</regex>
-<file_pattern>*.css</file_pattern>
-</search_files>
-        ]]></tool_use>
-      </step>
-
-      <step number="7">
-        <description>Extract API endpoints and configuration</description>
-        <tool_use><![CDATA[
-<search_files>
-<path>src/auth</path>
-<regex>@(Post|Get)\(['"]\/auth\/[^'"]+['"]|router\.(post|get)\(['"]\/auth\/[^'"]+['"]</regex>
-</search_files>
-        ]]></tool_use>
-        <tool_use><![CDATA[
-<search_files>
-<path>src</path>
-<regex>JWT_SECRET|JWT_EXPIRATION|AUTH_.*|process\.env\.\w*AUTH\w*</regex>
-</search_files>
-        ]]></tool_use>
-      </step>
-
-      <step number="8">
-        <description>Optional: Use semantic search for deeper insights</description>
-        <tool_use><![CDATA[
-<!-- Only if pattern searches miss important context -->
-<codebase_search>
-<query>authentication error handling user feedback messages</query>
-</codebase_search>
-        ]]></tool_use>
-        <note>Used when specific patterns don't capture all relevant error handling</note>
-      </step>
-
-      <step number="9">
-        <description>Create comprehensive extraction report</description>
-        <tool_use><![CDATA[
-<write_to_file>
-<path>EXTRACTION-authentication-system.md</path>
-<content>
-# Authentication System - Feature Extraction Report
-
-## Executive Summary
-The authentication system is a JWT-based security implementation that handles user registration, login, session management, and access control. It provides a comprehensive user experience with visual feedback, accessibility features, and robust error handling.
-
-## UI/UX Analysis
-
-### User Interface Components
-
-#### 1. Login Page (`src/components/LoginForm.tsx`)
-**Visual Layout:**
-- Centered card design with shadow (400px width)
-- Company logo at top
-- Form fields with floating labels
-- Primary blue theme (#1976d2)
-
-**Interactive Elements:**
-- Email input field
-  - Real-time validation (regex: /^[^\s@]+@[^\s@]+\.[^\s@]+$/)
-  - Error state: Red border and helper text
-  - Success state: Green checkmark icon
-- Password field
-  - Show/hide toggle button (eye icon)
-  - Minimum 8 characters validation
-  - Caps lock warning indicator
-- "Remember me" checkbox with 30-day persistence
-- "Forgot password?" link (underlined on hover)
-- Submit button
-  - Disabled state: Gray background until valid input
-  - Loading state: Spinner replaces text
-  - Success state: Checkmark animation
-
-**User Feedback:**
-- Loading overlay with spinner during authentication
-- Error messages appear with slide-down animation
-- Success toast notification (3s duration)
-- Form shake animation on error
-
-#### 2. Registration Form (`src/components/RegisterForm.tsx`)
-**Multi-Step Design:**
-- Progress bar showing 3 steps
-- Smooth slide transitions between steps
-- Back/Next navigation buttons
-
-**Step 1 - Account Info:**
-- Email field with async availability check
-- Password field with strength meter (5 levels)
-- Password confirmation with match validation
-
-**Step 2 - Personal Info:**
-- First/Last name fields
-- Optional phone with format mask
-- Country dropdown with flag icons
-
-**Step 3 - Terms & Submit:**
-- Terms of service scrollable text
-- Privacy policy link (opens modal)
-- Checkbox required for submission
-- Review summary before final submit
-
-**Visual Feedback:**
-- Field validation on blur
-- Progress saved in localStorage
-- Success confetti animation
-- Auto-redirect countdown (5s)
-
-#### 3. Session Management (`src/components/SessionManager.tsx`)
-**Device List UI:**
-- Card-based layout for each session
-- Device icons (FontAwesome)
-  - fa-mobile for mobile
-  - fa-desktop for desktop
-  - fa-tablet for tablet
-- Information displayed:
-  - Device name and browser
-  - IP address (partially masked)
-  - Last active (relative time)
-  - Location (city, country)
-
-**Interactive Features:**
-- Current device highlighted with blue border
-- Hover state shows "Revoke" button
-- Confirmation modal with device details
-- Bulk selection with checkboxes
-- "Revoke All" with double confirmation
-
-### User Experience Elements
-
-#### Visual Patterns
-**Theme System:**
-```css
---primary-color: #1976d2;
---error-color: #d32f2f;
---success-color: #388e3c;
---warning-color: #f57c00;
---text-primary: rgba(0, 0, 0, 0.87);
---text-secondary: rgba(0, 0, 0, 0.6);
-```
-
-**Animations:**
-- Page transitions: 300ms ease-in-out
-- Button hover: scale(1.02)
-- Error shake: 0.5s horizontal
-- Success checkmark: SVG path animation
-- Loading spinner: 1s rotation
-
-**Responsive Breakpoints:**
-- Mobile: < 768px (single column)
-- Tablet: 768px - 1024px
-- Desktop: > 1024px
-
-#### Accessibility Features
-**Keyboard Navigation:**
-- Tab order follows visual flow
-- Enter key submits forms
-- Escape closes modals
-- Arrow keys in dropdowns
-
-**Screen Reader Support:**
-- ARIA labels on all inputs
-- Live regions for errors
-- Role attributes for custom components
-- Descriptive button text
-
-**Visual Accessibility:**
-- 4.5:1 contrast ratio minimum
-- Focus indicators (2px outline)
-- Error icons for colorblind users
-- Scalable fonts (rem units)
-
-### User Workflows
-
-#### 1. First-Time Registration
-```
-Start → Landing Page → "Get Started" CTA
-  ↓
-Registration Form (Step 1)
-  → Email validation (async)
-  → Password strength check
-  → Real-time feedback
-  ↓
-Personal Info (Step 2)
-  → Optional fields clearly marked
-  → Format validation
-  ↓
-Terms Agreement (Step 3)
-  → Must scroll to enable checkbox
-  → Review summary
-  ↓
-Submit → Loading → Success
-  → Confetti animation
-  → Welcome email sent
-  → Auto-redirect (5s)
-  ↓
-Dashboard (First-time tour)
-```
-
-#### 2. Returning User Login
-```
-Start → Login Page
-  ↓
-Enter Credentials
-  → Email autocomplete
-  → Password manager integration
-  → "Remember me" option
-  ↓
-Submit → Loading (avg 1.2s)
-  ↓
-Success → Dashboard
-  OR
-Error → Inline feedback
-  → Retry with guidance
-  → "Forgot password?" option
-```
-
-#### 3. Password Reset Flow
-```
-Login Page → "Forgot password?"
-  ↓
-Modal Dialog
-  → Email input
-  → Captcha (if multiple attempts)
-  ↓
-Submit → "Check email" message
-  ↓
-Email Received (< 1 min)
-  → Secure link (1hr expiry)
-  ↓
-Reset Page
-  → New password requirements shown
-  → Strength meter
-  → Confirmation field
-  ↓
-Submit → Success → Login redirect
-```
-
-## Technical Details
-
-### Core Components
-1. **AuthController** (`src/auth/auth.controller.ts`)
-   - REST endpoints with validation decorators
-   - Rate limiting middleware
-   - CORS configuration
-
-2. **AuthService** (`src/auth/auth.service.ts`)
-   - JWT token generation/validation
-   - Bcrypt password hashing
-   - Session management logic
-
-3. **Security Implementation**
-   - JWT RS256 algorithm
-   - Refresh token rotation
-   - CSRF double-submit cookies
-   - XSS protection headers
-
-### API Endpoints
-| Method | Endpoint | Description | Rate Limit |
-|--------|----------|-------------|------------|
-| POST | /auth/register | New user registration | 3/hour |
-| POST | /auth/login | User authentication | 5/min |
-| POST | /auth/refresh | Token refresh | 10/min |
-| POST | /auth/logout | Session termination | None |
-| GET | /auth/profile | Current user data | None |
-| POST | /auth/reset-password | Password reset | 3/hour |
-
-### Configuration
-```env
-# Required
-JWT_SECRET=minimum-32-character-secret
-DATABASE_URL=postgresql://...
-
-# Optional with defaults
-JWT_EXPIRATION=15m
-REFRESH_TOKEN_EXPIRATION=7d
-BCRYPT_ROUNDS=10
-SESSION_MAX_AGE=30d
-MAX_SESSIONS_PER_USER=5
-```
-
-## Non-Technical Information
-
-### Business Rules
-1. **Account Creation**
-   - Unique email required
-   - Password: 8+ chars, mixed case, number, special
-   - Email verification within 24 hours
-   - Terms acceptance mandatory
-
-2. **Session Management**
-   - Max 5 concurrent sessions
-   - Idle timeout: 30 minutes
-   - Absolute timeout: 7 days
-   - Device trust for 30 days
-
-3. **Security Policies**
-   - Account lockout: 5 failed attempts (15 min)
-   - Password history: Last 3 not reusable
-   - 2FA optional but recommended
-   - Suspicious login notifications
-
-### Common User Scenarios
-
-#### Mobile Experience
-- Touch-optimized buttons (44px min)
-- Biometric login (Face ID/Touch ID)
-- Simplified navigation menu
-- Offline detection with retry
-- Push notification for new sessions
-
-#### Error Recovery
-- Network timeout: Auto-retry with backoff
-- Session expired: Smooth re-login flow
-- Form errors: Contextual help text
-- Server errors: Friendly messages with support link
-
-### Performance Metrics
-- Login response: 200ms (p50), 500ms (p95)
-- Page load: 1.2s (3G), 400ms (4G)
-- Token validation: < 10ms
-- Session check: < 50ms
-
-## Documentation Recommendations
-
-### Critical Areas for User Documentation
-1. **Getting Started Guide**
-   - Screenshots of each registration step
-   - Common email provider settings
-   - Password manager setup
-
-2. **Troubleshooting Section**
-   - "Why can't I log in?" flowchart
-   - Browser compatibility matrix
-   - Cookie/JavaScript requirements
-
-3. **Security Best Practices**
-   - How to spot phishing attempts
-   - Importance of unique passwords
-   - When to revoke sessions
-
-### Developer Integration Guide
-1. **API Authentication**
-   - Bearer token format
-   - Refresh token flow diagram
-   - Error response examples
-
-2. **SDK Examples**
-   - JavaScript/TypeScript
-   - Python
-   - Mobile (iOS/Android)
-
-## Integration Points
-- Email service for password reset and notifications
-- Session storage (Redis optional, in-memory default)
-- Rate limiting middleware
-- CORS configuration for cross-origin requests
-- Logging service for audit trails
-
-## Summary for Documentation Team
-This extraction report provides comprehensive details about the authentication system's current implementation. The system offers a complete user experience with visual feedback, accessibility features, and robust security measures. Key areas for user documentation include the multi-step registration process, session management features, and security policies. The technical implementation uses industry-standard JWT tokens with proper security measures.
-</content>
-<line_count>354</line_count>
-</write_to_file>
-        ]]></tool_use>
-      </step>
-    </workflow>
-
-    <key_takeaways>
-      <takeaway>Use flexible discovery methods - directory exploration and pattern search are primary tools</takeaway>
-      <takeaway>Comprehensive UI/UX analysis is essential for complete documentation</takeaway>
-      <takeaway>Document visual elements, interactions, and user feedback mechanisms</takeaway>
-      <takeaway>Include accessibility and responsive design considerations</takeaway>
-      <takeaway>Semantic search (codebase_search) is optional for deeper insights when needed</takeaway>
-      <takeaway>Organize findings to support documentation team's work</takeaway>
-    </key_takeaways>
-  </example>
-
-  <example name="documentation_verification_example">
-    <scenario>
-      Verify user-provided documentation about authentication UI/UX against the actual implementation.
-    </scenario>
-
-    <workflow>
-      <step number="1">
-        <description>User provides documentation to verify</description>
-        <user_input>
-          "Please verify our login documentation:
-          
-          'The login form provides a seamless experience with instant validation. Users see a green checkmark when their email is valid. The password field includes a strength indicator. After 3 failed attempts, users must wait 5 minutes before trying again.'"
-        </user_input>
-      </step>
-
-      <step number="2">
-        <description>Analyze the documentation claims</description>
-        <analysis>
-          Claims to verify:
-          - Instant email validation with green checkmark
-          - Password strength indicator on login
-          - 3 failed attempts triggers 5-minute wait
-        </analysis>
-      </step>
-
-      <step number="3">
-        <description>Find login UI components using directory exploration</description>
-        <tool_use><![CDATA[
-<list_files>
-<path>src/components</path>
-<recursive>false</recursive>
-</list_files>
-        ]]></tool_use>
-        <tool_use><![CDATA[
-<search_files>
-<path>src/components</path>
-<regex>Login|SignIn|Auth.*Form</regex>
-<file_pattern>*.tsx</file_pattern>
-</search_files>
-        ]]></tool_use>
-      </step>
-
-      <step number="4">
-        <description>Examine login form implementation</description>
-        <tool_use><![CDATA[
-<read_file>
-<args>
-  <file>
-    <path>src/components/LoginForm.tsx</path>
-  </file>
-  <file>
-    <path>src/components/LoginForm.css</path>
-  </file>
-</args>
-</read_file>
-        ]]></tool_use>
-        <findings>
-          - Email validation exists but shows red X, not green checkmark
-          - No password strength indicator on login form (only on registration)
-          - Account lockout is after 5 attempts, not 3
-          - Lockout duration is 15 minutes, not 5
-        </findings>
-      </step>
-
-      <step number="5">
-        <description>Verify validation behavior</description>
-        <tool_use><![CDATA[
-<search_files>
-<path>src/components</path>
-<regex>validateEmail|emailValid|checkmark|strength.*indicator</regex>
-</search_files>
-        ]]></tool_use>
-        <tool_use><![CDATA[
-<search_files>
-<path>src/auth</path>
-<regex>failed.*attempts|lockout|rate.*limit</regex>
-</search_files>
-        ]]></tool_use>
-      </step>
-
-      <step number="6">
-        <description>Create verification report</description>
-        <tool_use><![CDATA[
-<write_to_file>
-<path>VERIFICATION-login-documentation.md</path>
-<content>
-# Login Documentation - Verification Report
-
-## Overall Assessment: Needs Significant Updates
-
-## Summary
-The login documentation contains several inaccuracies about the UI/UX implementation that could confuse users and lead to poor user experience.
-
-## Critical Inaccuracies
-
-### 1. Email Validation Feedback
-**Documentation States**: "Users see a green checkmark when their email is valid"
-**Actual Implementation**: Red X icon for invalid emails, no positive feedback
-- Location: `src/components/LoginForm.tsx:45-52`
-- Current behavior: Only shows error states
-- Missing: Success indicator implementation
-- **Impact**: Users don't get positive reinforcement for correct input
-
-### 2. Password Strength Indicator
-**Documentation States**: "The password field includes a strength indicator"
-**Actual Implementation**: No strength indicator on login form
-- Location: Checked `src/components/LoginForm.tsx`
-- Strength indicator only exists in `RegisterForm.tsx`
-- Login form has basic password field only
-- **Impact**: Sets incorrect user expectations
-
-### 3. Failed Login Attempts
-**Documentation States**: "After 3 failed attempts, users must wait 5 minutes"
-**Actual Implementation**: 5 attempts, 15-minute lockout
-- Location: `src/auth/services/auth.service.ts:234`
-- Code: `MAX_LOGIN_ATTEMPTS = 5`
-- Code: `LOCKOUT_DURATION = 15 * 60 * 1000 // 15 minutes`
-- **Impact**: Users may be confused about actual security policy
-
-## UI/UX Elements Found But Not Documented
-
-### 1. Loading States
-- Spinner overlay during authentication
-- Button disabled state during submission
-- These improve perceived performance
-
-### 2. Remember Me Feature
-- 30-day persistent session option
-- Stored in secure cookie
-- Not mentioned in documentation
-
-### 3. Caps Lock Warning
-- Visual indicator when caps lock is on
-- Helps prevent login failures
-- Important accessibility feature
-
-## Recommendations
-
-### Immediate Corrections Needed
-1. **Email Validation**:
-   ```
-   CORRECT: "The email field shows a red error icon for invalid formats. Valid emails are accepted without visual confirmation."
-   ```
-
-2. **Password Features**:
-   ```
-   CORRECT: "The login form has a standard password field with show/hide toggle. Password strength indicators are only shown during registration."
-   ```
-
-3. **Security Policy**:
-   ```
-   CORRECT: "After 5 failed login attempts, accounts are temporarily locked for 15 minutes to prevent brute force attacks."
-   ```
-
-### Suggested Additions
-1. Document the loading states and visual feedback
-2. Explain the "Remember Me" functionality
-3. Mention the Caps Lock warning feature
-4. Add screenshots of actual UI states
-
-## Technical References
-- Login Form Component: `src/components/LoginForm.tsx`
-- Styles: `src/components/LoginForm.css`
-- Auth Service: `src/auth/services/auth.service.ts`
-- Rate Limiting: `src/middleware/rateLimiter.ts`
-
-## Visual Discrepancies
-- Documentation implies more visual feedback than implemented
-- Color scheme in docs doesn't match actual theme
-- Missing documentation for error message styling
-
-## Conclusion
-The documentation needs updates to accurately reflect the current login experience. The actual implementation is more security-focused (5 attempts, 15-min lockout) but less visually rich (no success indicators) than documented.
-</content>
-<line_count>95</line_count>
-</write_to_file>
-        ]]></tool_use>
-      </step>
-    </workflow>
-
-    <key_takeaways>
-      <takeaway>Always verify UI/UX claims against actual component implementation</takeaway>
-      <takeaway>Check both visual elements and behavioral logic</takeaway>
-      <takeaway>Look for undocumented features that users might expect</takeaway>
-      <takeaway>Provide specific corrections with code references</takeaway>
-      <takeaway>Consider the impact of inaccuracies on user experience</takeaway>
-    </key_takeaways>
-  </example>
-
-  <example name="api_endpoint_extraction">
-    <scenario>
-      Extract comprehensive API documentation including endpoints, request/response formats, and error handling.
-    </scenario>
-
-    <workflow>
-      <step number="1">
-        <description>Discover API structure using flexible methods</description>
-        <tool_use><![CDATA[
-<!-- Method 1: Look for common API directories -->
-<list_files>
-<path>src</path>
-<recursive>false</recursive>
-</list_files>
-        ]]></tool_use>
-        <tool_use><![CDATA[
-<list_files>
-<path>src/api</path>
-<recursive>true</recursive>
-</list_files>
-        ]]></tool_use>
-      </step>
-
-      <step number="2">
-        <description>Find all API routes using pattern search</description>
-        <tool_use><![CDATA[
-<search_files>
-<path>src</path>
-<regex>(app|router)\.(get|post|put|patch|delete|all)\s*\(\s*['"`]([^'"`]+)['"`]</regex>
-</search_files>
-        ]]></tool_use>
-      </step>
-
-      <step number="3">
-        <description>Extract request validation schemas</description>
-        <tool_use><![CDATA[
-<search_files>
-<path>src</path>
-<regex>@(Body|Query|Param|Headers)\(|joi\.object|yup\.object|zod\.object</regex>
-</search_files>
-        ]]></tool_use>
-      </step>
-
-      <step number="4">
-        <description>Analyze error handling and responses</description>
-        <tool_use><![CDATA[
-<search_files>
-<path>src</path>
-<regex>@ApiResponse|response\.status\(|res\.status\(|throw new.*Error</regex>
-</search_files>
-        ]]></tool_use>
-      </step>
-
-      <step number="5">
-        <description>Optional: Semantic search for middleware and auth</description>
-        <tool_use><![CDATA[
-<!-- Use when pattern search might miss complex middleware chains -->
-<codebase_search>
-<query>API middleware authentication authorization guards</query>
-</codebase_search>
-        ]]></tool_use>
-      </step>
-
-      <step number="6">
-        <description>Generate API extraction report</description>
-        <output>
-          - Complete endpoint inventory with methods and paths
-          - Request/response schemas with examples
-          - Authentication requirements per endpoint
-          - Rate limiting and throttling rules
-          - Error response formats and codes
-          - API versioning strategy
-        </output>
-      </step>
-    </workflow>
-  </example>
-
-  <example name="ui_component_library_extraction">
-    <scenario>
-      Document a React component library including props, styling, accessibility, and usage patterns.
-    </scenario>
-
-    <workflow>
-      <step number="1">
-        <description>Discover component structure</description>
-        <tool_use><![CDATA[
-<list_files>
-<path>src/components</path>
-<recursive>true</recursive>
-</list_files>
-        ]]></tool_use>
-      </step>
-
-      <step number="2">
-        <description>Analyze component interfaces and props</description>
-        <tool_use><![CDATA[
-<search_files>
-<path>src/components</path>
-<regex>interface\s+\w+Props|type\s+\w+Props|export\s+(default\s+)?function|export\s+const</regex>
-<file_pattern>*.tsx</file_pattern>
-</search_files>
-        ]]></tool_use>
-      </step>
-
-      <step number="3">
-        <description>Extract styling and theme usage</description>
-        <tool_use><![CDATA[
-<search_files>
-<path>src/components</path>
-<regex>styled\.|makeStyles|className=|sx=|css=</regex>
-</search_files>
-        ]]></tool_use>
-      </step>
-
-      <step number="4">
-        <description>Document accessibility features</description>
-        <tool_use><![CDATA[
-<search_files>
-<path>src/components</path>
-<regex>aria-|role=|tabIndex|alt=|htmlFor=</regex>
-</search_files>
-        ]]></tool_use>
-      </step>
-
-      <step number="5">
-        <description>Find usage examples and stories</description>
-        <tool_use><![CDATA[
-<search_files>
-<path>src</path>
-<regex>\.stories\.|\.story\.|examples?/|demo/</regex>
-<file_pattern>*.tsx</file_pattern>
-</search_files>
-        ]]></tool_use>
-      </step>
-
-      <step number="6">
-        <description>Create component library report</description>
-        <output>
-          - Component hierarchy and relationships
-          - Props documentation with types and defaults
-          - Styling system and customization options
-          - Accessibility compliance checklist
-          - Interactive examples and code snippets
-          - Best practices and anti-patterns
-          - Browser compatibility notes
-        </output>
-      </step>
-    </workflow>
-  </example>
-
-  <best_practices>
-    <practice name="flexible_discovery">
-      <description>Use the most appropriate discovery method</description>
-      <guidelines>
-        <guideline>Start with directory exploration for well-organized codebases</guideline>
-        <guideline>Use pattern search for specific syntax or naming conventions</guideline>
-        <guideline>Apply file-based search when you know exact locations</guideline>
-        <guideline>Reserve semantic search for complex conceptual queries</guideline>
-      </guidelines>
-    </practice>
-
-    <practice name="comprehensive_ui_ux_coverage">
-      <description>Ensure complete UI/UX documentation</description>
-      <checklist>
-        <item>Visual design and layout</item>
-        <item>Interactive elements and states</item>
-        <item>User feedback mechanisms</item>
-        <item>Accessibility features</item>
-        <item>Responsive behavior</item>
-        <item>Animation and transitions</item>
-        <item>Error states and recovery</item>
-        <item>Loading and progress indicators</item>
-      </checklist>
-    </practice>
-
-    <practice name="verification_thoroughness">
-      <description>Verify all aspects of documentation claims</description>
-      <checklist>
-        <item>Technical accuracy of code examples</item>
-        <item>UI element descriptions match implementation</item>
-        <item>User workflows reflect actual behavior</item>
-        <item>Configuration values are current</item>
-        <item>Error messages match code</item>
-        <item>Performance claims are realistic</item>
-      </checklist>
-    </practice>
-  </best_practices>
-</complete_extraction_examples>
\ No newline at end of file
diff --git a/.roo/rules-docs-extractor/6_communication_guidelines.xml b/.roo/rules-docs-extractor/6_communication_guidelines.xml
deleted file mode 100644
index 8691f2519..000000000
--- a/.roo/rules-docs-extractor/6_communication_guidelines.xml
+++ /dev/null
@@ -1,314 +0,0 @@
-<communication_guidelines>
-  <overview>
-    Guidelines for user communication and output formatting.
-  </overview>
-
-  <user_interaction>
-    <initial_contact>
-      <principle>Act on the user's request immediately.</principle>
-      <principle>Only ask for clarification if the request is ambiguous.</principle>
-    </initial_contact>
-
-    <clarification>
-      <when_to_ask>
-        <scenario>Multiple features with similar names are found.</scenario>
-        <scenario>The request is ambiguous.</scenario>
-        <scenario>The user explicitly asks for options.</scenario>
-      </when_to_ask>
-      
-      <question_example><![CDATA[
-<ask_followup_question>
-<question>Found multiple auth systems. Which to document?</question>
-<follow_up>
-<suggest>JWT-based system (src/auth/jwt/*)</suggest>
-<suggest>OAuth2 integration (src/auth/oauth/*)</suggest>
-<suggest>Basic auth middleware (src/middleware/basic-auth.ts)</suggest>
-<suggest>All of them</suggest>
-</follow_up>
-</ask_followup_question>
-      ]]></question_example>
-    </clarification>
-
-    <progress_updates>
-      <when_to_update>
-        <trigger>Starting a major analysis phase.</trigger>
-        <trigger>Extraction is complete.</trigger>
-        <trigger>Unexpected complexity is found.</trigger>
-      </when_to_update>
-      
-      <update_format>
-        <template>
-          Analyzing [component]...
-          - Found [X] related files.
-          - Identified [Y] API endpoints.
-          - Found [Z] config options.
-        </template>
-      </update_format>
-    </progress_updates>
-
-    <findings_communication>
-      <important_findings>
-        <discovery type="security_issue">
-          Alert user to security concerns found during analysis.
-        </discovery>
-        <discovery type="deprecated_code">
-          Note deprecated features needing migration docs.
-        </discovery>
-        <discovery type="missing_docs">
-          Highlight code that lacks inline documentation.
-        </discovery>
-        <discovery type="complex_dependencies">
-          Warn about complex dependency chains.
-        </discovery>
-      </important_findings>
-      <extraction_findings>
-        <template><![CDATA[
-Feature extraction complete for [feature name].
-
-**Extraction Report**: `EXTRACTION-[feature].md`
-
-**Key Findings**:
-- Technical Components: [X] classes, [Y] APIs, [Z] configurations
-- User Workflows: [number] primary use cases identified
-- Business Logic: [summary of core functionality]
-- Integration Points: [list of external dependencies]
-
-**Documentation Considerations**:
-- [Important aspect that needs clear explanation]
-- [Complex area that may need diagrams]
-- [Edge cases that should be documented]
-
-The extraction report provides comprehensive details for your documentation team.
-        ]]></template>
-      </extraction_findings>
-      <verification_findings>
-        <template><![CDATA[
-Documentation verification complete.
-
-**Verification Report**: `VERIFICATION-[feature].md`
-
-**Overall Assessment**: [Accurate/Needs Updates/Contains Critical Errors]
-
-**Summary of Findings**:
-- Critical Inaccuracies: [number]
-- Technical Corrections Needed: [number]
-- Missing Information: [number]
-- Clarity Improvements: [number]
-
-**Most Important Issues**:
-1. [Critical issue that could mislead users]
-2. [Important technical inaccuracy]
-3. [Key missing information]
-
-See the full verification report for detailed corrections and suggestions.
-        ]]></template>
-      </verification_findings>
-    </findings_communication>
-  </user_interaction>
-
-  <output_formatting>
-    <markdown_standards>
-      <headings>
-        <rule>Use # for main title, ## for major sections, ### for subsections.</rule>
-        <rule>Never skip heading levels.</rule>
-      </headings>
-
-      <code_blocks>
-        <rule>Always specify language for syntax highlighting (e.g., typescript, json, bash).</rule>
-        <rule>Include file paths as comments where relevant.</rule>
-        <example><![CDATA[
-```typescript
-// src/auth/auth.service.ts
-export class AuthService {
-  async validateUser(email: string, password: string): Promise<User> {
-    // Implementation
-  }
-}
-```
-        ]]></example>
-      </code_blocks>
-
-      <tables>
-        <rule>Use tables for structured data like configs.</rule>
-        <rule>Include headers and align columns.</rule>
-        <rule>Keep cell content brief.</rule>
-        <example><![CDATA[
-| Variable | Type | Default | Description |
-|----------|------|---------|-------------|
-| `JWT_SECRET` | string | - | Secret key for JWT signing |
-| `JWT_EXPIRATION` | string | '15m' | Token expiration time |
-        ]]></example>
-      </tables>
-
-      <lists>
-        <rule>Use bullets for unordered lists, numbers for sequential steps.</rule>
-        <rule>Keep list items parallel in structure.</rule>
-      </lists>
-    </markdown_standards>
-
-    <cross_references>
-      <internal_links>
-        <format>[Link text](#section-anchor)</format>
-        <rule>Use lowercase, hyphenated anchors. Test all links.</rule>
-      </internal_links>
-
-      <external_links>
-        <format>[Link text](https://example.com)</format>
-        <rule>Use HTTPS. Link to official docs.</rule>
-      </external_links>
-
-      <file_references>
-        <format>`path/to/file.ts`</format>
-        <rule>Use relative paths from project root, in backticks.</rule>
-      </file_references>
-    </cross_references>
-
-    <special_sections>
-      <alerts>
-        <type name="warning">
-          <format>> ⚠️ **Warning**: [message]</format>
-          <use_for>Security, breaking changes, deprecations.</use_for>
-        </type>
-        <type name="note">
-          <format>> 📝 **Note**: [message]</format>
-          <use_for>Important info, clarifications.</use_for>
-        </type>
-        <type name="tip">
-          <format>> 💡 **Tip**: [message]</format>
-          <use_for>Best practices, optimizations.</use_for>
-        </type>
-      </alerts>
-
-      <metadata_blocks>
-        <version_info><![CDATA[
----
-Feature: Authentication System
-Version: 2.1.0
-Last Updated: 2024-01-15
-Status: Stable
----
-        ]]></version_info>
-      </metadata_blocks>
-    </special_sections>
-  </output_formatting>
-
-  <documentation_tone>
-    <general>
-      <principle>Be direct, not conversational.</principle>
-      <principle>Use active voice.</principle>
-      <principle>Lead with benefits.</principle>
-      <principle>Use concrete examples.</principle>
-      <principle>Keep paragraphs short.</principle>
-      <principle>Avoid unnecessary technical details.</principle>
-    </general>
-
-    <audience_tone>
-      <audience type="developer">
-        <tone>Technical and direct.</tone>
-        <vocabulary>Standard programming terms.</vocabulary>
-        <examples>Code snippets, implementation details.</examples>
-      </audience>
-      <audience type="end_user">
-        <tone>Instructional, step-by-step.</tone>
-        <vocabulary>Simple language, no jargon.</vocabulary>
-        <examples>Screenshots, real-world scenarios.</examples>
-      </audience>
-      <audience type="administrator">
-        <tone>Operational focus.</tone>
-        <vocabulary>IT/DevOps terms.</vocabulary>
-        <examples>CLI examples, configs.</examples>
-      </audience>
-    </audience_tone>
-  </documentation_tone>
-
-  <completion_message>
-    <structure>
-      <element>Summary of analysis performed.</element>
-      <element>Key findings or issues identified.</element>
-      <element>Report file location.</element>
-      <element>Recommended next steps.</element>
-    </structure>
-
-    <extraction_example><![CDATA[
-Feature extraction complete for the authentication system.
-
-**Extraction Report**: `EXTRACTION-authentication-system.md`
-
-**Technical Summary**:
-- JWT-based authentication with refresh tokens
-- 5 API endpoints (login, logout, refresh, register, profile)
-- 12 configuration options
-- bcrypt password hashing, rate limiting
-
-**Non-Technical Summary**:
-- Users can register, login, and manage sessions
-- Supports "remember me" functionality
-- Automatic session refresh for seamless experience
-- Account lockout after failed attempts
-
-**Documentation Considerations**:
-- Token expiration times need clear explanation
-- Password requirements should be prominently displayed
-- Error messages need user-friendly translations
-
-The extraction report contains all details needed for comprehensive documentation.
-    ]]></extraction_example>
-
-    <verification_example><![CDATA[
-Documentation verification complete for the authentication system.
-
-**Verification Report**: `VERIFICATION-authentication-system.md`
-
-**Overall Assessment**: Needs Updates
-
-**Critical Issues Found**:
-1. JWT_SECRET documented as optional, but it's required
-2. Token expiration listed as 30m, actual is 15m
-3. Missing documentation for rate limiting feature
-
-**Technical Corrections**: 7 items
-**Missing Information**: 4 sections
-**Clarity Improvements**: 3 suggestions
-
-Please review the verification report for specific corrections needed.
-    ]]></verification_example>
-  </completion_message>
-
-  <error_handling>
-    <scenarios>
-      <scenario type="feature_not_found">
-        <response>
-          Could not find a feature matching "[feature name]". Similar features found:
-          - [List similar features]
-          Document one of these instead?
-        </response>
-      </scenario>
-
-      <scenario type="insufficient_docs">
-        <response>
-          Code for [feature] has limited inline documentation. Extracting from code structure, tests, and usage patterns.
-        </response>
-      </scenario>
-
-      <scenario type="complex_feature">
-        <response>
-          This feature is complex. Choose documentation scope:
-          - Document comprehensively
-          - Focus on core functionality
-          - Split into multiple documents
-        </response>
-      </scenario>
-    </scenarios>
-  </error_handling>
-
-  <quality_checks>
-    <before_completion>
-      <check>No placeholder content remains.</check>
-      <check>Code examples are correct.</check>
-      <check>Links and cross-references work.</check>
-      <check>Tables are formatted correctly.</check>
-      <check>Version info is included.</check>
-      <check>Filename follows conventions.</check>
-    </before_completion>
-  </quality_checks>
-</communication_guidelines>
\ No newline at end of file
diff --git a/.roo/rules-docs-extractor/7_user_friendly_examples.xml b/.roo/rules-docs-extractor/7_user_friendly_examples.xml
deleted file mode 100644
index 6b94e88de..000000000
--- a/.roo/rules-docs-extractor/7_user_friendly_examples.xml
+++ /dev/null
@@ -1,218 +0,0 @@
-<user_friendly_examples>
-  <overview>
-    Examples for creating user-focused, practical documentation.
-  </overview>
-
-  <writing_principles>
-    <principle name="benefits_over_features">
-      <bad>The concurrent file read feature uses parallel processing.</bad>
-      <good>Read multiple files at once, reducing interruptions.</good>
-    </principle>
-
-    <principle name="use_scenarios">
-      <bad>This improves efficiency.</bad>
-      <good>Instead of approving 10 file reads one-by-one, approve them all at once.</good>
-    </principle>
-
-    <principle name="hide_implementation_details">
-      <bad>The feature uses a thread pool with configurable concurrency limits.</bad>
-      <good>Roo reads up to 100 files at once (changeable in settings).</good>
-    </principle>
-
-    <principle name="direct_tone">
-      <bad>Users must configure the concurrent file read limit parameter.</bad>
-      <good>Adjust how many files Roo reads at once in settings.</good>
-    </principle>
-  </writing_principles>
-
-  <structure_examples>
-    <example name="feature_intro">
-      <template><![CDATA[
-# [Feature Name]
-
-[One-sentence description of what it does.]
-
-### Key Features
-- [Benefit 1]
-- [Benefit 2]
-- [Benefit 3]
-
----
-      ]]></template>
-    </example>
-
-    <example name="use_case">
-      <template><![CDATA[
-## Use Case
-
-**Before**: [Description of the old way]
-- [Pain point]
-- [Pain point]
-
-**Now**: [Description of the new way]
-      ]]></template>
-    </example>
-
-    <example name="configuration">
-      <template><![CDATA[
-## Configuration
-
-Customize this feature in settings:
-
-1. **[Setting Name]**
-   - **Does**: [Plain language explanation.]
-   - **Default**: [Default value.] (Works for most.)
-   - **Change if**: [Specific scenarios to adjust this.]
-
-2. **[Setting Name]**
-   - **Does**: [Plain language explanation.]
-   - **Default**: [Default value.]
-   - **Change if**: [Specific use case.]
-      ]]></template>
-    </example>
-
-    <example name="faq">
-      <template><![CDATA[
-## FAQ
-
-**"[User question]"**
-- [Direct answer.]
-- [Optional tip.]
-
-**"[Another question]"**
-- [Direct answer.]
-- [Optional link.]
-      ]]></template>
-    </example>
-
-    <example name="troubleshooting">
-      <template><![CDATA[
-## Troubleshooting
-
-### [Problem symptom]
-**Cause**: [Brief explanation.]
-**Fix**: [Immediate solution.]
-**Alternate fix**: [Alternative solution.]
-
-### [Another issue]
-**Scenario**: [When this happens.]
-**Solution**:
-1. [Step 1]
-2. [Step 2]
-      ]]></template>
-    </example>
-
-  </structure_examples>
-
-  <tone_examples>
-    <explanations>
-      <example context="limit">
-        <technical>The system imposes a hard limit of 100 concurrent operations.</technical>
-        <direct>Roo handles up to 100 files at once.</direct>
-      </example>
-
-      <example context="error">
-        <technical>Error: Maximum concurrency threshold exceeded.</technical>
-        <direct>Too many files requested. Lower the file limit in settings.</direct>
-      </example>
-
-      <example context="benefit">
-        <technical>Reduces API call overhead through request batching.</technical>
-        <direct>Get answers faster by reading all needed files at once.</direct>
-      </example>
-    </explanations>
-
-    <visuals>
-      <emojis>
-        <when>Error: ⚠️</when>
-        <when>Tip: 💡</when>
-        <when>Note: 📝</when>
-        <when>Security: 🔒</when>
-      </emojis>
-
-      <formatting>
-        <bold>For emphasis</bold>
-        <code>For settings, file paths, or commands</code>
-        <blockquotes>For callouts or warnings</blockquotes>
-      </formatting>
-    </visuals>
-  </tone_examples>
-
-  <real_world_example>
-    <title>Concurrent File Reads Doc</title>
-    <content><![CDATA[
-# Concurrent File Reads
-
-Read multiple files from your workspace in a single step.
-
-### Key Features
-- Read up to 100 files in one request.
-- Enabled by default for faster workflow.
-- Configurable to match system capabilities.
-
----
-
-## Use Case
-
-**Before**: Multiple, sequential requests to read files:
-- "Read `src/app.js`?" → Approve
-- "Read `src/utils.js`?" → Approve
-- "Read `src/config.json`?" → Approve
-
-**Now**: Roo asks once to read all related files.
-
-## How it Works
-
-Roo automatically identifies and reads relevant files together for tasks requiring multi-file context, such as:
-
-- Understanding components split across multiple files.
-- Refactoring code with dependencies.
-- Answering questions requiring broad project context.
-
-The [`read_file`](/tools/read-file) tool accepts multiple files in a single request.
-
----
-
-## Configuration
-
-Customize in Roo's settings:
-
-1. **Enable/Disable Concurrent File Reads**
-   - **Does**: Toggles whether Roo can read multiple files at once.
-   - **Default**: Enabled.
-   - **Disable if**: Using a less capable AI model or requiring more access control.
-
-2. **Concurrent File Reads Limit**
-   - **Does**: Sets max number of files Roo can read at once.
-   - **Default**: 100.
-   - **Adjust**: Lower for memory constraints; raise for very large projects.
-
----
-
-## FAQ
-
-**"Too many files are requested at once."**
-- Lower the file limit in settings.
-- Deny individual files in the batch dialog.
-
-**"Some files were denied but others were approved."**
-- Normal behavior. Roo works with approved files.
-- Files may be blocked by `.rooignore` settings.
-
-**"Does this use more memory?"**
-- Yes, but the impact is usually minimal.
-- If you see slowdowns, reduce the file limit.
-
-    ]]></content>
-  </real_world_example>
-
-  <checklist>
-    <item>Does it start with benefits?</item>
-    <item>Are technical terms avoided?</item>
-    <item>Is the tone direct?</item>
-    <item>Are there practical examples?</item>
-    <item>Are sections short and scannable?</item>
-    <item>Does it answer user questions?</item>
-    <item>Is help accessible?</item>
-  </checklist>
-</user_friendly_examples>
\ No newline at end of file
diff --git a/.roo/rules-integration-tester/1_workflow.xml b/.roo/rules-integration-tester/1_workflow.xml
deleted file mode 100644
index b0ebc535e..000000000
--- a/.roo/rules-integration-tester/1_workflow.xml
+++ /dev/null
@@ -1,198 +0,0 @@
-<workflow>
-  <step number="1">
-    <name>Understand Test Requirements</name>
-    <instructions>
-      Use ask_followup_question to determine what type of integration test is needed:
-      
-      <ask_followup_question>
-      <question>What type of integration test would you like me to create or work on?</question>
-      <follow_up>
-      <suggest>New E2E test for a specific feature or workflow</suggest>
-      <suggest>Fix or update an existing integration test</suggest>
-      <suggest>Create test utilities or helpers for common patterns</suggest>
-      <suggest>Debug failing integration tests</suggest>
-      </follow_up>
-      </ask_followup_question>
-    </instructions>
-  </step>
-
-  <step number="2">
-    <name>Gather Test Specifications</name>
-    <instructions>
-      Based on the test type, gather detailed requirements:
-      
-      For New E2E Tests:
-      - What specific user workflow or feature needs testing?
-      - What are the expected inputs and outputs?
-      - What edge cases or error scenarios should be covered?
-      - Are there specific API interactions to validate?
-      - What events should be monitored during the test?
-      
-      For Existing Test Issues:
-      - Which test file is failing or needs updates?
-      - What specific error messages or failures are occurring?
-      - What changes in the codebase might have affected the test?
-      
-      For Test Utilities:
-      - What common patterns are being repeated across tests?
-      - What helper functions would improve test maintainability?
-      
-      Use multiple ask_followup_question calls if needed to gather complete information.
-    </instructions>
-  </step>
-
-  <step number="3">
-    <name>Explore Existing Test Patterns</name>
-    <instructions>
-      Use codebase_search FIRST to understand existing test patterns and similar functionality:
-      
-      For New Tests:
-      - Search for similar test scenarios in apps/vscode-e2e/src/suite/
-      - Find existing test utilities and helpers
-      - Identify patterns for the type of functionality being tested
-      
-      For Test Fixes:
-      - Search for the failing test file and related code
-      - Find similar working tests for comparison
-      - Look for recent changes that might have broken the test
-      
-      Example searches:
-      - "file creation test mocha" for file operation tests
-      - "task completion waitUntilCompleted" for task monitoring patterns
-      - "api message validation" for API interaction tests
-      
-      After codebase_search, use:
-      - read_file on relevant test files to understand structure
-      - list_code_definition_names on test directories
-      - search_files for specific test patterns or utilities
-    </instructions>
-  </step>
-
-  <step number="4">
-    <name>Analyze Test Environment and Setup</name>
-    <instructions>
-      Examine the test environment configuration:
-      
-      1. Read the test runner configuration:
-         - apps/vscode-e2e/package.json for test scripts
-         - apps/vscode-e2e/src/runTest.ts for test setup
-         - Any test configuration files
-      
-      2. Understand the test workspace setup:
-         - How test workspaces are created
-         - What files are available during tests
-         - How the extension API is accessed
-      
-      3. Review existing test utilities:
-         - Helper functions for common operations
-         - Event listening patterns
-         - Assertion utilities
-         - Cleanup procedures
-      
-      Document findings including:
-      - Test environment structure
-      - Available utilities and helpers
-      - Common patterns and best practices
-    </instructions>
-  </step>
-
-  <step number="5">
-    <name>Design Test Structure</name>
-    <instructions>
-      Plan the test implementation based on gathered information:
-      
-      For New Tests:
-      - Define test suite structure with suite/test blocks
-      - Plan setup and teardown procedures
-      - Identify required test data and fixtures
-      - Design event listeners and validation points
-      - Plan for both success and failure scenarios
-      
-      For Test Fixes:
-      - Identify the root cause of the failure
-      - Plan the minimal changes needed to fix the issue
-      - Consider if the test needs to be updated due to code changes
-      - Plan for improved error handling or debugging
-      
-      Create a detailed test plan including:
-      - Test file structure and organization
-      - Required setup and cleanup
-      - Specific assertions and validations
-      - Error handling and edge cases
-    </instructions>
-  </step>
-
-  <step number="6">
-    <name>Implement Test Code</name>
-    <instructions>
-      Implement the test following established patterns:
-      
-      CRITICAL: Never write a test file with a single write_to_file call.
-      Always implement tests in parts:
-      
-      1. Start with the basic test structure (suite, setup, teardown)
-      2. Add individual test cases one by one
-      3. Implement helper functions separately
-      4. Add event listeners and validation logic incrementally
-      
-      Follow these implementation guidelines:
-      - Use suite() and test() blocks following Mocha TDD style
-      - Always use the global api object for extension interactions
-      - Implement proper async/await patterns with waitFor utility
-      - Use waitUntilCompleted and waitUntilAborted helpers for task monitoring
-      - Listen to and validate appropriate events (message, taskCompleted, etc.)
-      - Test both positive flows and error scenarios
-      - Validate message content using proper type assertions
-      - Create reusable test utilities when patterns emerge
-      - Use meaningful test descriptions that explain the scenario
-      - Always clean up tasks with cancelCurrentTask or clearCurrentTask
-      - Ensure tests are independent and can run in any order
-    </instructions>
-  </step>
-
-  <step number="7">
-    <name>Run and Validate Tests</name>
-    <instructions>
-      Execute the tests to ensure they work correctly:
-      
-      ALWAYS use the correct working directory and commands:
-      - Working directory: apps/vscode-e2e
-      - Test command: npm run test:run
-      - For specific tests: TEST_FILE="filename.test" npm run test:run
-      - Example: cd apps/vscode-e2e && TEST_FILE="apply-diff.test" npm run test:run
-      
-      Test execution process:
-      1. Run the specific test file first
-      2. Check for any failures or errors
-      3. Analyze test output and logs
-      4. Debug any issues found
-      5. Re-run tests after fixes
-      
-      If tests fail:
-      - Add console.log statements to track execution flow
-      - Log important events like task IDs, file paths, and AI responses
-      - Check test output carefully for error messages and stack traces
-      - Verify file creation in correct workspace directories
-      - Ensure proper event handling and timeouts
-    </instructions>
-  </step>
-
-  <step number="8">
-    <name>Document and Complete</name>
-    <instructions>
-      Finalize the test implementation:
-      
-      1. Add comprehensive comments explaining complex test logic
-      2. Document any new test utilities or patterns created
-      3. Ensure test descriptions clearly explain what is being tested
-      4. Verify all cleanup procedures are in place
-      5. Confirm tests can run independently and in any order
-      
-      Provide the user with:
-      - Summary of tests created or fixed
-      - Instructions for running the tests
-      - Any new patterns or utilities that can be reused
-      - Recommendations for future test improvements
-    </instructions>
-  </step>
-</workflow>
\ No newline at end of file
diff --git a/.roo/rules-integration-tester/2_test_patterns.xml b/.roo/rules-integration-tester/2_test_patterns.xml
deleted file mode 100644
index 62bef1631..000000000
--- a/.roo/rules-integration-tester/2_test_patterns.xml
+++ /dev/null
@@ -1,303 +0,0 @@
-<test_patterns>
-  <mocha_tdd_structure>
-    <description>Standard Mocha TDD structure for integration tests</description>
-    <pattern>
-      <name>Basic Test Suite Structure</name>
-      <example>
-        ```typescript
-        import { suite, test, suiteSetup, suiteTeardown } from 'mocha';
-        import * as assert from 'assert';
-        import * as vscode from 'vscode';
-        import { waitFor, waitUntilCompleted, waitUntilAborted } from '../utils/testUtils';
-
-        suite('Feature Name Tests', () => {
-          let testWorkspaceDir: string;
-          let testFiles: { [key: string]: string } = {};
-
-          suiteSetup(async () => {
-            // Setup test workspace and files
-            testWorkspaceDir = vscode.workspace.workspaceFolders![0].uri.fsPath;
-            // Create test files in workspace
-          });
-
-          suiteTeardown(async () => {
-            // Cleanup test files and tasks
-            await api.cancelCurrentTask();
-          });
-
-          test('should perform specific functionality', async () => {
-            // Test implementation
-          });
-        });
-        ```
-      </example>
-    </pattern>
-
-    <pattern>
-      <name>Event Listening Pattern</name>
-      <example>
-        ```typescript
-        test('should handle task completion events', async () => {
-          const events: any[] = [];
-          
-          const messageListener = (message: any) => {
-            events.push({ type: 'message', data: message });
-          };
-          
-          const taskCompletedListener = (result: any) => {
-            events.push({ type: 'taskCompleted', data: result });
-          };
-
-          api.onDidReceiveMessage(messageListener);
-          api.onTaskCompleted(taskCompletedListener);
-
-          try {
-            // Perform test actions
-            await api.startTask('test prompt');
-            await waitUntilCompleted();
-            
-            // Validate events
-            assert(events.some(e => e.type === 'taskCompleted'));
-          } finally {
-            // Cleanup listeners
-            api.onDidReceiveMessage(() => {});
-            api.onTaskCompleted(() => {});
-          }
-        });
-        ```
-      </example>
-    </pattern>
-
-    <pattern>
-      <name>File Creation Test Pattern</name>
-      <example>
-        ```typescript
-        test('should create files in workspace', async () => {
-          const fileName = 'test-file.txt';
-          const expectedContent = 'test content';
-          
-          await api.startTask(`Create a file named ${fileName} with content: ${expectedContent}`);
-          await waitUntilCompleted();
-          
-          // Check multiple possible locations
-          const possiblePaths = [
-            path.join(testWorkspaceDir, fileName),
-            path.join(process.cwd(), fileName),
-            // Add other possible locations
-          ];
-          
-          let fileFound = false;
-          let actualContent = '';
-          
-          for (const filePath of possiblePaths) {
-            if (fs.existsSync(filePath)) {
-              actualContent = fs.readFileSync(filePath, 'utf8');
-              fileFound = true;
-              break;
-            }
-          }
-          
-          assert(fileFound, `File ${fileName} not found in any expected location`);
-          assert.strictEqual(actualContent.trim(), expectedContent);
-        });
-        ```
-      </example>
-    </pattern>
-  </mocha_tdd_structure>
-
-  <api_interaction_patterns>
-    <pattern>
-      <name>Basic Task Execution</name>
-      <example>
-        ```typescript
-        // Start a task and wait for completion
-        await api.startTask('Your prompt here');
-        await waitUntilCompleted();
-        ```
-      </example>
-    </pattern>
-
-    <pattern>
-      <name>Task with Auto-Approval Settings</name>
-      <example>
-        ```typescript
-        // Enable auto-approval for specific actions
-        await api.updateSettings({
-          alwaysAllowWrite: true,
-          alwaysAllowExecute: true
-        });
-        
-        await api.startTask('Create and execute a script');
-        await waitUntilCompleted();
-        ```
-      </example>
-    </pattern>
-
-    <pattern>
-      <name>Message Validation</name>
-      <example>
-        ```typescript
-        const messages: any[] = [];
-        api.onDidReceiveMessage((message) => {
-          messages.push(message);
-        });
-
-        await api.startTask('test prompt');
-        await waitUntilCompleted();
-
-        // Validate specific message types
-        const toolMessages = messages.filter(m => 
-          m.type === 'say' && m.say === 'api_req_started'
-        );
-        assert(toolMessages.length > 0, 'Expected tool execution messages');
-        ```
-      </example>
-    </pattern>
-  </api_interaction_patterns>
-
-  <error_handling_patterns>
-    <pattern>
-      <name>Task Abortion Handling</name>
-      <example>
-        ```typescript
-        test('should handle task abortion', async () => {
-          await api.startTask('long running task');
-          
-          // Abort after short delay
-          setTimeout(() => api.abortTask(), 1000);
-          
-          await waitUntilAborted();
-          
-          // Verify task was properly aborted
-          const status = await api.getTaskStatus();
-          assert.strictEqual(status, 'aborted');
-        });
-        ```
-      </example>
-    </pattern>
-
-    <pattern>
-      <name>Error Message Validation</name>
-      <example>
-        ```typescript
-        test('should handle invalid input gracefully', async () => {
-          const errorMessages: any[] = [];
-          
-          api.onDidReceiveMessage((message) => {
-            if (message.type === 'error' || message.text?.includes('error')) {
-              errorMessages.push(message);
-            }
-          });
-
-          await api.startTask('invalid prompt that should fail');
-          await waitFor(() => errorMessages.length > 0, 5000);
-          
-          assert(errorMessages.length > 0, 'Expected error messages');
-        });
-        ```
-      </example>
-    </pattern>
-  </error_handling_patterns>
-
-  <utility_patterns>
-    <pattern>
-      <name>File Location Helper</name>
-      <example>
-        ```typescript
-        function findFileInWorkspace(fileName: string, workspaceDir: string): string | null {
-          const possiblePaths = [
-            path.join(workspaceDir, fileName),
-            path.join(process.cwd(), fileName),
-            path.join(os.tmpdir(), fileName),
-            // Add other common locations
-          ];
-          
-          for (const filePath of possiblePaths) {
-            if (fs.existsSync(filePath)) {
-              return filePath;
-            }
-          }
-          
-          return null;
-        }
-        ```
-      </example>
-    </pattern>
-
-    <pattern>
-      <name>Event Collection Helper</name>
-      <example>
-        ```typescript
-        class EventCollector {
-          private events: any[] = [];
-          
-          constructor(private api: any) {
-            this.setupListeners();
-          }
-          
-          private setupListeners() {
-            this.api.onDidReceiveMessage((message: any) => {
-              this.events.push({ type: 'message', timestamp: Date.now(), data: message });
-            });
-            
-            this.api.onTaskCompleted((result: any) => {
-              this.events.push({ type: 'taskCompleted', timestamp: Date.now(), data: result });
-            });
-          }
-          
-          getEvents(type?: string) {
-            return type ? this.events.filter(e => e.type === type) : this.events;
-          }
-          
-          clear() {
-            this.events = [];
-          }
-        }
-        ```
-      </example>
-    </pattern>
-  </utility_patterns>
-
-  <debugging_patterns>
-    <pattern>
-      <name>Comprehensive Logging</name>
-      <example>
-        ```typescript
-        test('should log execution flow for debugging', async () => {
-          console.log('Starting test execution');
-          
-          const events: any[] = [];
-          api.onDidReceiveMessage((message) => {
-            console.log('Received message:', JSON.stringify(message, null, 2));
-            events.push(message);
-          });
-
-          console.log('Starting task with prompt');
-          await api.startTask('test prompt');
-          
-          console.log('Waiting for task completion');
-          await waitUntilCompleted();
-          
-          console.log('Task completed, events received:', events.length);
-          console.log('Final workspace state:', fs.readdirSync(testWorkspaceDir));
-        });
-        ```
-      </example>
-    </pattern>
-
-    <pattern>
-      <name>State Validation</name>
-      <example>
-        ```typescript
-        function validateTestState(description: string) {
-          console.log(`=== ${description} ===`);
-          console.log('Workspace files:', fs.readdirSync(testWorkspaceDir));
-          console.log('Current working directory:', process.cwd());
-          console.log('Task status:', api.getTaskStatus?.() || 'unknown');
-          console.log('========================');
-        }
-        ```
-      </example>
-    </pattern>
-  </debugging_patterns>
-</test_patterns>
\ No newline at end of file
diff --git a/.roo/rules-integration-tester/3_best_practices.xml b/.roo/rules-integration-tester/3_best_practices.xml
deleted file mode 100644
index e495ea5f0..000000000
--- a/.roo/rules-integration-tester/3_best_practices.xml
+++ /dev/null
@@ -1,104 +0,0 @@
-<best_practices>
-  <test_structure>
-    - Always use suite() and test() blocks following Mocha TDD style
-    - Use descriptive test names that explain the scenario being tested
-    - Implement proper setup and teardown in suiteSetup() and suiteTeardown()
-    - Create test files in the VSCode workspace directory during suiteSetup()
-    - Store file paths in a test-scoped object for easy reference across tests
-    - Ensure tests are independent and can run in any order
-    - Clean up all test files and tasks in suiteTeardown() to avoid test pollution
-  </test_structure>
-
-  <api_interactions>
-    - Always use the global api object for extension interactions
-    - Implement proper async/await patterns with the waitFor utility
-    - Use waitUntilCompleted and waitUntilAborted helpers for task monitoring
-    - Set appropriate auto-approval settings (alwaysAllowWrite, alwaysAllowExecute) for the functionality being tested
-    - Listen to and validate appropriate events (message, taskCompleted, taskAborted, etc.)
-    - Always clean up tasks with cancelCurrentTask or clearCurrentTask after tests
-    - Use meaningful timeouts that account for actual task execution time
-  </api_interactions>
-
-  <file_system_handling>
-    - Be aware that files may be created in the workspace directory (/tmp/roo-test-workspace-*) rather than expected locations
-    - Always check multiple possible file locations when verifying file creation
-    - Use flexible file location checking that searches workspace directories
-    - Verify files exist after creation to catch setup issues early
-    - Account for the fact that the workspace directory is created by runTest.ts
-    - The AI may use internal tools instead of the documented tools - verify outcomes rather than methods
-  </file_system_handling>
-
-  <event_handling>
-    - Add multiple event listeners (taskStarted, taskCompleted, taskAborted) for better debugging
-    - Don't rely on parsing AI messages to detect tool usage - the AI's message format may vary
-    - Use terminal shell execution events (onDidStartTerminalShellExecution, onDidEndTerminalShellExecution) for command tracking
-    - Tool executions are reported via api_req_started messages with type="say" and say="api_req_started"
-    - Focus on testing outcomes (files created, commands executed) rather than message parsing
-    - There is no "tool_result" message type - tool results appear in "completion_result" or "text" messages
-  </event_handling>
-
-  <error_scenarios>
-    - Test both positive flows and error scenarios
-    - Validate message content using proper type assertions
-    - Implement proper error handling and edge cases
-    - Use try-catch blocks around critical test operations
-    - Log important events like task IDs, file paths, and AI responses for debugging
-    - Check test output carefully for error messages and stack traces
-  </error_scenarios>
-
-  <test_reliability>
-    - Remove unnecessary waits for specific tool executions - wait for task completion instead
-    - Simplify message handlers to only capture essential error information
-    - Use the simplest possible test structure that verifies the outcome
-    - Avoid complex message parsing logic that depends on AI behavior
-    - Terminal events are more reliable than message parsing for command execution verification
-    - Keep prompts simple and direct - complex instructions may confuse the AI
-  </test_reliability>
-
-  <debugging_and_troubleshooting>
-    - Add console.log statements to track test execution flow
-    - Log important events like task IDs, file paths, and AI responses
-    - Use codebase_search first to find similar test patterns before writing new tests
-    - Create helper functions for common file location checks
-    - Use descriptive variable names for file paths and content
-    - Always log the expected vs actual locations when tests fail
-    - Add comprehensive comments explaining complex test logic
-  </debugging_and_troubleshooting>
-
-  <test_utilities>
-    - Create reusable test utilities when patterns emerge
-    - Implement helper functions for common operations like file finding
-    - Use event collection utilities for consistent event handling
-    - Create assertion helpers for common validation patterns
-    - Document any new test utilities or patterns created
-    - Share common utilities across test files to reduce duplication
-  </test_utilities>
-
-  <ai_interaction_considerations>
-    - Keep prompts simple and direct - complex instructions may lead to unexpected behavior
-    - Allow for variations in how the AI accomplishes tasks
-    - The AI may not always use the exact tool you specify in the prompt
-    - Be prepared to adapt tests based on actual AI behavior rather than expected behavior
-    - The AI may interpret instructions creatively - test results rather than implementation details
-    - The AI will not see the files in the workspace directory, you must tell it to assume they exist and proceed
-  </ai_interaction_considerations>
-
-  <test_execution>
-    - ALWAYS use the correct working directory: apps/vscode-e2e
-    - The test command is: npm run test:run
-    - To run specific tests use environment variable: TEST_FILE="filename.test" npm run test:run
-    - Example: cd apps/vscode-e2e && TEST_FILE="apply-diff.test" npm run test:run
-    - Never use npm test directly as it doesn't exist
-    - Always check available scripts with npm run if unsure
-    - Run tests incrementally during development to catch issues early
-  </test_execution>
-
-  <code_organization>
-    - Never write a test file with a single write_to_file tool call
-    - Always implement tests in parts: structure first, then individual test cases
-    - Group related tests in the same suite
-    - Use consistent naming conventions for test files and functions
-    - Separate test utilities into their own files when they become substantial
-    - Follow the existing project structure and conventions
-  </code_organization>
-</best_practices>
\ No newline at end of file
diff --git a/.roo/rules-integration-tester/4_common_mistakes.xml b/.roo/rules-integration-tester/4_common_mistakes.xml
deleted file mode 100644
index 88a747364..000000000
--- a/.roo/rules-integration-tester/4_common_mistakes.xml
+++ /dev/null
@@ -1,109 +0,0 @@
-<common_mistakes_to_avoid>
-  <test_structure_mistakes>
-    - Writing a test file with a single write_to_file tool call instead of implementing in parts
-    - Not using proper Mocha TDD structure with suite() and test() blocks
-    - Forgetting to implement suiteSetup() and suiteTeardown() for proper cleanup
-    - Creating tests that depend on each other or specific execution order
-    - Not cleaning up tasks and files after test completion
-    - Using describe/it blocks instead of the required suite/test blocks
-  </test_structure_mistakes>
-
-  <api_interaction_mistakes>
-    - Not using the global api object for extension interactions
-    - Forgetting to set auto-approval settings (alwaysAllowWrite, alwaysAllowExecute) when testing functionality that requires user approval
-    - Not implementing proper async/await patterns with waitFor utilities
-    - Using incorrect timeout values that are too short for actual task execution
-    - Not properly cleaning up tasks with cancelCurrentTask or clearCurrentTask
-    - Assuming the AI will use specific tools instead of testing outcomes
-  </api_interaction_mistakes>
-
-  <file_system_mistakes>
-    - Assuming files will be created in the expected location without checking multiple paths
-    - Not accounting for the workspace directory being created by runTest.ts
-    - Creating test files in temporary directories instead of the VSCode workspace directory
-    - Not verifying files exist after creation during setup
-    - Forgetting that the AI may not see files in the workspace directory
-    - Not using flexible file location checking that searches workspace directories
-  </file_system_mistakes>
-
-  <event_handling_mistakes>
-    - Relying on parsing AI messages to detect tool usage instead of using proper event listeners
-    - Expecting tool results in "tool_result" message type (which doesn't exist)
-    - Not listening to terminal shell execution events for command tracking
-    - Depending on specific message formats that may vary
-    - Not implementing proper event cleanup after tests
-    - Parsing complex AI conversation messages instead of focusing on outcomes
-  </event_handling_mistakes>
-
-  <test_execution_mistakes>
-    - Using npm test instead of npm run test:run
-    - Not using the correct working directory (apps/vscode-e2e)
-    - Running tests from the wrong directory
-    - Not checking available scripts with npm run when unsure
-    - Forgetting to use TEST_FILE environment variable for specific tests
-    - Not running tests incrementally during development
-  </test_execution_mistakes>
-
-  <debugging_mistakes>
-    - Not adding sufficient logging to track test execution flow
-    - Not logging important events like task IDs, file paths, and AI responses
-    - Not using codebase_search to find similar test patterns before writing new tests
-    - Not checking test output carefully for error messages and stack traces
-    - Not validating test state at critical points
-    - Assuming test failures are due to code issues without checking test logic
-  </debugging_mistakes>
-
-  <ai_interaction_mistakes>
-    - Using complex instructions that may confuse the AI
-    - Expecting the AI to use exact tools specified in prompts
-    - Not allowing for variations in how the AI accomplishes tasks
-    - Testing implementation details instead of outcomes
-    - Not adapting tests based on actual AI behavior
-    - Forgetting to tell the AI to assume files exist in the workspace directory
-  </ai_interaction_mistakes>
-
-  <reliability_mistakes>
-    - Adding unnecessary waits for specific tool executions
-    - Using complex message parsing logic that depends on AI behavior
-    - Not using the simplest possible test structure
-    - Depending on specific AI message formats
-    - Not using terminal events for reliable command execution verification
-    - Making tests too brittle by depending on exact AI responses
-  </reliability_mistakes>
-
-  <workspace_mistakes>
-    - Not understanding that files may be created in /tmp/roo-test-workspace-* directories
-    - Assuming the AI can see files in the workspace directory
-    - Not checking multiple possible file locations when verifying creation
-    - Creating files outside the VSCode workspace during tests
-    - Not properly setting up the test workspace in suiteSetup()
-    - Forgetting to clean up workspace files in suiteTeardown()
-  </workspace_mistakes>
-
-  <message_handling_mistakes>
-    - Expecting specific message types for tool execution results
-    - Not understanding that ClineMessage types have specific values
-    - Trying to parse tool execution from AI conversation messages
-    - Not checking packages/types/src/message.ts for valid message types
-    - Depending on message parsing instead of outcome verification
-    - Not using api_req_started messages to verify tool execution
-  </message_handling_mistakes>
-
-  <timeout_and_timing_mistakes>
-    - Using timeouts that are too short for actual task execution
-    - Not accounting for AI processing time in test timeouts
-    - Waiting for specific tool executions instead of task completion
-    - Not implementing proper retry logic for flaky operations
-    - Using fixed delays instead of condition-based waiting
-    - Not considering that some operations may take longer in CI environments
-  </timeout_and_timing_mistakes>
-
-  <test_data_mistakes>
-    - Not creating test files in the correct workspace directory
-    - Using hardcoded paths that don't work across different environments
-    - Not storing file paths in test-scoped objects for easy reference
-    - Creating test data that conflicts with other tests
-    - Not cleaning up test data properly after tests complete
-    - Using test data that's too complex for the AI to handle reliably
-  </test_data_mistakes>
-</common_mistakes_to_avoid>
\ No newline at end of file
diff --git a/.roo/rules-integration-tester/5_test_environment.xml b/.roo/rules-integration-tester/5_test_environment.xml
deleted file mode 100644
index 8e872b1df..000000000
--- a/.roo/rules-integration-tester/5_test_environment.xml
+++ /dev/null
@@ -1,209 +0,0 @@
-<test_environment_and_tools>
-  <test_framework>
-    <description>VSCode E2E testing framework using Mocha and VSCode Test</description>
-    <key_components>
-      - Mocha TDD framework for test structure
-      - VSCode Test framework for extension testing
-      - Custom test utilities and helpers
-      - Event-driven testing patterns
-      - Workspace-based test execution
-    </key_components>
-  </test_framework>
-
-  <directory_structure>
-    <test_files_location>apps/vscode-e2e/src/suite/</test_files_location>
-    <test_utilities>apps/vscode-e2e/src/utils/</test_utilities>
-    <test_runner>apps/vscode-e2e/src/runTest.ts</test_runner>
-    <package_config>apps/vscode-e2e/package.json</package_config>
-    <type_definitions>packages/types/</type_definitions>
-  </directory_structure>
-
-  <test_execution_commands>
-    <working_directory>apps/vscode-e2e</working_directory>
-    <commands>
-      <run_all_tests>npm run test:run</run_all_tests>
-      <run_specific_test>TEST_FILE="filename.test" npm run test:run</run_specific_test>
-      <example>cd apps/vscode-e2e && TEST_FILE="apply-diff.test" npm run test:run</example>
-      <check_scripts>npm run</check_scripts>
-    </commands>
-    <important_notes>
-      - Never use npm test directly as it doesn't exist
-      - Always use the correct working directory
-      - Use TEST_FILE environment variable for specific tests
-      - Check available scripts with npm run if unsure
-    </important_notes>
-  </test_execution_commands>
-
-  <api_object>
-    <description>Global api object for extension interactions</description>
-    <key_methods>
-      <task_management>
-        - api.startTask(prompt: string): Start a new task
-        - api.cancelCurrentTask(): Cancel the current task
-        - api.clearCurrentTask(): Clear the current task
-        - api.abortTask(): Abort the current task
-        - api.getTaskStatus(): Get current task status
-      </task_management>
-      <event_listeners>
-        - api.onDidReceiveMessage(callback): Listen to messages
-        - api.onTaskCompleted(callback): Listen to task completion
-        - api.onTaskAborted(callback): Listen to task abortion
-        - api.onTaskStarted(callback): Listen to task start
-        - api.onDidStartTerminalShellExecution(callback): Terminal start events
-        - api.onDidEndTerminalShellExecution(callback): Terminal end events
-      </event_listeners>
-      <settings>
-        - api.updateSettings(settings): Update extension settings
-        - api.getSettings(): Get current settings
-      </settings>
-    </key_methods>
-  </api_object>
-
-  <test_utilities>
-    <wait_functions>
-      <waitFor>
-        <description>Wait for a condition to be true</description>
-        <usage>await waitFor(() => condition, timeout)</usage>
-        <example>await waitFor(() => fs.existsSync(filePath), 5000)</example>
-      </waitFor>
-      <waitUntilCompleted>
-        <description>Wait until current task is completed</description>
-        <usage>await waitUntilCompleted()</usage>
-        <timeout>Default timeout for task completion</timeout>
-      </waitUntilCompleted>
-      <waitUntilAborted>
-        <description>Wait until current task is aborted</description>
-        <usage>await waitUntilAborted()</usage>
-        <timeout>Default timeout for task abortion</timeout>
-      </waitUntilAborted>
-    </wait_functions>
-    
-    <helper_patterns>
-      <file_location_helper>
-        <description>Helper to find files in multiple possible locations</description>
-        <usage>Use when files might be created in different workspace directories</usage>
-      </file_location_helper>
-      <event_collector>
-        <description>Utility to collect and analyze events during test execution</description>
-        <usage>Use for comprehensive event tracking and validation</usage>
-      </event_collector>
-      <assertion_helpers>
-        <description>Custom assertion functions for common test patterns</description>
-        <usage>Use for consistent validation across tests</usage>
-      </assertion_helpers>
-    </helper_patterns>
-  </test_utilities>
-
-  <workspace_management>
-    <workspace_creation>
-      <description>Test workspaces are created by runTest.ts</description>
-      <location>/tmp/roo-test-workspace-*</location>
-      <access>vscode.workspace.workspaceFolders![0].uri.fsPath</access>
-    </workspace_creation>
-    
-    <file_creation_strategy>
-      <setup_phase>Create all test files in suiteSetup() before any tests run</setup_phase>
-      <location>Always create files in the VSCode workspace directory</location>
-      <verification>Verify files exist after creation to catch setup issues early</verification>
-      <cleanup>Clean up all test files in suiteTeardown() to avoid test pollution</cleanup>
-      <storage>Store file paths in a test-scoped object for easy reference</storage>
-    </file_creation_strategy>
-
-    <ai_visibility>
-      <important_note>The AI will not see the files in the workspace directory</important_note>
-      <solution>Tell the AI to assume files exist and proceed as if they do</solution>
-      <verification>Always verify outcomes rather than relying on AI file visibility</verification>
-    </ai_visibility>
-  </workspace_management>
-
-  <message_types>
-    <description>Understanding message types for proper event handling</description>
-    <reference>Check packages/types/src/message.ts for valid message types</reference>
-    
-    <key_message_types>
-      <api_req_started>
-        <type>say</type>
-        <say>api_req_started</say>
-        <description>Indicates tool execution started</description>
-        <text_content>JSON with tool name and execution details</text_content>
-        <usage>Most reliable way to verify tool execution</usage>
-      </api_req_started>
-      
-      <completion_result>
-        <description>Contains tool execution results</description>
-        <usage>Tool results appear here, not in "tool_result" type</usage>
-      </completion_result>
-      
-      <text_messages>
-        <description>General AI conversation messages</description>
-        <caution>Format may vary, don't rely on parsing these for tool detection</caution>
-      </text_messages>
-    </key_message_types>
-  </message_types>
-
-  <auto_approval_settings>
-    <description>Settings to enable automatic approval of AI actions</description>
-    <critical_settings>
-      <alwaysAllowWrite>Enable for file creation/modification tests</alwaysAllowWrite>
-      <alwaysAllowExecute>Enable for command execution tests</alwaysAllowExecute>
-      <alwaysAllowBrowser>Enable for browser-related tests</alwaysAllowBrowser>
-    </critical_settings>
-    <usage>
-      ```typescript
-      await api.updateSettings({
-        alwaysAllowWrite: true,
-        alwaysAllowExecute: true
-      });
-      ```
-    </usage>
-    <importance>Without proper auto-approval settings, the AI won't be able to perform actions without user approval</importance>
-  </auto_approval_settings>
-
-  <debugging_tools>
-    <console_logging>
-      <description>Use console.log for tracking test execution flow</description>
-      <best_practices>
-        - Log test phase transitions
-        - Log important events and data
-        - Log file paths and workspace state
-        - Log expected vs actual outcomes
-      </best_practices>
-    </console_logging>
-    
-    <state_validation>
-      <description>Helper functions to validate test state at critical points</description>
-      <includes>
-        - Workspace file listing
-        - Current working directory
-        - Task status
-        - Event counts
-      </includes>
-    </state_validation>
-    
-    <error_analysis>
-      <description>Tools for analyzing test failures</description>
-      <techniques>
-        - Stack trace analysis
-        - Event timeline reconstruction
-        - File system state comparison
-        - Message flow analysis
-      </techniques>
-    </error_analysis>
-  </debugging_tools>
-
-  <performance_considerations>
-    <timeouts>
-      <description>Appropriate timeout values for different operations</description>
-      <task_completion>Use generous timeouts for task completion (30+ seconds)</task_completion>
-      <file_operations>Shorter timeouts for file system operations (5-10 seconds)</file_operations>
-      <event_waiting>Medium timeouts for event waiting (10-15 seconds)</event_waiting>
-    </timeouts>
-    
-    <resource_management>
-      <description>Proper cleanup to avoid resource leaks</description>
-      <event_listeners>Always clean up event listeners after tests</event_listeners>
-      <tasks>Cancel or clear tasks in teardown</tasks>
-      <files>Remove test files to avoid disk space issues</files>
-    </resource_management>
-  </performance_considerations>
-</test_environment_and_tools>
\ No newline at end of file
diff --git a/.roo/rules-issue-fixer/1_Workflow.xml b/.roo/rules-issue-fixer/1_Workflow.xml
deleted file mode 100644
index 91682de65..000000000
--- a/.roo/rules-issue-fixer/1_Workflow.xml
+++ /dev/null
@@ -1,560 +0,0 @@
-<workflow>
-  <step number="1">
-    <name>Retrieve Issue Context</name>
-    <instructions>
-      The user should provide a full GitHub issue URL (e.g., "https://github.com/owner/repo/issues/123") for implementation.
-      
-      Parse the URL to extract:
-      - Owner (organization or username)
-      - Repository name
-      - Issue number
-      
-      For example, from https://github.com/RooCodeInc/Roo-Code/issues/123:
-      - Owner: RooCodeInc
-      - Repo: Roo-Code
-      - Issue: 123
-      
-      Then retrieve the issue:
-      
-      <execute_command>
-      <command>gh issue view [issue-number] --repo [owner]/[repo] --json number,title,body,state,labels,assignees,milestone,createdAt,updatedAt,closedAt,author</command>
-      </execute_command>
-      
-      If the command fails with an authentication error (e.g., "gh: Not authenticated" or "HTTP 401"), ask the user to authenticate:
-      <ask_followup_question>
-      <question>GitHub CLI is not authenticated. Please run 'gh auth login' in your terminal to authenticate, then let me know when you're ready to continue.</question>
-      <follow_up>
-      <suggest>I've authenticated, please continue</suggest>
-      <suggest>I need help with authentication</suggest>
-      <suggest>Let's use a different approach</suggest>
-      </follow_up>
-      </ask_followup_question>
-      
-      Analyze the issue to determine:
-      1. All requirements and acceptance criteria
-      2. Technical details mentioned
-      3. Any linked issues or discussions
-      
-      Note: For PR review feedback, users should use the dedicated pr-fixer mode instead.
-    </instructions>
-  </step>
-
-  <step number="2">
-    <name>Review Issue Comments and Related Context</name>
-    <instructions>
-      Get all comments on the issue to understand:
-      - Additional context or clarifications
-      - Maintainer feedback
-      - Community suggestions
-      - Any decisions or changes to requirements
-      
-      <execute_command>
-      <command>gh issue view [issue number] --repo [owner]/[repo] --comments</command>
-      </execute_command>
-      
-      Also check for:
-      1. Related issues mentioned in the body or comments
-      2. Linked pull requests
-      3. Referenced discussions
-      
-      If related PRs are mentioned, view them:
-      <execute_command>
-      <command>gh pr view [pr-number] --repo [owner]/[repo]</command>
-      </execute_command>
-      
-      Document all requirements and constraints found.
-    </instructions>
-  </step>
-
-  <step number="3">
-    <name>Explore Codebase and Related Files</name>
-    <instructions>
-      Use codebase_search FIRST to understand the codebase structure and find ALL related files:
-      
-      For Bug Fixes:
-      - Search for the broken functionality
-      - Find error handling and logging
-      - Locate related test files
-      - Identify dependencies and imports
-      - Find similar patterns in the codebase
-      
-      For Features:
-      - Search for similar existing features
-      - Find integration points
-      - Locate configuration files
-      - Identify patterns to follow
-      - Find related components and utilities
-      
-      Example searches based on issue type:
-      - Bug: Search for error messages, function names, component names
-      - Feature: Search for similar functionality, API endpoints, UI components
-      
-      CRITICAL: Always read multiple related files together to understand:
-      - Current code patterns and conventions
-      - How similar functionality is implemented
-      - Testing patterns used in the project
-      - Import/export patterns
-      - Error handling approaches
-      - Configuration and setup patterns
-      
-      Then use other tools:
-      - list_code_definition_names to understand file structure
-      - read_file to examine specific implementations (read multiple files at once)
-      - search_files for specific patterns or error messages
-      
-      Also use GitHub CLI to check recent changes:
-      <execute_command>
-      <command>gh api repos/[owner]/[repo]/commits?path=[file-path]&per_page=10 --jq '.[].sha + " " + .[].commit.message'</command>
-      </execute_command>
-      
-      Search for related PRs:
-      <execute_command>
-      <command>gh pr list --repo [owner]/[repo] --search "[relevant search terms]" --limit 10</command>
-      </execute_command>
-      
-      Document:
-      - All files that need modification
-      - Current implementation details and patterns
-      - Code conventions to follow (naming, structure, etc.)
-      - Test file locations and patterns
-      - Related files that might be affected
-    </instructions>
-  </step>
-
-  <step number="4">
-    <name>Create Implementation Plan</name>
-    <instructions>
-      Based on the issue analysis, create a detailed implementation plan:
-      
-      For Bug Fixes:
-      1. Reproduce the bug locally (if possible)
-      2. Identify root cause
-      3. Plan the fix approach. The plan should be focused on resolving the issue with a high-quality, targeted fix, while avoiding unrelated changes.
-      4. Identify files to modify.
-      5. Plan test cases to prevent regression.
-      
-      For Feature Implementation:
-      1. Break down the feature into components
-      2. Identify all files that need changes
-      3. Plan the implementation approach
-      4. Consider edge cases and error handling
-      5. Plan test coverage
-      
-      Present the plan to the user:
-      
-      <ask_followup_question>
-      <question>I've analyzed issue #[number]: "[title]"
-
-      Here's my implementation plan to resolve the issue:
-
-      [Detailed plan with steps and affected files]
-
-      This plan focuses on providing a quality fix for the reported problem without introducing unrelated changes.
-
-      Would you like me to proceed with this implementation?</question>
-      <follow_up>
-      <suggest>Yes, proceed with the implementation</suggest>
-      <suggest>Let me review the issue first</suggest>
-      <suggest>Modify the approach for: [specific aspect]</suggest>
-      <suggest>Focus only on: [specific part]</suggest>
-      </follow_up>
-      </ask_followup_question>
-    </instructions>
-  </step>
-
-  <step number="5">
-    <name>Implement the Solution</name>
-    <instructions>
-      Implement the fix or feature following the plan:
-      
-      General Guidelines:
-      1. Follow existing code patterns and style
-      2. Add appropriate error handling
-      3. Include necessary comments
-      4. Update related documentation
-      5. Ensure backward compatibility (if applicable)
-      
-      For Bug Fixes:
-      1. Implement the planned fix, focusing on quality and precision.
-      2. The scope of the fix should be as narrow as possible to address the issue. Avoid making changes to code that is not directly related to the fix. This is not an encouragement for one-line hacks, but a guideline to prevent unintended side-effects.
-      3. Add regression tests.
-      4. Verify the fix resolves the issue.
-      5. Check for side effects.
-      
-      For Features:
-      1. Implement incrementally
-      2. Test each component as you build
-      3. Follow the acceptance criteria exactly
-      4. Add comprehensive tests
-      5. Update documentation
-      
-      Use appropriate tools:
-      - apply_diff for targeted changes
-      - write_to_file for new files
-      - search_and_replace for systematic updates
-      
-      After each significant change, run relevant tests:
-      - execute_command to run test suites
-      - Check for linting errors
-      - Verify functionality works as expected
-    </instructions>
-  </step>
-
-  <step number="6">
-    <name>Verify Acceptance Criteria</name>
-    <instructions>
-      Systematically verify all acceptance criteria from the issue:
-      
-      For Bug Fixes:
-      1. Confirm the bug no longer reproduces
-      2. Follow the exact reproduction steps
-      3. Verify expected behavior now occurs
-      4. Check no new bugs introduced
-      5. Run all related tests
-      
-      For Features:
-      1. Test each acceptance criterion
-      2. Verify all Given/When/Then scenarios
-      3. Test edge cases
-      4. Verify UI changes (if applicable)
-      5. Check performance impact
-      
-      Document verification results:
-      - [ ] Criterion 1: [result]
-      - [ ] Criterion 2: [result]
-      - [ ] All tests passing
-      - [ ] No linting errors
-      
-      If any criteria fail, return to implementation step.
-     </instructions>
-   </step>
- 
-   <step number="7">
-     <name>Check for Translation Requirements</name>
-     <instructions>
-       After implementing changes, analyze if any translations are required:
-       
-       Translation is needed if the implementation includes:
-       1. New user-facing text strings in UI components
-       2. New error messages or user notifications
-       3. Updated documentation files that need localization
-       4. New command descriptions or tooltips
-       5. Changes to announcement files or release notes
-       6. New configuration options with user-visible descriptions
-       
-       Check for these patterns:
-       - Hard-coded strings in React components (.tsx/.jsx files)
-       - New entries needed in i18n JSON files
-       - Updated markdown documentation files
-       - New VSCode command contributions
-       - Changes to user-facing configuration schemas
-       
-       If translations are required:
-       
-       <new_task>
-       <mode>translate</mode>
-       <message>Translation needed for issue #[issue-number] implementation.
- 
-       The following changes require translation into all supported languages:
- 
-       **Files with new/updated user-facing content:**
-       - [List specific files and what content needs translation]
-       - [Include context about where the strings appear]
-       - [Note any special formatting or constraints]
- 
-       **Translation scope:**
-       - [Specify if it's new strings, updated strings, or both]
-       - [List specific JSON keys that need attention]
-       - [Note any markdown files that need localization]
- 
-       **Context for translators:**
-       - [Explain the feature/fix being implemented]
-       - [Provide context about how the text is used]
-       - [Note any technical terms or constraints]
- 
-       Please ensure all translations maintain consistency with existing terminology and follow the project's localization guidelines.</message>
-       </new_task>
-       
-       Wait for the translation task to complete before proceeding to testing.
-       
-       If no translations are required, continue to the next step.
-     </instructions>
-   </step>
- 
-   <step number="8">
-     <name>Run Tests and Checks</name>
-    <instructions>
-      Run comprehensive tests to ensure quality:
-      
-      1. Run unit tests for modified files:
-         ```
-         npm test [test file paths]
-         ```
-      
-      2. Run integration tests if applicable:
-         ```
-         npm run test:integration
-         ```
-      
-      3. Check for linting errors:
-         ```
-         npm run lint
-         ```
-      
-      4. Run type checking:
-         ```
-         npm run type-check
-         ```
-      
-      5. If UI changes, test manually:
-         - Build the extension
-         - Test in VSCode
-         - Verify visual changes
-      
-      Document all test results and fix any failures.
-    </instructions>
-  </step>
-
-  <step number="9">
-    <name>Prepare Summary</name>
-    <instructions>
-      Create a comprehensive summary of the implementation:
-      
-      ## Summary of Changes
-      
-      **Issue:** #[number] - [title]
-      **Type:** [Bug Fix/Feature Implementation]
-      
-      ### What was done:
-      - [List key changes]
-      - [Files modified]
-      - [Tests added]
-      
-      ### How it addresses the issue:
-      [Explain how each requirement is met]
-      
-      ### Testing performed:
-      - [List all tests run]
-      - [Manual testing done]
-      - [Verification of acceptance criteria]
-      
-      ### Files changed:
-      - `path/to/file1.ts` - [brief description]
-      - `path/to/file2.ts` - [brief description]
-      
-      ### Potential impacts:
-      - [Any breaking changes]
-      - [Performance considerations]
-      - [Compatibility notes]
-      
-      Present to user for review:
-      
-      <ask_followup_question>
-      <question>I've completed the implementation for issue #[number]. Here's what was done:
-
-      [Insert summary]
-
-      All acceptance criteria have been met and tests are passing.
-
-      Would you like me to prepare a pull request, or would you like to review the changes first?</question>
-      <follow_up>
-      <suggest>Create a pull request with these changes</suggest>
-      <suggest>Show me the key changes in detail</suggest>
-      <suggest>Run additional tests for: [specific area]</suggest>
-      <suggest>Make additional changes to: [specific file]</suggest>
-      </follow_up>
-      </ask_followup_question>
-    </instructions>
-  </step>
-
-  <step number="10">
-    <name>Prepare for Pull Request</name>
-    <instructions>
-      If user wants to create a pull request, prepare everything needed:
-      
-      1. Create appropriate branch name:
-         - Bug fix: `fix/issue-[number]-[brief-description]`
-         - Feature: `feat/issue-[number]-[brief-description]`
-      
-      2. Ensure all changes are committed:
-         ```bash
-         git status
-         git add [modified files]
-         git commit -m "fix: [description] (#[issue-number])"
-         ```
-      
-      3. Push to a fork or branch (depending on user's access):
-         ```bash
-         git push origin [branch-name]
-         ```
-      
-      4. Prepare comprehensive PR description:
-         ```markdown
-         ## Description
-         
-         Fixes #[issue number]
-         
-         [Detailed description of what was changed and why]
-         
-         ## Changes Made
-         
-         - [Specific change 1 with file references]
-         - [Specific change 2 with technical details]
-         - [Any refactoring or cleanup done]
-         
-         ## Testing
-         
-         - [x] All existing tests pass
-         - [x] Added tests for [specific functionality]
-         - [x] Manual testing completed:
-           - [Specific manual test 1]
-           - [Specific manual test 2]
-         
-         ## Verification of Acceptance Criteria
-         
-         [For each criterion from the issue, show it's met]
-         - [x] Criterion 1: [How it's verified]
-         - [x] Criterion 2: [How it's verified]
-         
-         ## Checklist
-         
-         - [x] Code follows project style guidelines
-         - [x] Self-review completed
-         - [x] Comments added for complex logic
-         - [x] Documentation updated (if needed)
-         - [x] No breaking changes (or documented if any)
-         - [x] Accessibility checked (for UI changes)
-         
-         ## Screenshots/Demo (if applicable)
-         
-         [Add before/after screenshots for UI changes]
-         [Add terminal output for CLI changes]
-         ```
-      
-      5. Ask user for final approval:
-      
-      <ask_followup_question>
-      <question>I've prepared everything for the pull request:
-
-      **Branch:** [branch-name]
-      **Title:** [PR title]
-      **Target:** [owner]/[repo] (main branch)
-
-      Here's the PR description:
-
-      [Show prepared PR description]
-
-      Would you like me to create this pull request to [owner]/[repo]?</question>
-      <follow_up>
-      <suggest>Yes, create the pull request</suggest>
-      <suggest>Let me review the PR description first</suggest>
-      <suggest>Change the PR title to: [let me specify]</suggest>
-      <suggest>Add more details about: [specific aspect]</suggest>
-      </follow_up>
-      </ask_followup_question>
-    </instructions>
-  </step>
-
-  <step number="11">
-    <name>Create Pull Request</name>
-    <instructions>
-      Once user approves, create the pull request using GitHub CLI:
-      
-      If the user doesn't have push access to [owner]/[repo], fork the repository:
-      <execute_command>
-      <command>gh repo fork [owner]/[repo] --clone</command>
-      </execute_command>
-      
-      Create the pull request:
-      <execute_command>
-      <command>gh pr create --repo [owner]/[repo] --base main --title "[Type]: [Brief description] (#[issue-number])" --body "[Complete PR description from step 10]" --maintainer-can-modify</command>
-      </execute_command>
-      
-      The gh CLI will automatically handle the fork workflow if needed.
-      
-      After PR creation:
-      1. Capture the PR number and URL from the command output
-      2. Link the PR to the issue by commenting on the issue
-      3. Inform the user of the successful creation
-      
-      <execute_command>
-      <command>gh issue comment [original issue number] --repo [owner]/[repo] --body "PR #[new PR number] has been created to address this issue"</command>
-      </execute_command>
-      
-      Final message to user:
-      ```
-      ✅ Pull Request Created Successfully!
-      
-      PR #[number]: [title]
-      URL: [PR URL]
-      
-      The PR has been created and linked to issue #[issue number].
-      
-      Next steps:
-      1. The PR will be reviewed by maintainers
-      2. Address any feedback in the PR comments
-      3. Once approved, it will be merged
-      
-      You can track the PR status at: [PR URL]
-      ```
-    </instructions>
-  </step>
-
-  <step number="12">
-    <name>Monitor PR Checks</name>
-    <instructions>
-      After the PR is created, monitor the CI/CD checks to ensure they pass:
-      
-      <execute_command>
-      <command>gh pr checks [PR number] --repo [owner]/[repo] --watch</command>
-      </execute_command>
-      
-      This command will:
-      1. Display all CI/CD checks configured for the repository
-      2. Show the status of each check in real-time
-      3. Update automatically as checks complete
-      4. Exit when all checks have finished running
-      
-      Monitor the output and note:
-      - Which checks are running (e.g., tests, linting, build)
-      - Any checks that fail and their error messages
-      - The overall status of the PR checks
-      
-      If any checks fail:
-      1. Analyze the failure logs
-      2. Identify what needs to be fixed
-      3. Ask the user if they want you to address the failures
-      
-      <ask_followup_question>
-      <question>The PR checks have completed. Here's the status:
-
-      [Show check results - passing/failing]
-
-      [If all pass]: All checks have passed successfully! The PR is ready for review.
-
-      [If any fail]: Some checks have failed:
-      - [Failed check 1]: [Brief error description]
-      - [Failed check 2]: [Brief error description]
-
-      Would you like me to fix these issues?</question>
-      <follow_up>
-      <suggest>Yes, please fix the failing checks</suggest>
-      <suggest>Show me the detailed error logs</suggest>
-      <suggest>I'll handle the failures manually</suggest>
-      <suggest>The PR is fine as-is, these failures are expected</suggest>
-      </follow_up>
-      </ask_followup_question>
-      
-      If user wants fixes:
-      1. Create a plan to address each failure
-      2. Make necessary code changes
-      3. Commit and push the fixes
-      4. Monitor checks again to ensure they pass
-      
-      Important notes:
-      - The --watch flag will keep the command running until all checks complete
-      - This step helps ensure the PR meets all quality standards before review
-      - Early detection of CI/CD failures saves reviewer time
-    </instructions>
-  </step>
-</workflow>
\ No newline at end of file
diff --git a/.roo/rules-issue-fixer/2_best_practices.xml b/.roo/rules-issue-fixer/2_best_practices.xml
deleted file mode 100644
index dede40a92..000000000
--- a/.roo/rules-issue-fixer/2_best_practices.xml
+++ /dev/null
@@ -1,18 +0,0 @@
-<best_practices>
-  - Always read the entire issue and all comments before starting
-  - Follow the project's coding standards and patterns
-  - Focus exclusively on addressing the issue's requirements.
-  - Make minimal, high-quality changes for bug fixes. The goal is a narrow, targeted fix, not a one-line hack.
-  - Test thoroughly - both automated and manual testing
-  - Document complex logic with comments
-  - Keep commits focused and well-described
-  - Reference the issue number in commits
-  - Verify all acceptance criteria are met
-  - Consider performance and security implications
-  - Update documentation when needed
-  - Add tests for any new functionality
-  - Check for accessibility issues (for UI changes)
-  - Delegate translation tasks to translate mode when implementing user-facing changes
-  - Always check for hard-coded strings and internationalization needs
-  - Wait for translation completion before proceeding to final testing
-</best_practices>
\ No newline at end of file
diff --git a/.roo/rules-issue-fixer/3_common_patterns.xml b/.roo/rules-issue-fixer/3_common_patterns.xml
deleted file mode 100644
index 0fdffa8b6..000000000
--- a/.roo/rules-issue-fixer/3_common_patterns.xml
+++ /dev/null
@@ -1,21 +0,0 @@
-<common_patterns>
-  <bug_fix_pattern>
-    1. Reproduce the issue
-    2. Identify root cause
-    3. Implement minimal fix
-    4. Add regression test
-    5. Verify fix works
-    6. Check for side effects
-  </bug_fix_pattern>
-  
-  <feature_implementation_pattern>
-    1. Understand all requirements
-    2. Design the solution
-    3. Implement incrementally
-    4. Test each component
-    5. Integrate components
-    6. Verify acceptance criteria
-    7. Add comprehensive tests
-    8. Update documentation
-  </feature_implementation_pattern>
-</common_patterns>
\ No newline at end of file
diff --git a/.roo/rules-issue-fixer/4_github_cli_usage.xml b/.roo/rules-issue-fixer/4_github_cli_usage.xml
deleted file mode 100644
index e12fb06a5..000000000
--- a/.roo/rules-issue-fixer/4_github_cli_usage.xml
+++ /dev/null
@@ -1,221 +0,0 @@
-<github_cli_usage>
-  <overview>
-    This mode uses the GitHub CLI (gh) for all GitHub operations.
-    The mode assumes the user has gh installed and authenticated. If authentication errors occur,
-    the mode will prompt the user to authenticate.
-    
-    Users must provide full GitHub issue URLs (e.g., https://github.com/owner/repo/issues/123)
-    so the mode can extract the repository information dynamically.
-  </overview>
-  
-  <url_parsing>
-    <pattern>https://github.com/[owner]/[repo]/issues/[number]</pattern>
-    <extraction>
-      - Owner: The organization or username
-      - Repo: The repository name
-      - Number: The issue number
-    </extraction>
-  </url_parsing>
-
-  <authentication_handling>
-    <approach>Assume authenticated, handle errors gracefully</approach>
-    <when>Only check authentication if a gh command fails with auth error</when>
-    <error_patterns>
-      - "gh: Not authenticated"
-      - "HTTP 401"
-      - "HTTP 403: Resource not accessible"
-    </error_patterns>
-  </authentication_handling>
-
-  <primary_commands>
-    <command name="gh_issue_view">
-      <purpose>Retrieve the issue details at the start</purpose>
-      <when>Always use first to get the full issue content</when>
-      <syntax>gh issue view [issue-number] --repo [owner]/[repo] --json number,title,body,state,labels,assignees,milestone,createdAt,updatedAt,closedAt,author</syntax>
-      <example>
-        <execute_command>
-        <command>gh issue view 123 --repo octocat/hello-world --json number,title,body,state,labels,assignees,milestone,createdAt,updatedAt,closedAt,author</command>
-        </execute_command>
-      </example>
-    </command>
-    
-    <command name="gh_issue_comments">
-      <purpose>Get additional context and requirements from issue comments</purpose>
-      <when>Always use after viewing issue to see full discussion</when>
-      <syntax>gh issue view [issue-number] --repo [owner]/[repo] --comments</syntax>
-      <example>
-        <execute_command>
-        <command>gh issue view 123 --repo octocat/hello-world --comments</command>
-        </execute_command>
-      </example>
-    </command>
-    
-    
-    <command name="gh_repo_view_commits">
-      <purpose>Find recent changes to affected files</purpose>
-      <when>Use during codebase exploration</when>
-      <syntax>gh api repos/[owner]/[repo]/commits?path=[file-path]&per_page=10</syntax>
-      <example>
-        <execute_command>
-        <command>gh api repos/octocat/hello-world/commits?path=src/api/index.ts&per_page=10 --jq '.[].sha + " " + .[].commit.message'</command>
-        </execute_command>
-      </example>
-    </command>
-    
-    <command name="gh_search_code">
-      <purpose>Search for code patterns on GitHub</purpose>
-      <when>Use to supplement local codebase_search</when>
-      <syntax>gh search code "[search-query]" --repo [owner]/[repo]</syntax>
-      <example>
-        <execute_command>
-        <command>gh search code "function handleError" --repo octocat/hello-world --limit 10</command>
-        </execute_command>
-      </example>
-    </command>
-  </primary_commands>
-  
-  <optional_commands>
-    <command name="gh_issue_comment">
-      <purpose>Add progress updates or ask questions on issues</purpose>
-      <when>Use if clarification needed or to show progress</when>
-      <syntax>gh issue comment [issue-number] --repo [owner]/[repo] --body "[comment]"</syntax>
-      <example>
-        <execute_command>
-        <command>gh issue comment 123 --repo octocat/hello-world --body "Working on this issue. Found the root cause in the theme detection logic."</command>
-        </execute_command>
-      </example>
-    </command>
-    
-    <command name="gh_pr_list">
-      <purpose>Find related or similar PRs</purpose>
-      <when>Use to understand similar changes</when>
-      <syntax>gh pr list --repo [owner]/[repo] --search "[search-terms]"</syntax>
-      <example>
-        <execute_command>
-        <command>gh pr list --repo octocat/hello-world --search "dark theme" --limit 10</command>
-        </execute_command>
-      </example>
-    </command>
-    
-    <command name="gh_pr_diff">
-      <purpose>View the diff of a pull request</purpose>
-      <when>Use to understand changes in a PR</when>
-      <syntax>gh pr diff [pr-number] --repo [owner]/[repo]</syntax>
-      <example>
-        <execute_command>
-        <command>gh pr diff 456 --repo octocat/hello-world</command>
-        </execute_command>
-      </example>
-    </command>
-  </optional_commands>
-  
-  <pull_request_commands>
-    <command name="gh_pr_create">
-      <purpose>Create a pull request</purpose>
-      <when>Use in step 11 after user approval</when>
-      <important>
-        - Target the repository from the provided URL
-        - Use "main" as the base branch unless specified otherwise
-        - Include issue number in PR title
-        - Use --maintainer-can-modify flag
-      </important>
-      <syntax>gh pr create --repo [owner]/[repo] --base main --title "[title]" --body "[body]" --maintainer-can-modify</syntax>
-      <example>
-        <execute_command>
-        <command>gh pr create --repo octocat/hello-world --base main --title "fix: Resolve dark theme button visibility (#123)" --body "## Description
-
-Fixes #123
-
-[Full PR description]" --maintainer-can-modify</command>
-        </execute_command>
-      </example>
-      <note>
-        If working from a fork, ensure the fork is set as the remote and push the branch there first.
-        The gh CLI will automatically handle the fork workflow.
-      </note>
-    </command>
-    
-    <command name="gh_repo_fork">
-      <purpose>Fork the repository if user doesn't have push access</purpose>
-      <when>Use if user needs to work from a fork</when>
-      <syntax>gh repo fork [owner]/[repo] --clone</syntax>
-      <example>
-        <execute_command>
-        <command>gh repo fork octocat/hello-world --clone</command>
-        </execute_command>
-      </example>
-    </command>
-    
-    <command name="gh_pr_checks">
-      <purpose>Monitor CI/CD checks on a pull request</purpose>
-      <when>Use after creating PR to ensure checks pass</when>
-      <syntax>gh pr checks [pr-number] --repo [owner]/[repo] --watch</syntax>
-      <example>
-        <execute_command>
-        <command>gh pr checks 789 --repo octocat/hello-world --watch</command>
-        </execute_command>
-      </example>
-    </command>
-  </pull_request_commands>
-  
-  <workflow_helpers>
-    <command name="gh_api">
-      <purpose>Access GitHub API directly for advanced operations</purpose>
-      <when>Use when specific gh commands don't provide needed functionality</when>
-      <examples>
-        <!-- Get repository information -->
-        <execute_command>
-        <command>gh api repos/[owner]/[repo] --jq '.default_branch'</command>
-        </execute_command>
-        
-        <!-- Get file contents -->
-        <execute_command>
-        <command>gh api repos/[owner]/[repo]/contents/README.md --jq '.content' | base64 -d</command>
-        </execute_command>
-        
-        <!-- Get workflow runs -->
-        <execute_command>
-        <command>gh api repos/[owner]/[repo]/actions/runs --jq '.workflow_runs[0:5] | .[] | .id, .status, .conclusion'</command>
-        </execute_command>
-      </examples>
-    </command>
-    
-    <command name="gh_run_list">
-      <purpose>Check GitHub Actions workflow status</purpose>
-      <when>Use to monitor CI/CD pipeline</when>
-      <syntax>gh run list --repo [owner]/[repo] --limit 5</syntax>
-      <example>
-        <execute_command>
-        <command>gh run list --repo octocat/hello-world --limit 5</command>
-        </execute_command>
-      </example>
-    </command>
-  </workflow_helpers>
-  
-  <error_handling>
-    <scenario name="not_authenticated">
-      <error>gh: Not authenticated. Run 'gh auth login' to authenticate.</error>
-      <action>
-        Ask user to authenticate:
-        <ask_followup_question>
-        <question>GitHub CLI is not authenticated. Please run 'gh auth login' in your terminal to authenticate, then let me know when you're ready to continue.</question>
-        <follow_up>
-        <suggest>I've authenticated, please continue</suggest>
-        <suggest>I need help with authentication</suggest>
-        <suggest>Let's use a different approach</suggest>
-        </follow_up>
-        </ask_followup_question>
-      </action>
-    </scenario>
-    
-    <scenario name="no_permissions">
-      <error>HTTP 403: Resource not accessible by integration</error>
-      <action>
-        Check if working from a fork is needed:
-        <execute_command>
-        <command>gh repo fork [owner]/[repo] --clone</command>
-        </execute_command>
-      </action>
-    </scenario>
-  </error_handling>
-</github_cli_usage>
\ No newline at end of file
diff --git a/.roo/rules-issue-fixer/5_pull_request_workflow.xml b/.roo/rules-issue-fixer/5_pull_request_workflow.xml
deleted file mode 100644
index aaba5dea4..000000000
--- a/.roo/rules-issue-fixer/5_pull_request_workflow.xml
+++ /dev/null
@@ -1,52 +0,0 @@
-<pull_request_workflow>
-  <preparation>
-    1. Ensure all changes are committed with proper message format
-    2. Push to appropriate branch (fork or direct)
-    3. Prepare comprehensive PR description
-    4. Get user approval before creating PR
-    5. Extract owner and repo from the provided GitHub URL
-  </preparation>
-  
-  <pr_title_format>
-    - Bug fixes: "fix: [description] (#[issue-number])"
-    - Features: "feat: [description] (#[issue-number])"
-    - Follow conventional commit format
-  </pr_title_format>
-  
-  <pr_description_template>
-    Must include:
-    - Link to issue (Fixes #[number])
-    - Detailed description of changes
-    - Testing performed
-    - Verification of acceptance criteria
-    - Checklist items
-    - Screenshots/demos if applicable
-  </pr_description_template>
-  
-  <creating_pr_with_cli>
-    Use GitHub CLI to create the pull request:
-    <execute_command>
-    <command>gh pr create --repo [owner]/[repo] --base main --title "[title]" --body "[description]" --maintainer-can-modify</command>
-    </execute_command>
-    
-    If working from a fork, ensure you've forked first:
-    <execute_command>
-    <command>gh repo fork [owner]/[repo] --clone</command>
-    </execute_command>
-    
-    The gh CLI automatically handles fork workflows.
-  </creating_pr_with_cli>
-  
-  <after_creation>
-    1. Comment on original issue with PR link:
-       <execute_command>
-       <command>gh issue comment [issue-number] --repo [owner]/[repo] --body "PR #[pr-number] has been created to address this issue"</command>
-       </execute_command>
-    2. Inform user of successful creation
-    3. Provide next steps and tracking info
-    4. Monitor PR checks:
-       <execute_command>
-       <command>gh pr checks [pr-number] --repo [owner]/[repo] --watch</command>
-       </execute_command>
-  </after_creation>
-</pull_request_workflow>
\ No newline at end of file
diff --git a/.roo/rules-issue-fixer/6_testing_guidelines.xml b/.roo/rules-issue-fixer/6_testing_guidelines.xml
deleted file mode 100644
index 721a89f2b..000000000
--- a/.roo/rules-issue-fixer/6_testing_guidelines.xml
+++ /dev/null
@@ -1,10 +0,0 @@
-<testing_guidelines>
-  - Always run existing tests before making changes (baseline)
-  - Add tests for any new functionality
-  - Add regression tests for bug fixes
-  - Test edge cases and error conditions
-  - Run the full test suite before completing
-  - For UI changes, test in multiple themes
-  - Verify accessibility (keyboard navigation, screen readers)
-  - Test performance impact for large operations
-</testing_guidelines>
\ No newline at end of file
diff --git a/.roo/rules-issue-fixer/7_communication_style.xml b/.roo/rules-issue-fixer/7_communication_style.xml
deleted file mode 100644
index a2a2ada08..000000000
--- a/.roo/rules-issue-fixer/7_communication_style.xml
+++ /dev/null
@@ -1,8 +0,0 @@
-<communication_style>
-  - Be clear about what you're doing at each step
-  - Explain technical decisions and trade-offs
-  - Ask for clarification if requirements are ambiguous
-  - Provide regular progress updates for complex issues
-  - Summarize changes clearly for non-technical stakeholders
-  - Use issue numbers and links for reference
-</communication_style>
\ No newline at end of file
diff --git a/.roo/rules-issue-fixer/8_github_communication_guidelines.xml b/.roo/rules-issue-fixer/8_github_communication_guidelines.xml
deleted file mode 100644
index 627908f1f..000000000
--- a/.roo/rules-issue-fixer/8_github_communication_guidelines.xml
+++ /dev/null
@@ -1,16 +0,0 @@
-<github_communication_guidelines>
-  <issue_comments>
-    - Provide brief status updates when working on complex issues
-    - Ask specific questions if requirements are unclear
-    - Share findings when investigation reveals important context
-    - Keep progress updates factual and concise
-    - Example: "Found the root cause in the theme detection logic. Working on a fix that preserves backward compatibility."
-  </issue_comments>
-  
-  <commit_messages>
-    - Follow conventional commit format: "type: description (#issue-number)"
-    - Keep first line under 72 characters
-    - Be specific about what changed
-    - Example: "fix: resolve button visibility in dark theme (#123)"
-  </commit_messages>
-</github_communication_guidelines>
\ No newline at end of file
diff --git a/.roo/rules-issue-fixer/9_pr_template.xml b/.roo/rules-issue-fixer/9_pr_template.xml
deleted file mode 100644
index 4c35819b1..000000000
--- a/.roo/rules-issue-fixer/9_pr_template.xml
+++ /dev/null
@@ -1,205 +0,0 @@
-<pr_template_instructions>
-  <overview>
-    This file contains the official Roo Code PR template that must be used when creating pull requests.
-    All PRs must follow this exact format to ensure consistency and proper documentation.
-  </overview>
-
-  <pr_body_template>
-    <description>
-      The PR body must follow this exact Roo Code PR template with all required sections.
-      Replace placeholder content in square brackets with actual information.
-    </description>
-    <template><![CDATA[
-<!--
-Thank you for contributing to Roo Code!
-
-Before submitting your PR, please ensure:
-- It's linked to an approved GitHub Issue.
-- You've reviewed our [Contributing Guidelines](../CONTRIBUTING.md).
--->
-
-### Related GitHub Issue
-
-<!-- Every PR MUST be linked to an approved issue. -->
-
-Closes: #[ISSUE_NUMBER] <!-- Replace with the issue number, e.g., Closes: #123 -->
-
-### Roo Code Task Context (Optional)
-
-<!--
-If you used Roo Code to help create this PR, you can share public task links here.
-This helps reviewers understand your development process and provides additional context.
-Example: https://app.roocode.com/share/task-id
--->
-
-[TASK_CONTEXT]
-
-### Description
-
-<!--
-Briefly summarize the changes in this PR and how they address the linked issue.
-The issue should cover the "what" and "why"; this section should focus on:
-- The "how": key implementation details, design choices, or trade-offs made.
-- Anything specific reviewers should pay attention to in this PR.
--->
-
-[DESCRIPTION_CONTENT]
-
-### Test Procedure
-
-<!--
-Detail the steps to test your changes. This helps reviewers verify your work.
-- How did you test this specific implementation? (e.g., unit tests, manual testing steps)
-- How can reviewers reproduce your tests or verify the fix/feature?
-- Include relevant testing environment details if applicable.
--->
-
-[TEST_PROCEDURE_CONTENT]
-
-### Pre-Submission Checklist
-
-<!-- Go through this checklist before marking your PR as ready for review. -->
-
-- [x] **Issue Linked**: This PR is linked to an approved GitHub Issue (see "Related GitHub Issue" above).
-- [x] **Scope**: My changes are focused on the linked issue (one major feature/fix per PR).
-- [x] **Self-Review**: I have performed a thorough self-review of my code.
-- [x] **Testing**: New and/or updated tests have been added to cover my changes (if applicable).
-- [x] **Documentation Impact**: I have considered if my changes require documentation updates (see "Documentation Updates" section below).
-- [x] **Contribution Guidelines**: I have read and agree to the [Contributor Guidelines](/CONTRIBUTING.md).
-
-### Screenshots / Videos
-
-<!--
-For UI changes, please provide before-and-after screenshots or a short video of the *actual results*.
-This greatly helps in understanding the visual impact of your changes.
--->
-
-[SCREENSHOTS_CONTENT]
-
-### Documentation Updates
-
-<!--
-Does this PR necessitate updates to user-facing documentation?
-- [ ] No documentation updates are required.
-- [ ] Yes, documentation updates are required. (Please describe what needs to be updated or link to a PR in the docs repository).
--->
-
-[DOCUMENTATION_UPDATES_CONTENT]
-
-### Additional Notes
-
-<!-- Add any other context, questions, or information for reviewers here. -->
-
-[ADDITIONAL_NOTES_CONTENT]
-
-### Get in Touch
-
-<!--
-Please provide your Discord username for reviewers or maintainers to reach you if they have questions about your PR
--->
-
-[DISCORD_USERNAME]
-    ]]></template>
-  </pr_body_template>
-
-  <github_cli_commands>
-    <description>
-      Valid GitHub CLI commands for creating PRs with the proper template
-    </description>
-    
-    <create_pr_command>
-      <description>Create a PR using the filled template</description>
-      <command><![CDATA[
-gh pr create \
-  --repo [owner]/[repo] \
-  --base main \
-  --title "[Type]: [Brief description] (#[issue-number])" \
-  --body-file pr-body.md \
-  --maintainer-can-modify
-      ]]></command>
-      <note>The PR body should be saved to a temporary file first, then referenced with --body-file</note>
-    </create_pr_command>
-
-    <create_pr_inline>
-      <description>Alternative: Create PR with inline body (for shorter content)</description>
-      <command><![CDATA[
-gh pr create \
-  --repo [owner]/[repo] \
-  --base main \
-  --title "[Type]: [Brief description] (#[issue-number])" \
-  --body "[Complete PR body content]" \
-  --maintainer-can-modify
-      ]]></command>
-      <note>Use this only if the body content doesn't contain special characters that need escaping</note>
-    </create_pr_inline>
-
-    <fork_if_needed>
-      <description>Fork repository if user doesn't have push access</description>
-      <command><![CDATA[
-gh repo fork [owner]/[repo] --clone=false
-      ]]></command>
-      <note>The --clone=false flag prevents cloning since we're already in the repo</note>
-    </fork_if_needed>
-  </github_cli_commands>
-
-  <pr_title_format>
-    <description>PR titles should follow conventional commit format</description>
-    <formats>
-      <format type="bug_fix">fix: [brief description] (#[issue-number])</format>
-      <format type="feature">feat: [brief description] (#[issue-number])</format>
-      <format type="docs">docs: [brief description] (#[issue-number])</format>
-      <format type="refactor">refactor: [brief description] (#[issue-number])</format>
-      <format type="test">test: [brief description] (#[issue-number])</format>
-      <format type="chore">chore: [brief description] (#[issue-number])</format>
-    </formats>
-  </pr_title_format>
-
-  <placeholder_guidance>
-    <description>How to fill in the template placeholders</description>
-    <placeholders>
-      <placeholder name="ISSUE_NUMBER">
-        <description>The GitHub issue number being addressed</description>
-        <example>123</example>
-      </placeholder>
-      <placeholder name="TASK_CONTEXT">
-        <description>Optional Roo Code task links if used during development</description>
-        <example>https://app.roocode.com/share/task-abc123</example>
-        <default>_No Roo Code task context for this PR_</default>
-      </placeholder>
-      <placeholder name="DESCRIPTION_CONTENT">
-        <description>Detailed explanation of implementation approach</description>
-        <guidance>
-          - Focus on HOW you solved the problem
-          - Mention key design decisions
-          - Highlight any trade-offs made
-          - Point out areas needing special review attention
-        </guidance>
-      </placeholder>
-      <placeholder name="TEST_PROCEDURE_CONTENT">
-        <description>Steps to verify the changes work correctly</description>
-        <guidance>
-          - List specific test commands run
-          - Describe manual testing performed
-          - Include steps for reviewers to reproduce tests
-          - Mention test environment details if relevant
-        </guidance>
-      </placeholder>
-      <placeholder name="SCREENSHOTS_CONTENT">
-        <description>Visual evidence of changes for UI modifications</description>
-        <default>_No UI changes in this PR_</default>
-      </placeholder>
-      <placeholder name="DOCUMENTATION_UPDATES_CONTENT">
-        <description>Documentation impact assessment</description>
-        <default>- [x] No documentation updates are required.</default>
-      </placeholder>
-      <placeholder name="ADDITIONAL_NOTES_CONTENT">
-        <description>Any extra context for reviewers</description>
-        <default>_No additional notes_</default>
-      </placeholder>
-      <placeholder name="DISCORD_USERNAME">
-        <description>Discord username for communication</description>
-        <example>@username</example>
-      </placeholder>
-    </placeholders>
-  </placeholder_guidance>
-</pr_template_instructions>
\ No newline at end of file
diff --git a/.roo/rules-issue-investigator/1_workflow.xml b/.roo/rules-issue-investigator/1_workflow.xml
deleted file mode 100644
index 561b27512..000000000
--- a/.roo/rules-issue-investigator/1_workflow.xml
+++ /dev/null
@@ -1,98 +0,0 @@
-<workflow_instructions>
-  <mode_overview>
-    This mode investigates GitHub issues to find the probable root cause and suggest a theoretical solution. It uses a structured, iterative search process and communicates findings in a conversational tone.
-  </mode_overview>
-
-  <initialization_steps>
-    <step number="1">
-      <action>Understand the user's request</action>
-      <details>
-        The user will provide a GitHub issue URL or number. Your first step is to fetch the issue details using the `gh` CLI.
-      </details>
-      <tool_use>
-        <command>gh issue view ISSUE_URL --json title,body,labels,comments</command>
-      </tool_use>
-    </step>
-    <step number="2">
-      <action>Create an investigation plan</action>
-      <details>
-        Based on the issue details, create a todo list to track the investigation.
-      </details>
-      <tool_use><![CDATA[
-<update_todo_list>
-<todos>
-[ ] Extract keywords from the issue title and body.
-[ ] Perform initial codebase search with keywords.
-[ ] Analyze search results and form a hypothesis.
-[ ] Attempt to disprove the hypothesis.
-[ ] Formulate a theoretical solution.
-[ ] Draft a comment for the user.
-</todos>
-</update_todo_list>
-      ]]></tool_use>
-    </step>
-  </initialization_steps>
-
-  <main_workflow>
-    <phase name="investigation">
-      <description>
-        Systematically search the codebase to identify the root cause. This is an iterative process.
-      </description>
-      <steps>
-        <step>
-            <title>Extract Keywords</title>
-            <description>Identify key terms, function names, error messages, and concepts from the issue title, body, and comments.</description>
-        </step>
-        <step>
-            <title>Iterative Codebase Search</title>
-            <description>Use `codebase_search` with the extracted keywords. Start broad and then narrow down your search based on the results. Continue searching with new keywords discovered from relevant files until you have a clear understanding of the related code.</description>
-            <tool_use>
-                <command>codebase_search</command>
-            </tool_use>
-        </step>
-        <step>
-            <title>Form a Hypothesis</title>
-            <description>Based on the search results, form a hypothesis about the probable cause of the issue. Document this hypothesis.</description>
-        </step>
-        <step>
-            <title>Attempt to Disprove Hypothesis</title>
-            <description>Actively try to find evidence that contradicts your hypothesis. This might involve searching for alternative implementations, looking for configurations that change behavior, or considering edge cases. If the hypothesis is disproven, return to the search step with new insights.</description>
-        </step>
-      </steps>
-    </phase>
-
-    <phase name="solution">
-      <description>Formulate a solution and prepare to communicate it.</description>
-      <steps>
-        <step>
-            <title>Formulate Theoretical Solution</title>
-            <description>Once the hypothesis is stable, describe a potential solution. Frame it as a suggestion, using phrases like "It seems like the issue could be resolved by..." or "A possible fix would be to...".</description>
-        </step>
-        <step>
-            <title>Draft Comment</title>
-            <description>Draft a comment for the GitHub issue that explains your findings and suggested solution in a conversational, human-like tone.</description>
-        </step>
-      </steps>
-    </phase>
-
-    <phase name="user_confirmation">
-        <description>Ask the user for confirmation before posting any comments.</description>
-        <tool_use><![CDATA[
-<ask_followup_question>
-<question>I've investigated the issue and drafted a comment with my findings and a suggested solution. Would you like me to post it to the GitHub issue?</question>
-<follow_up>
-<suggest>Yes, please post the comment to the issue.</suggest>
-<suggest>Show me the draft comment first.</suggest>
-<suggest>No, do not post the comment.</suggest>
-</follow_up>
-</ask_followup_question>
-        ]]></tool_use>
-    </phase>
-  </main_workflow>
-
-  <completion_criteria>
-    <criterion>A probable cause has been identified and validated.</criterion>
-    <criterion>A theoretical solution has been proposed.</criterion>
-    <criterion>The user has decided whether to post a comment on the issue.</criterion>
-  </completion_criteria>
-</workflow_instructions>
\ No newline at end of file
diff --git a/.roo/rules-issue-investigator/2_best_practices.xml b/.roo/rules-issue-investigator/2_best_practices.xml
deleted file mode 100644
index 31ad2c226..000000000
--- a/.roo/rules-issue-investigator/2_best_practices.xml
+++ /dev/null
@@ -1,59 +0,0 @@
-<best_practices>
-  <general_principles>
-    <principle priority="high">
-      <name>Be Methodical</name>
-      <description>Follow the workflow steps precisely. Do not skip the hypothesis validation step. A rigorous process leads to more accurate conclusions.</description>
-      <rationale>Skipping steps can lead to incorrect assumptions and wasted effort. The goal is to be confident in the proposed solution.</rationale>
-    </principle>
-    <principle priority="high">
-      <name>Embrace Iteration</name>
-      <description>The investigation is not linear. Be prepared to go back to the search phase multiple times as you uncover new information. Each search should build on the last.</description>
-      <rationale>Complex issues rarely have a single, obvious cause. Iterative searching helps peel back layers and reveal the true root of the problem.</rationale>
-    </principle>
-    <principle priority="medium">
-      <name>Think like a Skeptic</name>
-      <description>Your primary goal when you have a hypothesis is to try and break it. Actively look for evidence that you are wrong. This makes your final conclusion much stronger.</description>
-      <rationale>Confirmation bias is a common pitfall. By trying to disprove your own theories, you ensure a more objective and reliable investigation.</rationale>
-    </principle>
-  </general_principles>
-
-  <code_conventions>
-    <convention category="searching">
-      <rule>Start with broad keywords from the issue, then narrow down your search using specific function names, variable names, or file paths discovered in the initial results.</rule>
-      <examples>
-        <good>Initial search: "user authentication fails". Follow-up search: "getUserById invalid token".</good>
-        <bad>Searching for a generic term like "error" without context.</bad>
-      </examples>
-    </convention>
-  </code_conventions>
-
-  <common_pitfalls>
-    <pitfall>
-      <description>Jumping to conclusions after the first search.</description>
-      <why_problematic>The first set of results might be misleading or only part of the story.</why_problematic>
-      <correct_approach>Always perform multiple rounds of searches, and always try to disprove your initial hypothesis.</correct_approach>
-    </pitfall>
-    <pitfall>
-      <description>Forgetting to use the todo list.</description>
-      <why_problematic>The todo list is essential for tracking the complex, multi-step investigation process. Without it, you can lose track of your progress and findings.</why_problematic>
-      <correct_approach>Update the todo list after each major step in the workflow.</correct_approach>
-    </pitfall>
-  </common_pitfalls>
-
-  <quality_checklist>
-    <category name="investigation">
-      <item>Have I extracted all relevant keywords from the issue?</item>
-      <item>Have I performed at least two rounds of codebase searches?</item>
-      <item>Have I genuinely tried to disprove my hypothesis?</item>
-    </category>
-    <category name="solution">
-      <item>Is the proposed solution theoretical and not stated as a definitive fact?</item>
-      <item>Is the explanation clear and easy to understand?</item>
-    </category>
-    <category name="communication">
-      <item>Does the draft comment sound conversational and human?</item>
-      <item>Have I avoided technical jargon where possible?</item>
-      <item>Is the tone helpful and not condescending?</item>
-    </category>
-  </quality_checklist>
-</best_practices>
\ No newline at end of file
diff --git a/.roo/rules-issue-investigator/3_common_patterns.xml b/.roo/rules-issue-investigator/3_common_patterns.xml
deleted file mode 100644
index 2a17e7be7..000000000
--- a/.roo/rules-issue-investigator/3_common_patterns.xml
+++ /dev/null
@@ -1,45 +0,0 @@
-<common_patterns>
-    <pattern name="bug_investigation">
-        <usage>For investigating bug reports where something is broken.</usage>
-        <template>
-            <workflow>
-                <step>1. Identify the exact error message from the issue.</step>
-                <step>2. Search for the error message in the codebase using `codebase_search`.</step>
-                <step>3. Analyze the code that throws the error to understand the context.</step>
-                <step>4. Trace the execution path backward from the error to find where the problem originates.</step>
-                <step>5. Form a hypothesis about the incorrect logic or state.</step>
-                <step>6. Try to disprove the hypothesis by checking for alternative paths or configurations.</step>
-                <step>7. Propose a code change to correct the logic.</step>
-            </workflow>
-        </template>
-    </pattern>
-
-    <pattern name="unexpected_behavior_investigation">
-        <usage>For investigating issues where the system works but not as expected.</usage>
-        <template>
-            <workflow>
-                <step>1. Identify the feature or component exhibiting the unexpected behavior.</step>
-                <step>2. Use `codebase_search` to find the main implementation files for that feature.</step>
-                <step>3. Read the relevant code to understand the intended logic.</step>
-                <step>4. Form a hypothesis about which part of the logic is producing the unexpected result.</step>
-                <step>5. Look for related code, configurations, or data that might influence the behavior in an unexpected way.</step>
-                <step>6. Try to disprove the hypothesis. For example, if you think a configuration flag is the cause, check where it's used and if it could be set differently.</step>
-                <step>7. Suggest a change to the logic or configuration to align it with the expected behavior.</step>
-            </workflow>
-        </template>
-    </pattern>
-
-    <pattern name="performance_issue_investigation">
-        <usage>For investigating issues related to slowness or high resource usage.</usage>
-        <template>
-            <workflow>
-                <step>1. Identify the specific action or process that is slow.</step>
-                <step>2. Use `codebase_search` to find the code responsible for that action.</step>
-                <step>3. Look for common performance anti-patterns: loops with expensive operations, redundant database queries, inefficient algorithms, etc.</step>
-                <step>4. Form a hypothesis about the performance bottleneck.</step>
-                <step>5. Try to disprove the hypothesis. Could another part of the system be contributing to the slowness?</step>
-                <step>6. Propose a more efficient implementation, such as caching, batching operations, or using a better algorithm.</step>
-            </workflow>
-        </template>
-    </pattern>
-</common_patterns>
\ No newline at end of file
diff --git a/.roo/rules-issue-investigator/4_tool_usage.xml b/.roo/rules-issue-investigator/4_tool_usage.xml
deleted file mode 100644
index c43c41a8c..000000000
--- a/.roo/rules-issue-investigator/4_tool_usage.xml
+++ /dev/null
@@ -1,78 +0,0 @@
-<tool_usage_guide>
-  <tool_priorities>
-    <priority level="1">
-      <tool>gh issue view</tool>
-      <when>Always use first to get the issue context.</when>
-      <why>This provides the foundational information for the entire investigation.</why>
-    </priority>
-    <priority level="2">
-      <tool>codebase_search</tool>
-      <when>For all investigation steps to find relevant code.</when>
-      <why>Semantic search is critical for finding the root cause based on concepts, not just exact keywords.</why>
-    </priority>
-    <priority level="3">
-      <tool>update_todo_list</tool>
-      <when>After major steps or when the investigation plan changes.</when>
-      <why>Maintains a clear record of the investigation's state and next steps.</why>
-    </priority>
-  </tool_priorities>
-
-  <tool_specific_guidance>
-    <tool name="execute_command (gh CLI)">
-      <best_practices>
-        <practice>Use `gh issue view [URL] --json title,body,labels,comments` to fetch initial details.</practice>
-        <practice>Use `gh issue comment [URL] --body "..."` to add comments, but only after explicit user approval.</practice>
-        <practice>Always wrap the comment body in quotes to handle special characters.</practice>
-      </best_practices>
-      <example><![CDATA[
-<execute_command>
-<command>gh issue view https://github.com/RooCodeInc/Roo-Code/issues/123 --json title,body</command>
-</execute_command>
-      ]]></example>
-    </tool>
-
-    <tool name="codebase_search">
-        <best_practices>
-            <practice>Extract multiple keywords from the issue. Combine them in your search query.</practice>
-            <practice>If initial results are too broad, add more specific terms from the results (like function or variable names) to your next query.</practice>
-            <practice>Use this tool iteratively. Don't rely on a single search.</practice>
-        </best_practices>
-        <example><![CDATA[
-<codebase_search>
-<query>user login authentication error "invalid credentials"</query>
-</codebase_search>
-        ]]></example>
-    </tool>
-
-    <tool name="ask_followup_question">
-      <best_practices>
-        <practice>Only use this tool to ask for confirmation before posting a comment.</practice>
-        <practice>The suggestions should be clear and directly related to the action of commenting.</practice>
-      </best_practices>
-      <example><![CDATA[
-<ask_followup_question>
-<question>I have analyzed the issue and drafted a comment. Would you like me to post it?</question>
-<follow_up>
-<suggest>Yes, go ahead and post the comment.</suggest>
-<suggest>Let me see the comment first before you post it.</suggest>
-<suggest>No, do not post anything. I will handle it.</suggest>
-</follow_up>
-</ask_followup_question>
-      ]]></example>
-    </tool>
-  </tool_specific_guidance>
-
-  <tool_combination_patterns>
-    <pattern name="investigate_and_report">
-      <sequence>
-        <step>execute_command (gh issue view) - Get issue details.</step>
-        <step>update_todo_list - Create an investigation plan.</step>
-        <step>codebase_search - Perform initial search.</step>
-        <step>read_file - Analyze relevant file contents.</step>
-        <step>codebase_search - Perform follow-up search to confirm/deny hypothesis.</step>
-        <step>ask_followup_question - Ask user to confirm before commenting.</step>
-        <step>execute_command (gh issue comment) - Post the comment if approved.</step>
-      </sequence>
-    </pattern>
-  </tool_combination_patterns>
-</tool_usage_guide>
\ No newline at end of file
diff --git a/.roo/rules-issue-investigator/5_examples.xml b/.roo/rules-issue-investigator/5_examples.xml
deleted file mode 100644
index dbd4ae2f2..000000000
--- a/.roo/rules-issue-investigator/5_examples.xml
+++ /dev/null
@@ -1,99 +0,0 @@
-<complete_examples>
-  <example name="investigating_a_login_bug">
-    <scenario>
-      A user has reported a bug where they are unable to log in with valid credentials, but no error message is shown.
-    </scenario>
-    
-    <user_request>
-      "Please investigate issue #456. Users are reporting that they can't log in."
-    </user_request>
-
-    <workflow>
-      <step number="1">
-        <description>Fetch issue details from GitHub.</description>
-        <tool_use><![CDATA[
-<execute_command>
-<command>gh issue view 456 --json title,body,comments</command>
-</execute_command>
-        ]]></tool_use>
-        <expected_outcome>Get the title "Login fails silently" and body "Users with valid credentials are not able to log in. The page just refreshes without any error message."</expected_outcome>
-      </step>
-
-      <step number="2">
-        <description>Create the initial investigation plan.</description>
-        <tool_use><![CDATA[
-<update_todo_list>
-<todos>
-[x] Extract keywords from the issue title and body.
-[-] Perform initial codebase search with keywords.
-[ ] Analyze search results and form a hypothesis.
-[ ] Attempt to disprove the hypothesis.
-[ ] Formulate a theoretical solution.
-[ ] Draft a comment for the user.
-</todos>
-</update_todo_list>
-        ]]></tool_use>
-      </step>
-
-      <step number="3">
-          <description>Perform initial codebase search using keywords "login", "authentication", "silent fail".</description>
-          <tool_use><![CDATA[
-<codebase_search>
-<query>user login authentication silent fail</query>
-</codebase_search>
-          ]]></tool_use>
-          <analysis>The search results point to `src/auth/login.ts` as a highly relevant file.</analysis>
-      </step>
-
-      <step number="4">
-          <description>Read the contents of the relevant file.</description>
-          <tool_use><![CDATA[
-<read_file>
-<path>src/auth/login.ts</path>
-</read_file>
-          ]]></tool_use>
-          <analysis>
-            The file contains a `try...catch` block in the `handleLogin` function. The `catch` block is empty, which explains the silent failure. This is the likely cause. Hypothesis: The login process is failing inside the try block, but the error is swallowed by the empty catch block.
-          </analysis>
-      </step>
-      
-      <step number="5">
-          <description>Attempt to disprove the hypothesis by looking for other error handling mechanisms.</description>
-          <tool_use><![CDATA[
-<codebase_search>
-<query>global error handling middleware Express</query>
-</codebase_search>
-          ]]></tool_use>
-          <analysis>No global error handling middleware seems to be in use that would override this local empty catch block. The hypothesis stands.</analysis>
-      </step>
-
-      <step number="6">
-          <description>Formulate a solution and draft a comment.</description>
-          <draft>
-"Hey, I took a look at this issue and it seems like the problem is in the `handleLogin` function in `src/auth/login.ts`. There's an empty `try...catch` block that is likely catching the login error and preventing any message from being shown to the user.
-
-A good first step to fixing this would be to add some logging to the `catch` block to see what error is actually happening. Then, we should probably implement proper error feedback to the user on the login page. This should solve the issue of the silent failure."
-          </draft>
-      </step>
-
-      <step number="7">
-        <description>Ask the user for confirmation before posting the comment.</description>
-        <tool_use><![CDATA[
-<ask_followup_question>
-<question>I've investigated the issue and drafted a comment with my findings and a suggested solution. Would you like me to post it to the GitHub issue?</question>
-<follow_up>
-<suggest>Yes, please post the comment to the issue.</suggest>
-<suggest>Show me the draft comment first.</suggest>
-<suggest>No, do not post the comment.</suggest>
-</follow_up>
-</ask_followup_question>
-        ]]></tool_use>
-      </step>
-    </workflow>
-
-    <key_takeaways>
-      <takeaway>Empty catch blocks are a strong indicator of silent failures.</takeaway>
-      <takeaway>Always try to disprove a hypothesis by looking for conflicting code patterns.</takeaway>
-    </key_takeaways>
-  </example>
-</complete_examples>
\ No newline at end of file
diff --git a/.roo/rules-issue-investigator/6_communication.xml b/.roo/rules-issue-investigator/6_communication.xml
deleted file mode 100644
index 348ecf187..000000000
--- a/.roo/rules-issue-investigator/6_communication.xml
+++ /dev/null
@@ -1,35 +0,0 @@
-<communication_guidelines>
-  <tone_and_style>
-    <principle>Be conversational and helpful, not robotic.</principle>
-    <principle>Write comments as if you are a human developer collaborating on the project.</principle>
-    <avoid>
-      <phrase>Analysis complete.</phrase>
-      <phrase>The investigation has yielded the following result.</phrase>
-    </avoid>
-    <prefer>
-      <phrase>Hey, I took a look at this and found something interesting...</phrase>
-      <phrase>I've been digging into this issue, and I think I've found a possible cause.</phrase>
-    </prefer>
-  </tone_and_style>
-
-  <comment_structure>
-      <element>Start with a friendly opening.</element>
-      <element>State your main finding or hypothesis clearly but not definitively.</element>
-      <element>Provide context, like file paths and function names.</element>
-      <element>Propose a next step or a theoretical solution.</element>
-      <element>Keep it concise and easy to read. Avoid large blocks of text.</element>
-      <element>Use markdown for code snippets or file paths only when necessary for clarity.</element>
-  </comment_structure>
-
-  <completion_messages>
-    <structure>
-      <element>What was accomplished (e.g., "Investigation complete.").</element>
-      <element>A summary of the findings and the proposed solution.</element>
-      <element>A final statement indicating that the user has been prompted on how to proceed with the comment.</element>
-    </structure>
-    <avoid>
-      <element>Ending with a question.</element>
-      <element>Offers for further assistance.</element>
-    </avoid>
-  </completion_messages>
-</communication_guidelines>
\ No newline at end of file
diff --git a/.roo/rules-issue-writer/1_workflow.xml b/.roo/rules-issue-writer/1_workflow.xml
deleted file mode 100644
index 99ef7db5d..000000000
--- a/.roo/rules-issue-writer/1_workflow.xml
+++ /dev/null
@@ -1,1161 +0,0 @@
-<workflow>
-  <initialization>
-    <step number="1">
-      <name>Initialize Issue Creation Process</name>
-      <instructions>
-        IMPORTANT: This mode assumes the first user message is already a request to create an issue.
-        The user doesn't need to say "create an issue" or "make me an issue" - their first message
-        is treated as the issue description itself.
-        
-        When the session starts, immediately:
-        1. Treat the user's first message as the issue description
-        2. Initialize the workflow by using the update_todo_list tool
-        3. Begin the issue creation process without asking what they want to do
-        
-        <update_todo_list>
-        <todos>
-        [ ] Detect current repository information
-        [ ] Determine repository structure (monorepo/standard)
-        [ ] Perform initial codebase discovery
-        [ ] Analyze user request to determine issue type
-        [ ] Gather and verify additional information
-        [ ] Determine if user wants to contribute
-        [ ] Perform issue scoping (if contributing)
-        [ ] Draft issue content
-        [ ] Review and confirm with user
-        [ ] Create GitHub issue
-        </todos>
-        </update_todo_list>
-      </instructions>
-    </step>
-  </initialization>
-
-  <step number="1">
-    <name>Detect current repository information</name>
-    <instructions>
-      CRITICAL FIRST STEP: Verify we're in a git repository and get repository information.
-      
-      1. Check if we're in a git repository:
-      <execute_command>
-      <command>git rev-parse --is-inside-work-tree 2>/dev/null || echo "not-git-repo"</command>
-      </execute_command>
-      
-      If the output is "not-git-repo", immediately stop and inform the user:
-      
-      <attempt_completion>
-      <result>
-      This mode must be run from within a GitHub repository. Please navigate to a git repository and try again.
-      </result>
-      </attempt_completion>
-      
-      2. If in a git repository, get the repository information:
-      <execute_command>
-      <command>git remote get-url origin 2>/dev/null | sed -E 's/.*[:/]([^/]+)\/([^/]+)(\.git)?$/\1\/\2/' | sed 's/\.git$//'</command>
-      </execute_command>
-      
-      Store this as REPO_FULL_NAME for use throughout the workflow.
-      
-      If no origin remote exists, stop with:
-      <attempt_completion>
-      <result>
-      No GitHub remote found. This mode requires a GitHub repository with an 'origin' remote configured.
-      </result>
-      </attempt_completion>
-      
-      Update todo after detecting repository:
-      <update_todo_list>
-      <todos>
-      [x] Detect current repository information
-      [-] Determine repository structure (monorepo/standard)
-      [ ] Perform initial codebase discovery
-      [ ] Analyze user request to determine issue type
-      [ ] Gather and verify additional information
-      [ ] Determine if user wants to contribute
-      [ ] Perform issue scoping (if contributing)
-      [ ] Draft issue content
-      [ ] Review and confirm with user
-      [ ] Create GitHub issue
-      </todos>
-      </update_todo_list>
-    </instructions>
-  </step>
-
-  <step number="2">
-    <name>Determine Repository Structure</name>
-    <instructions>
-      Check if this is a monorepo or standard repository by looking for common patterns.
-      
-      First, check for monorepo indicators:
-      1. Look for workspace configuration:
-         - package.json with "workspaces" field
-         - lerna.json
-         - pnpm-workspace.yaml
-         - rush.json
-      
-      2. Check for common monorepo directory patterns:
-      <list_files>
-      <path>.</path>
-      <recursive>false</recursive>
-      </list_files>
-      
-      Look for directories like:
-      - apps/ (application packages)
-      - packages/ (shared packages)
-      - services/ (service packages)
-      - libs/ (library packages)
-      - modules/ (module packages)
-      - src/ (main source if not using workspaces)
-      
-      If monorepo detected:
-        - Dynamically discover packages by looking for package.json files in detected directories
-        - Build a list of available packages with their paths
-      
-      Based on the user's description, try to identify which package they're referring to.
-      If unclear, ask for clarification:
-      
-      <ask_followup_question>
-      <question>I see this is a monorepo with multiple packages. Which specific package or application is your issue related to?</question>
-      <follow_up>
-      [Dynamically generated list of discovered packages]
-      <suggest>Let me describe which package: [specify]</suggest>
-      </follow_up>
-      </ask_followup_question>
-      
-      If standard repository:
-        - Skip package selection
-        - Use repository root for all searches
-      
-      Store the repository context for all future codebase searches and explorations.
-      
-      Update todo after determining context:
-      <update_todo_list>
-      <todos>
-      [x] Detect current repository information
-      [x] Determine repository structure (monorepo/standard)
-      [-] Perform initial codebase discovery
-      [ ] Analyze user request to determine issue type
-      [ ] Gather and verify additional information
-      [ ] Determine if user wants to contribute
-      [ ] Perform issue scoping (if contributing)
-      [ ] Draft issue content
-      [ ] Review and confirm with user
-      [ ] Create GitHub issue
-      </todos>
-      </update_todo_list>
-    </instructions>
-  </step>
-
-  <step number="3">
-    <name>Perform Initial Codebase Discovery</name>
-    <instructions>
-      Now that we know the repository structure, immediately search the codebase to understand
-      what the user is talking about before determining the issue type.
-      
-      DISCOVERY ACTIVITIES:
-      
-      1. Extract keywords and concepts from the user's INITIAL MESSAGE (their issue description)
-      2. Search the codebase to verify these concepts exist
-      3. Build understanding of the actual implementation
-      4. Identify relevant files, components, and code patterns
-      
-      <codebase_search>
-      <query>[Keywords from user's initial message/description]</query>
-      <path>[Repository or package path from step 2]</path>
-      </codebase_search>
-      
-      Additional searches based on initial findings:
-      - If error mentioned: search for exact error strings
-      - If feature mentioned: search for related functionality
-      - If component mentioned: search for implementation details
-      
-      <search_files>
-      <path>[repository or package path]</path>
-      <regex>[specific patterns found in initial search]</regex>
-      </search_files>
-      
-      Document findings:
-      - Components/features found that match user's description
-      - Actual implementation details discovered
-      - Related code sections identified
-      - Any discrepancies between user description and code reality
-      
-      Update todos:
-      <update_todo_list>
-      <todos>
-      [x] Detect current repository information
-      [x] Determine repository structure (monorepo/standard)
-      [x] Perform initial codebase discovery
-      [-] Analyze user request to determine issue type
-      [ ] Gather and verify additional information
-      [ ] Determine if user wants to contribute
-      [ ] Perform issue scoping (if contributing)
-      [ ] Draft issue content
-      [ ] Review and confirm with user
-      [ ] Create GitHub issue
-      </todos>
-      </update_todo_list>
-    </instructions>
-  </step>
-
-  <step number="4">
-    <name>Analyze Request to Determine Issue Type</name>
-    <instructions>
-      Using the codebase discoveries from step 2, analyze the user's request to determine
-      the appropriate issue type with informed context.
-      
-      CRITICAL GUIDANCE FOR ISSUE TYPE SELECTION:
-      For issues that affect user workflows or require behavior changes:
-      - PREFER the feature proposal template over bug report
-      - Focus on explaining WHO is affected and WHEN this happens
-      - Describe the user impact before diving into technical details
-      
-      Based on your findings, classify the issue:
-      
-      Bug indicators (verified against code):
-      - Error messages that match actual error handling in code
-      - Broken functionality in existing features found in codebase
-      - Regression from previous behavior documented in code/tests
-      - Code paths that don't work as documented
-      
-      Feature indicators (verified against code):
-      - New functionality not found in current codebase
-      - Enhancement to existing features found in code
-      - Missing capabilities compared to similar features
-      - Integration points that could be extended
-      - WORKFLOW IMPROVEMENTS: When existing behavior works but doesn't meet user needs
-      
-      IMPORTANT: Use your codebase findings to inform the question:
-      
-      <ask_followup_question>
-      <question>Based on your request about [specific feature/component found in code], what type of issue would you like to create?</question>
-      <follow_up>
-      [Order based on codebase findings and user description]
-      <suggest>Bug Report - [Specific component] is not working as expected</suggest>
-      <suggest>Feature Proposal - Add [specific capability] to [existing component]</suggest>
-      </follow_up>
-      </ask_followup_question>
-      
-      Update todos:
-      <update_todo_list>
-      <todos>
-      [x] Detect current repository information
-      [x] Determine repository structure (monorepo/standard)
-      [x] Perform initial codebase discovery
-      [x] Analyze user request to determine issue type
-      [-] Gather and verify additional information
-      [ ] Determine if user wants to contribute
-      [ ] Perform issue scoping (if contributing)
-      [ ] Draft issue content
-      [ ] Review and confirm with user
-      [ ] Create GitHub issue
-      </todos>
-      </update_todo_list>
-    </instructions>
-  </step>
-
-  <step number="5">
-    <name>Gather and Verify Additional Information</name>
-    <instructions>
-      Based on the issue type and initial codebase discovery, gather information while
-      continuously verifying against the actual code implementation.
-      
-      CRITICAL FOR FEATURE REQUESTS: Be fact-driven and challenge assumptions!
-      When users describe current behavior as problematic for a feature request, you MUST verify
-      their claims against the actual code. If their description doesn't match reality, this
-      might actually be a bug report, not a feature request.
-      
-      For Bug Reports:
-      1. When user describes steps to reproduce:
-         - Search for the UI components/commands mentioned
-         - Verify the code paths that would be executed
-         - Check for existing error handling or known issues
-         
-      2. When user provides error messages:
-         - Search for exact error strings in codebase
-         - Find where errors are thrown
-         - Understand the conditions that trigger them
-         
-      3. For version information:
-         - Check package.json for actual version
-         - Look for version-specific code or migrations
-      
-      Example verification searches:
-      <search_files>
-      <path>[repository or package path]</path>
-      <regex>[exact error message from user]</regex>
-      </search_files>
-      
-      <codebase_search>
-      <query>[feature or component name] implementation</query>
-      <path>[repository or package path]</path>
-      </codebase_search>
-      
-      For Feature Requests - AGGRESSIVE VERIFICATION WITH CONCRETE EXAMPLES:
-      1. When user claims current behavior is X:
-         - ALWAYS search for the actual implementation
-         - Read the relevant code to verify their claim
-         - Check CSS/styling files if UI-related
-         - Look at configuration files
-         - Examine test files to understand expected behavior
-         - TRACE THE DATA FLOW: Follow values from where they're calculated to where they're used
-         
-      2. CRITICAL: Look for existing variables/code that could be reused:
-         - Search for variables that are calculated but not used where expected
-         - Identify existing patterns that could be extended
-         - Find similar features that work correctly for comparison
-         
-      3. If discrepancy found between claim and code:
-         - Do NOT proceed without clarification
-         - Present CONCRETE before/after examples with actual values
-         - Show exactly what happens vs what should happen
-         - Ask if this might be a bug instead
-         
-      Example verification approach:
-      User says: "Feature X doesn't work properly"
-      
-      Your investigation should follow this pattern:
-      a) What is calculated: Search for where X is computed/defined
-      b) Where it's stored: Find variables/state holding the value
-      c) Where it's used: Trace all usages of that value
-      d) What's missing: Identify gaps in the flow
-      
-      Present findings with concrete examples:
-      
-      <ask_followup_question>
-      <question>I investigated the implementation and found something interesting:
-      
-      Current behavior:
-      - The value is calculated at [file:line]: `value = computeX()`
-      - It's stored in variable `calculatedValue` at [file:line]
-      - BUT it's only used for [purpose A] at [file:line]
-      - It's NOT used for [purpose B] where you expected it
-      
-      Concrete example:
-      - When you do [action], the system calculates [value]
-      - This value goes to [location A]
-      - But [location B] still uses [old/different value]
-      
-      Is this the issue you're experiencing? This seems like the calculated value isn't being used where it should be.</question>
-      <follow_up>
-      <suggest>Yes, exactly! The value is calculated but not used in the right place</suggest>
-      <suggest>No, the issue is that the calculation itself is wrong</suggest>
-      <suggest>Actually, I see now that [location B] should use a different value</suggest>
-      </follow_up>
-      </ask_followup_question>
-      
-      4. Continue verification until facts are established:
-         - If user confirms it's a bug, switch to bug report workflow
-         - If user provides more specific context, search again
-         - Do not accept vague claims without code verification
-         
-      5. For genuine feature requests after verification:
-         - Document what the code currently does (with evidence and line numbers)
-         - Show the exact data flow: input → processing → output
-         - Confirm what the user wants changed with concrete examples
-         - Ensure the request is based on accurate understanding
-      
-      CRITICAL: For feature requests, if user's description doesn't match codebase reality:
-      - Challenge the assumption with code evidence AND concrete examples
-      - Show actual vs expected behavior with specific values
-      - Suggest it might be a bug if code shows different intent
-      - Ask for clarification repeatedly if needed
-      - Do NOT proceed until facts are established
-      
-      Only proceed when you have:
-      - Verified current behavior in code with line-by-line analysis
-      - Confirmed user's understanding matches reality
-      - Determined if it's truly a feature request or actually a bug
-      - Identified any existing code that could be reused for the fix
-      
-      Update todos after verification:
-      <update_todo_list>
-      <todos>
-      [x] Detect current repository information
-      [x] Determine repository structure (monorepo/standard)
-      [x] Perform initial codebase discovery
-      [x] Analyze user request to determine issue type
-      [x] Gather and verify additional information
-      [-] Determine if user wants to contribute
-      [ ] Perform issue scoping (if contributing)
-      [ ] Draft issue content
-      [ ] Review and confirm with user
-      [ ] Create GitHub issue
-      </todos>
-      </update_todo_list>
-    </instructions>
-  </step>
-
-  <step number="6">
-    <name>Determine Contribution Intent with Context</name>
-    <instructions>
-      Before asking about contribution, perform a quick technical assessment to provide context:
-      
-      1. Search for complexity indicators:
-         - Number of files that would need changes
-         - Existing tests that would need updates
-         - Dependencies and integration points
-         
-      2. Look for contribution helpers:
-         - CONTRIBUTING.md guidelines
-         - Existing similar implementations
-         - Test patterns to follow
-      
-      <codebase_search>
-      <query>CONTRIBUTING guide setup development</query>
-      </codebase_search>
-      
-      Based on findings, provide informed context in the question:
-      
-      <ask_followup_question>
-      <question>Based on my analysis, this [issue type] involves [brief complexity assessment from code exploration]. Are you interested in implementing this yourself, or are you reporting it for the project team to handle?</question>
-      <follow_up>
-      <suggest>Just reporting the problem - the project team can design the solution</suggest>
-      <suggest>I want to contribute and implement this myself</suggest>
-      <suggest>I'd like to provide issue scoping to help whoever implements it</suggest>
-      </follow_up>
-      </ask_followup_question>
-      
-      Update todos based on response:
-      <update_todo_list>
-      <todos>
-      [x] Detect current repository information
-      [x] Determine repository structure (monorepo/standard)
-      [x] Perform initial codebase discovery
-      [x] Analyze user request to determine issue type
-      [x] Gather and verify additional information
-      [x] Determine if user wants to contribute
-      [If contributing: [-] Perform issue scoping (if contributing)]
-      [If not contributing: [-] Perform issue scoping (skipped - not contributing)]
-      [-] Draft issue content
-      [ ] Review and confirm with user
-      [ ] Create GitHub issue
-      </todos>
-      </update_todo_list>
-    </instructions>
-  </step>
-
-  <step number="7">
-    <name>Issue Scoping for Contributors</name>
-    <instructions>
-      ONLY perform this step if the user wants to contribute or provide issue scoping.
-      
-      This step performs a comprehensive, aggressive investigation to create detailed technical
-      scoping that can guide implementation. The process involves multiple sub-phases:
-      
-      <sub_workflow name="comprehensive_issue_scoping">
-        <overview>
-          Perform an exhaustive investigation to produce a comprehensive technical solution
-          with extreme detail, suitable for automated fix workflows.
-        </overview>
-        
-        <phase number="1" name="Initialize Investigation">
-          <description>Expand the todo list to include detailed investigation steps</description>
-          <actions>
-            When starting the issue scoping phase, update the main todo list to include
-            the detailed investigation steps:
-            
-            <update_todo_list>
-            <todos>
-            [x] Detect current repository information
-            [x] Determine repository structure (monorepo/standard)
-            [x] Perform initial codebase discovery
-            [x] Analyze user request to determine issue type
-            [x] Gather and verify additional information
-            [x] Determine if user wants to contribute
-            [-] Perform issue scoping (if contributing)
-                [ ] Extract keywords from the issue description
-                [ ] Perform initial broad codebase search
-                [ ] Analyze search results and identify key components
-                [ ] Deep dive into relevant files and implementations
-                [ ] Form initial hypothesis about the issue/feature
-                [ ] Attempt to disprove hypothesis through further investigation
-                [ ] Identify all affected files and dependencies
-                [ ] Map out the complete implementation approach
-                [ ] Document technical risks and edge cases
-                [ ] Formulate comprehensive technical solution
-                [ ] Create detailed acceptance criteria
-                [ ] Prepare issue scoping summary
-            [ ] Draft issue content
-            [ ] Review and confirm with user
-            [ ] Create GitHub issue
-            </todos>
-            </update_todo_list>
-          </actions>
-        </phase>
-        
-        <phase number="2" name="Keyword Extraction">
-          <description>Extract all relevant keywords, concepts, and technical terms</description>
-          <actions>
-            - Identify primary technical concepts from user's description
-            - Extract error messages or specific symptoms
-            - Note any mentioned file paths or components
-            - List related features or functionality
-            - Include synonyms and related terms
-          </actions>
-          <update_progress>
-            Update the main todo list to mark "Extract keywords" as complete and move to next phase
-          </update_progress>
-        </phase>
-        
-        <phase number="3" name="Iterative Search">
-          <description>Perform multiple rounds of increasingly focused searches</description>
-          
-          <iteration name="Initial Broad Search">
-            Use codebase_search with all extracted keywords to get an overview of relevant code.
-            <codebase_search>
-            <query>[Combined keywords from extraction phase]</query>
-            <path>[Repository or package path]</path>
-            </codebase_search>
-          </iteration>
-          
-          <iteration name="Component Discovery">
-            Based on initial results, identify key components and search for:
-            - Related class/function definitions
-            - Import statements and dependencies
-            - Configuration files
-            - Test files that might reveal expected behavior
-          </iteration>
-          
-          <iteration name="Deep Implementation Search">
-            Search for specific implementation details:
-            - Error handling patterns
-            - State management
-            - API endpoints or routes
-            - Database queries or models
-            - UI components and their interactions
-          </iteration>
-          
-          <iteration name="Edge Case and Integration Search">
-            Look for:
-            - Edge cases in the code
-            - Integration points with other systems
-            - Configuration options that affect behavior
-            - Feature flags or conditional logic
-          </iteration>
-          
-          <update_progress>
-            After completing all search iterations, update the todo list to show progress
-          </update_progress>
-        </phase>
-        
-        <phase number="4" name="File Analysis">
-          <description>Thoroughly analyze all relevant files discovered</description>
-          <actions>
-            - Use list_code_definition_names to understand file structure
-            - Read complete files to understand full context
-            - Trace execution paths through the code
-            - Identify all dependencies and imports
-            - Map relationships between components
-          </actions>
-          <documentation>
-            Document findings including:
-            - File paths and their purposes
-            - Key functions and their responsibilities
-            - Data flow through the system
-            - External dependencies
-            - Potential impact areas
-          </documentation>
-        </phase>
-        
-        <phase number="5" name="Hypothesis Formation">
-          <description>Form a comprehensive hypothesis about the issue or feature</description>
-          <for_bugs>
-            - Identify the most likely root cause
-            - Trace the bug through the execution path
-            - Determine why the current implementation fails
-            - Consider environmental factors
-          </for_bugs>
-          <for_features>
-            - Identify the optimal integration points
-            - Determine required architectural changes
-            - Plan the implementation approach
-            - Consider scalability and maintainability
-          </for_features>
-        </phase>
-        
-        <phase number="6" name="Hypothesis Validation">
-          <description>Aggressively attempt to disprove the hypothesis</description>
-          <validation_steps>
-            <step name="Search for Alternative Implementations">
-              - Look for similar features implemented differently
-              - Check for deprecated code that might interfere
-            </step>
-            <step name="Configuration and Environment Check">
-              - Search for configuration that could change behavior
-              - Look for environment-specific code paths
-            </step>
-            <step name="Test Case Analysis">
-              - Find existing tests that might contradict hypothesis
-              - Look for test cases that reveal edge cases
-            </step>
-            <step name="Historical Context">
-              - Search for comments explaining design decisions
-              - Look for TODO or FIXME comments related to the area
-            </step>
-          </validation_steps>
-          <outcome>
-            If hypothesis is disproven, return to search phase with new insights.
-            If hypothesis stands, proceed to solution formulation.
-          </outcome>
-        </phase>
-        
-        <phase number="7" name="Solution Formulation">
-          <description>Create a comprehensive technical solution - PRIORITIZE SIMPLICITY</description>
-          <simplicity_principle>
-            CRITICAL: Before proposing any solution, ask yourself:
-            1. What existing variables/functions can I reuse?
-            2. What's the minimal change that fixes the issue?
-            3. Can I leverage existing patterns in the codebase?
-            4. Is there a simpler approach I'm overlooking?
-            
-            The best solution often reuses existing code rather than creating new complexity.
-          </simplicity_principle>
-          
-          <backwards_compatibility_principle>
-            ALWAYS consider backwards compatibility:
-            1. Will existing data/configurations still work with the new code?
-            2. Can we detect and handle legacy formats automatically?
-            3. What migration paths are needed for existing users?
-            4. Are there ways to make changes additive rather than breaking?
-            5. Document any compatibility considerations clearly
-          </backwards_compatibility_principle>
-          <components>
-            <component name="existing_code_analysis">
-              FIRST, identify what can be reused:
-              - Variables that are already calculated but not used where needed
-              - Functions that already do what we need
-              - Patterns in similar features we can follow
-              - Configuration that already exists but isn't applied
-              
-              Example finding:
-              "The variable `calculatedValue` already contains what we need at line X,
-              we just need to use it at line Y instead of recalculating"
-            </component>
-            
-            <component name="implementation_plan">
-              - Start with the SIMPLEST possible fix
-              - Exact files to modify with line numbers
-              - Prefer changing variable usage over creating new logic
-              - Specific code changes required (minimal diff)
-              - Order of implementation steps
-              - Migration strategy if needed
-            </component>
-            
-            <component name="dependency_analysis">
-              - All files that import affected code
-              - API contracts that must be maintained
-              - Existing tests that validate current behavior
-              - Configuration changes required (prefer reusing existing)
-              - Documentation updates needed
-            </component>
-            
-            <component name="test_strategy">
-              - Unit tests to add or modify
-              - Integration tests required
-              - Edge cases to test
-              - Performance testing needs
-              - Manual testing scenarios
-            </component>
-            
-            <component name="risk_assessment">
-              - Breaking changes identified
-              - Performance implications
-              - Security considerations
-              - Backward compatibility issues
-              - Rollback strategy
-            </component>
-          </components>
-        </phase>
-        
-        <phase number="8" name="Acceptance Criteria">
-          <description>Create extremely detailed acceptance criteria</description>
-          <format>
-            Given [detailed context including system state]
-            When [specific user or system action]
-            Then [exact expected outcome]
-            And [additional verifiable outcomes]
-            But [what should NOT happen]
-            
-            Include:
-            - Specific UI changes with exact text/behavior
-            - API response formats
-            - Database state changes
-            - Performance requirements
-            - Error handling scenarios
-          </format>
-          <guidelines>
-            - Each criterion must be independently testable
-            - Include both positive and negative test cases
-            - Specify exact error messages and codes
-            - Define performance thresholds where applicable
-          </guidelines>
-        </phase>
-        
-        <phase number="9" name="Issue Scoping Output">
-          <description>Format the comprehensive issue scoping section</description>
-          <output_template><![CDATA[
-## 🔍 Comprehensive Issue Scoping
-
-### Root Cause / Implementation Target
-[Detailed explanation of the core issue or feature target, focusing on the practical problem first]
-
-### Affected Components
-- **Primary Files:**
-  - `path/to/file1.ts` (lines X-Y): [Purpose and changes needed]
-  - `path/to/file2.ts` (lines A-B): [Purpose and changes needed]
-
-- **Secondary Impact:**
-  - Files that import affected components
-  - Related test files
-  - Documentation files
-
-### Current Implementation Analysis
-[Detailed explanation of how the current code works, with specific examples showing the data flow]
-Example: "The function at line X calculates [value] by [method], which results in [actual behavior]"
-
-### Proposed Implementation
-
-#### Step 1: [First implementation step]
-- File: `path/to/file.ts`
-- Changes: [Specific code changes]
-- Rationale: [Why this change is needed]
-
-#### Step 2: [Second implementation step]
-[Continue for all steps...]
-
-### Code Architecture Considerations
-- Design patterns to follow
-- Existing patterns in codebase to match
-- Architectural constraints
-
-### Testing Requirements
-- Unit Tests:
-  - [ ] Test case 1: [Description]
-  - [ ] Test case 2: [Description]
-- Integration Tests:
-  - [ ] Test scenario 1: [Description]
-- Edge Cases:
-  - [ ] Edge case 1: [Description]
-
-### Performance Impact
-- Expected performance change: [Increase/Decrease/Neutral]
-- Benchmarking needed: [Yes/No, specifics]
-- Optimization opportunities: [List any]
-
-### Security Considerations
-- Input validation requirements
-- Authentication/Authorization changes
-- Data exposure risks
-
-### Migration Strategy
-[If applicable, how to migrate existing data/functionality]
-
-### Rollback Plan
-[How to safely rollback if issues arise]
-
-### Dependencies and Breaking Changes
-- External dependencies affected: [List]
-- API contract changes: [List]
-- Breaking changes for users: [List with mitigation]
-          ]]></output_template>
-        </phase>
-      </sub_workflow>
-      
-      Additional considerations for monorepo repositories:
-      - Scope all searches to the identified package (if monorepo)
-      - Check for cross-package dependencies
-      - Verify against package-specific conventions
-      - Look for package-specific configuration
-      - Check if changes affect multiple packages
-      - Identify shared dependencies that might be impacted
-      - Look for workspace-specific scripts or tooling
-      - Consider package versioning implications
-      
-      After completing the comprehensive issue scoping, update the main todo list to show
-      all investigation steps are complete:
-      <update_todo_list>
-      <todos>
-      [x] Detect current repository information
-      [x] Determine repository structure (monorepo/standard)
-      [x] Perform initial codebase discovery
-      [x] Analyze user request to determine issue type
-      [x] Gather and verify additional information
-      [x] Determine if user wants to contribute
-      [x] Perform issue scoping (if contributing)
-          [x] Extract keywords from the issue description
-          [x] Perform initial broad codebase search
-          [x] Analyze search results and identify key components
-          [x] Deep dive into relevant files and implementations
-          [x] Form initial hypothesis about the issue/feature
-          [x] Attempt to disprove hypothesis through further investigation
-          [x] Identify all affected files and dependencies
-          [x] Map out the complete implementation approach
-          [x] Document technical risks and edge cases
-          [x] Formulate comprehensive technical solution
-          [x] Create detailed acceptance criteria
-          [x] Prepare issue scoping summary
-      [-] Draft issue content
-      [ ] Review and confirm with user
-      [ ] Create GitHub issue
-      </todos>
-      </update_todo_list>
-    </instructions>
-  </step>
-
-  <step number="8">
-    <name>Check for Repository Issue Templates</name>
-    <instructions>
-      Check if the repository has custom issue templates and use them. If not, create a simple generic template.
-      
-      1. Check for issue templates in standard locations:
-      <list_files>
-      <path>.github/ISSUE_TEMPLATE</path>
-      <recursive>true</recursive>
-      </list_files>
-      
-      2. Also check for single template file:
-      <list_files>
-      <path>.github</path>
-      <recursive>false</recursive>
-      </list_files>
-      
-      Look for files like:
-      - .github/ISSUE_TEMPLATE/*.md
-      - .github/ISSUE_TEMPLATE/*.yml
-      - .github/ISSUE_TEMPLATE/*.yaml
-      - .github/issue_template.md
-      - .github/ISSUE_TEMPLATE.md
-      
-      3. If templates are found:
-         a. Parse the template files to extract:
-            - Template name and description
-            - Required fields
-            - Template body structure
-            - Labels to apply
-         
-         b. For YAML templates, look for:
-            - name: Template display name
-            - description: Template description
-            - labels: Default labels
-            - body: Form fields or markdown template
-         
-         c. For Markdown templates, look for:
-            - Front matter with metadata
-            - Template structure with placeholders
-      
-      4. If multiple templates exist, ask user to choose:
-      <ask_followup_question>
-      <question>I found the following issue templates in this repository. Which one would you like to use?</question>
-      <follow_up>
-      <suggest>[Template 1 name]: [Template 1 description]</suggest>
-      <suggest>[Template 2 name]: [Template 2 description]</suggest>
-      </follow_up>
-      </ask_followup_question>
-      
-      5. If no templates are found:
-         - Create a simple generic template based on issue type
-         - For bugs: Basic structure with description, steps to reproduce, expected vs actual
-         - For features: Problem description, proposed solution, impact
-      
-      6. Store the selected/created template information:
-         - Template content/structure
-         - Required fields
-         - Default labels
-         - Any special formatting requirements
-      
-      Update todos:
-      <update_todo_list>
-      <todos>
-      [x] Detect current repository information
-      [x] Determine repository structure (monorepo/standard)
-      [x] Perform initial codebase discovery
-      [x] Analyze user request to determine issue type
-      [x] Gather and verify additional information
-      [x] Determine if user wants to contribute
-      [x] Perform issue scoping (if contributing)
-      [x] Check for repository issue templates
-      [-] Draft issue content
-      [ ] Review and confirm with user
-      [ ] Create GitHub issue
-      </todos>
-      </update_todo_list>
-    </instructions>
-  </step>
-
-  <step number="9">
-    <name>Draft Issue Content</name>
-    <instructions>
-      Create the issue body using the template from step 8 and all verified information from codebase exploration.
-      
-      If using a repository template:
-      - Fill in the template fields with gathered information
-      - Include code references and findings where appropriate
-      - Respect the template's structure and formatting
-      
-      If using a generated template (no repo templates found):
-      
-      For Bug Reports:
-      ```
-      ## Description
-      [Clear description of the bug with code context]
-      
-      ## Steps to Reproduce
-      1. [Step with relevant code paths]
-      2. [Step with component references]
-      3. [Continue with specific details]
-      
-      ## Expected Behavior
-      [What should happen based on code logic]
-      
-      ## Actual Behavior
-      [What actually happens]
-      
-      ## Additional Context
-      - Version: [from package.json if found]
-      - Environment: [any relevant details]
-      - Error logs: [if any]
-      
-      ## Code Investigation
-      [Include findings from codebase exploration]
-      - Relevant files: [list with line numbers]
-      - Possible cause: [hypothesis from code review]
-      
-      [If user is contributing, add the comprehensive issue scoping section from step 7]
-      ```
-      
-      For Feature Requests:
-      ```
-      ## Problem Description
-      [What problem does this solve, who is affected, when it happens]
-      
-      ## Current Behavior
-      [How it works now with specific examples]
-      
-      ## Proposed Solution
-      [What should change]
-      
-      ## Impact
-      [Who benefits and how]
-      
-      ## Technical Context
-      [Findings from codebase exploration]
-      - Similar features: [code references]
-      - Integration points: [from exploration]
-      - Architecture considerations: [if any]
-      
-      [If contributing, add the comprehensive issue scoping section from step 7]
-      ```
-      
-      Update todos:
-      <update_todo_list>
-      <todos>
-      [x] Detect current repository information
-      [x] Determine repository structure (monorepo/standard)
-      [x] Perform initial codebase discovery
-      [x] Analyze user request to determine issue type
-      [x] Gather and verify additional information
-      [x] Determine if user wants to contribute
-      [x] Perform issue scoping (if contributing)
-      [x] Check for repository issue templates
-      [x] Draft issue content
-      [-] Review and confirm with user
-      [ ] Create GitHub issue
-      </todos>
-      </update_todo_list>
-    </instructions>
-  </step>
-
-  <step number="10">
-    <name>Review and Confirm with User</name>
-    <instructions>
-      Present the complete drafted issue to the user for review, highlighting the
-      code-verified information:
-      
-      <ask_followup_question>
-      <question>I've prepared the following GitHub issue based on my analysis of the codebase and your description. I've verified the technical details against the actual implementation. Please review:
-
-      [Show the complete formatted issue content]
-
-      Key verifications made:
-      - ✓ Component locations confirmed in code
-      - ✓ Error messages matched to source
-      - ✓ Architecture compatibility checked
-      [List other relevant verifications]
-
-      Would you like me to create this issue, or would you like to make any changes?</question>
-      <follow_up>
-      <suggest>Yes, create this issue in the detected repository</suggest>
-      <suggest>Modify the problem description</suggest>
-      <suggest>Add more technical details</suggest>
-      <suggest>Change the title to: [let me specify]</suggest>
-      </follow_up>
-      </ask_followup_question>
-      
-      If user requests changes, make them and show the updated version for confirmation.
-      
-      After confirmation:
-      <update_todo_list>
-      <todos>
-      [x] Detect current repository information
-      [x] Determine repository structure (monorepo/standard)
-      [x] Perform initial codebase discovery
-      [x] Analyze user request to determine issue type
-      [x] Gather and verify additional information
-      [x] Determine if user wants to contribute
-      [x] Perform issue scoping (if contributing)
-      [x] Check for repository issue templates
-      [x] Draft issue content
-      [x] Review and confirm with user
-      [-] Prepare issue for submission
-      [ ] Handle submission choice
-      </todos>
-      </update_todo_list>
-    </instructions>
-  </step>
-
-  <step number="11">
-    <name>Prepare Issue for Submission</name>
-    <instructions>
-      Once user confirms the issue content, prepare it for submission:
-      
-      First, perform final duplicate check with refined search based on our findings:
-      <execute_command>
-      <command>gh issue list --repo $REPO_FULL_NAME --search "[key terms from verified analysis]" --state all --limit 10</command>
-      </execute_command>
-      
-      If no exact duplicates are found, save the issue content to a temporary file within the project:
-      
-      <write_to_file>
-      <path>./github_issue_draft.md</path>
-      <content>[The complete formatted issue body from step 8]</content>
-      <line_count>[calculated line count]</line_count>
-      </write_to_file>
-      
-      After saving the issue draft, ask the user how they would like to proceed:
-      
-      <ask_followup_question>
-      <question>I've saved the issue draft to ./github_issue_draft.md. The issue is ready for submission with the following details:
-
-      Title: "[Descriptive title with component name]"
-      Labels: [appropriate labels based on issue type]
-      Repository: $REPO_FULL_NAME
-
-      How would you like to proceed?</question>
-      <follow_up>
-      <suggest>Submit the issue now to the repository</suggest>
-      <suggest>Let me make some edits to the issue first</suggest>
-      <suggest>I'll submit it manually later</suggest>
-      </follow_up>
-      </ask_followup_question>
-      
-      Based on the user's response:
-      
-      If "Submit the issue now":
-        - Use gh issue create with the saved file
-        - Provide the created issue URL and number
-        - Clean up the temporary file
-        - Complete the workflow
-      
-      If "Let me make some edits":
-        - Ask what changes they'd like to make
-        - Update the draft file with their changes
-        - Return to the submission question
-      
-      If "I'll submit it manually":
-        - Inform them the draft is saved at the configured location
-        - Provide the gh command they can use later
-        - Complete the workflow without submission
-      
-      Update todos based on the outcome:
-      <update_todo_list>
-      <todos>
-      [x] Detect current repository information
-      [x] Determine repository structure (monorepo/standard)
-      [x] Perform initial codebase discovery
-      [x] Analyze user request to determine issue type
-      [x] Gather and verify additional information
-      [x] Determine if user wants to contribute
-      [x] Perform issue scoping (if contributing)
-      [x] Check for repository issue templates
-      [x] Draft issue content
-      [x] Review and confirm with user
-      [x] Prepare issue for submission
-      [-] Handle submission choice
-      </todos>
-      </update_todo_list>
-    </instructions>
-  </step>
-
-  <step number="12">
-    <name>Handle Submission Choice</name>
-    <instructions>
-      This step handles the user's choice from step 9.
-      
-      OPTION 1: Submit the issue now
-      If the user chooses to submit immediately:
-      
-      <execute_command>
-      <command>gh issue create --repo $REPO_FULL_NAME --title "[Descriptive title]" --body-file ./github_issue_draft.md --label "[appropriate labels]"</command>
-      </execute_command>
-      
-      Label selection based on findings:
-      - Bug: Use "bug" label
-      - Feature: Use "enhancement" label
-      - If affects multiple packages in monorepo: add "affects-multiple" label
-      
-      After successful creation:
-      - Capture and display the issue URL
-      - Clean up the temporary file:
-        <execute_command>
-        <command>rm ./github_issue_draft.md</command>
-        </execute_command>
-      - Provide a summary of key findings included
-      
-      OPTION 2: Make edits
-      If the user wants to edit:
-      
-      <ask_followup_question>
-      <question>What changes would you like to make to the issue?</question>
-      <follow_up>
-      <suggest>Update the title</suggest>
-      <suggest>Modify the problem description</suggest>
-      <suggest>Add or remove technical details</suggest>
-      <suggest>Change the labels or other metadata</suggest>
-      </follow_up>
-      </ask_followup_question>
-      
-      - Apply the requested changes to the draft
-      - Update the file with write_to_file
-      - Return to step 9 to ask about submission again
-      
-      OPTION 3: Manual submission
-      If the user will submit manually:
-      
-      Provide clear instructions:
-      "The issue draft has been saved to ./github_issue_draft.md
-
-      To submit it later, you can use:
-      gh issue create --repo $REPO_FULL_NAME --title "[Your title]" --body-file ./github_issue_draft.md --label "[labels]"
-      
-      Or you can copy the content and create the issue through the GitHub web interface."
-      
-      Final todo update:
-      <update_todo_list>
-      <todos>
-      [x] Detect current repository information
-      [x] Determine repository structure (monorepo/standard)
-      [x] Perform initial codebase discovery
-      [x] Analyze user request to determine issue type
-      [x] Gather and verify additional information
-      [x] Determine if user wants to contribute
-      [x] Perform issue scoping (if contributing)
-      [x] Check for repository issue templates
-      [x] Draft issue content
-      [x] Review and confirm with user
-      [x] Prepare issue for submission
-      [x] Handle submission choice
-      </todos>
-      </update_todo_list>
-    </instructions>
-  </step>
-</workflow>
\ No newline at end of file
diff --git a/.roo/rules-issue-writer/2_github_issue_templates.xml b/.roo/rules-issue-writer/2_github_issue_templates.xml
deleted file mode 100644
index 36b44125d..000000000
--- a/.roo/rules-issue-writer/2_github_issue_templates.xml
+++ /dev/null
@@ -1,190 +0,0 @@
-<github_issue_templates>
-  <overview>
-    This mode prioritizes using repository-specific issue templates over hardcoded ones.
-    If no templates exist in the repository, simple generic templates are created on the fly.
-  </overview>
-
-  <template_detection>
-    <locations>
-      <location priority="1">.github/ISSUE_TEMPLATE/*.yml</location>
-      <location priority="2">.github/ISSUE_TEMPLATE/*.yaml</location>
-      <location priority="3">.github/ISSUE_TEMPLATE/*.md</location>
-      <location priority="4">.github/issue_template.md</location>
-      <location priority="5">.github/ISSUE_TEMPLATE.md</location>
-    </locations>
-    
-    <yaml_template_structure>
-      <field name="name">Display name of the template</field>
-      <field name="description">Brief description of when to use this template</field>
-      <field name="title">Default issue title (optional)</field>
-      <field name="labels">Array of labels to apply</field>
-      <field name="assignees">Array of default assignees</field>
-      <field name="body">Array of form elements or markdown content</field>
-    </yaml_template_structure>
-    
-    <yaml_form_elements>
-      <element type="markdown">
-        <description>Static markdown content</description>
-        <attributes>
-          <attr name="value">The markdown content to display</attr>
-        </attributes>
-      </element>
-      
-      <element type="input">
-        <description>Single-line text input</description>
-        <attributes>
-          <attr name="id">Unique identifier</attr>
-          <attr name="label">Display label</attr>
-          <attr name="description">Help text</attr>
-          <attr name="placeholder">Placeholder text</attr>
-          <attr name="value">Default value</attr>
-          <attr name="required">Boolean</attr>
-        </attributes>
-      </element>
-      
-      <element type="textarea">
-        <description>Multi-line text input</description>
-        <attributes>
-          <attr name="id">Unique identifier</attr>
-          <attr name="label">Display label</attr>
-          <attr name="description">Help text</attr>
-          <attr name="placeholder">Placeholder text</attr>
-          <attr name="value">Default value</attr>
-          <attr name="required">Boolean</attr>
-          <attr name="render">Language for syntax highlighting</attr>
-        </attributes>
-      </element>
-      
-      <element type="dropdown">
-        <description>Dropdown selection</description>
-        <attributes>
-          <attr name="id">Unique identifier</attr>
-          <attr name="label">Display label</attr>
-          <attr name="description">Help text</attr>
-          <attr name="options">Array of options</attr>
-          <attr name="required">Boolean</attr>
-        </attributes>
-      </element>
-      
-      <element type="checkboxes">
-        <description>Multiple checkbox options</description>
-        <attributes>
-          <attr name="id">Unique identifier</attr>
-          <attr name="label">Display label</attr>
-          <attr name="description">Help text</attr>
-          <attr name="options">Array of checkbox items</attr>
-        </attributes>
-      </element>
-    </yaml_form_elements>
-    
-    <markdown_template_structure>
-      <front_matter>
-        Optional YAML front matter with:
-        - name: Template name
-        - about: Template description
-        - title: Default title
-        - labels: Comma-separated or array
-        - assignees: Comma-separated or array
-      </front_matter>
-      <body>
-        Markdown content with sections and placeholders
-        Common patterns:
-        - Headers with ##
-        - Placeholder text in brackets or as comments
-        - Checklists with - [ ]
-        - Code blocks with ```
-      </body>
-    </markdown_template_structure>
-  </template_detection>
-
-  <generic_templates>
-    <description>
-      When no repository templates exist, create simple templates based on issue type.
-      These should be minimal and focused on gathering essential information.
-    </description>
-    
-    <bug_template>
-      <structure>
-        - Description: Clear explanation of the bug
-        - Steps to Reproduce: Numbered list
-        - Expected Behavior: What should happen
-        - Actual Behavior: What actually happens
-        - Additional Context: Version, environment, logs
-        - Code Investigation: Findings from exploration (if any)
-      </structure>
-      <labels>["bug"]</labels>
-    </bug_template>
-    
-    <feature_template>
-      <structure>
-        - Problem Description: What problem this solves
-        - Current Behavior: How it works now
-        - Proposed Solution: What should change
-        - Impact: Who benefits and how
-        - Technical Context: Code findings (if any)
-      </structure>
-      <labels>["enhancement", "proposal"]</labels>
-    </feature_template>
-  </generic_templates>
-
-  <template_parsing_guidelines>
-    <guideline>
-      When parsing YAML templates:
-      1. Use a YAML parser to extract the structure
-      2. Convert form elements to markdown sections
-      3. Preserve required field indicators
-      4. Include descriptions as help text
-      5. Maintain the intended flow of the template
-    </guideline>
-    
-    <guideline>
-      When parsing Markdown templates:
-      1. Extract front matter if present
-      2. Identify section headers
-      3. Look for placeholder patterns
-      4. Preserve formatting and structure
-      5. Replace generic placeholders with user's information
-    </guideline>
-    
-    <guideline>
-      For template selection:
-      1. If only one template exists, use it automatically
-      2. If multiple exist, let user choose based on name/description
-      3. Match template to issue type when possible (bug vs feature)
-      4. Respect template metadata (labels, assignees, etc.)
-    </guideline>
-  </template_parsing_guidelines>
-
-  <filling_templates>
-    <principle>
-      Fill templates intelligently using gathered information:
-      - Map user's description to appropriate sections
-      - Include code investigation findings where relevant
-      - Preserve template structure and formatting
-      - Don't leave placeholder text unfilled
-      - Add contributor scoping if user is contributing
-    </principle>
-    
-    <mapping_examples>
-      <example from="Steps to Reproduce" to="User's reproduction steps + code paths"/>
-      <example from="Expected behavior" to="What user expects + code logic verification"/>
-      <example from="System information" to="Detected versions + environment"/>
-      <example from="Additional context" to="Code findings + architecture insights"/>
-    </mapping_examples>
-  </filling_templates>
-
-  <no_template_behavior>
-    <description>
-      When no templates exist, create appropriate generic templates on the fly.
-      Keep them simple and focused on essential information.
-    </description>
-    
-    <guidelines>
-      - Don't overwhelm with too many fields
-      - Focus on problem description first
-      - Include technical details only if user is contributing
-      - Use clear, simple section headers
-      - Adapt based on issue type (bug vs feature)
-    </guidelines>
-  </no_template_behavior>
-</github_issue_templates>
\ No newline at end of file
diff --git a/.roo/rules-issue-writer/3_best_practices.xml b/.roo/rules-issue-writer/3_best_practices.xml
deleted file mode 100644
index f2f149ed2..000000000
--- a/.roo/rules-issue-writer/3_best_practices.xml
+++ /dev/null
@@ -1,172 +0,0 @@
-<best_practices>
-  <mode_behavior>
-    - CRITICAL: This mode assumes the user's FIRST message is already an issue description
-    - Do NOT ask "What would you like to do?" or "Do you want to create an issue?"
-    - Immediately start the issue creation workflow when the user begins talking
-    - Treat their initial message as the problem/feature description
-    - Begin with repository detection and codebase discovery right away
-    - The user is already in "issue creation mode" by choosing this mode
-  </mode_behavior>
-  
-  <template_usage>
-    - ALWAYS check for repository-specific issue templates before creating issues
-    - Use templates from .github/ISSUE_TEMPLATE/ directory if they exist
-    - Parse both YAML (.yml/.yaml) and Markdown (.md) template formats
-    - If multiple templates exist, let the user choose the appropriate one
-    - If no templates exist, create a simple generic template on the fly
-    - NEVER fall back to hardcoded templates - always use repo templates or generate minimal ones
-    - Respect template metadata like labels, assignees, and title patterns
-    - Fill templates intelligently using gathered information from codebase exploration
-  </template_usage>
-  
-  <problem_reporting_focus>
-    - Focus on helping users describe problems clearly, not solutions
-    - The project team will design solutions unless the user explicitly wants to contribute
-    - Don't push users to provide technical details they may not have
-    - Make it easy for non-technical users to report issues effectively
-    
-    CRITICAL: Lead with user impact:
-    - Always explain WHO is affected and WHEN the problem occurs
-    - Use concrete examples with actual values, not abstractions
-    - Show before/after scenarios with specific data
-    - Example: "Users trying to [action] see [actual result] instead of [expected result]"
-  </problem_reporting_focus>
-  
-  <fact_driven_verification>
-    - ALWAYS verify user claims against actual code implementation
-    - For feature requests, aggressively check if current behavior matches user's description
-    - If code shows different intent than user describes, it might be a bug not a feature
-    - Present code evidence when challenging user assumptions
-    - Do not be agreeable - be fact-driven and question discrepancies
-    - Continue verification until facts are established
-    - A "feature request" where code shows the feature should already work is likely a bug
-    
-    CRITICAL additions for thorough analysis:
-    - Trace data flow from where values are created to where they're used
-    - Look for existing variables/functions that already contain needed data
-    - Check if the issue is just missing usage of existing code
-    - Follow imports and exports to understand data availability
-    - Identify patterns in similar features that work correctly
-  </fact_driven_verification>
-  
-  <general_practices>
-    - Always search for existing similar issues before creating a new one
-    - Check for and use repository issue templates before creating content
-    - Include specific version numbers and environment details
-    - Use code blocks with syntax highlighting for code snippets
-    - Make titles descriptive but concise (e.g., "Dark theme: Submit button invisible due to white-on-grey text")
-    - For bugs, always test if the issue is reproducible
-    - Include screenshots or mockups when relevant (ask user to provide)
-    - Link to related issues or PRs if found during exploration
-    
-    CRITICAL: Use concrete examples throughout:
-    - Show actual data values, not just descriptions
-    - Include specific file paths and line numbers
-    - Demonstrate the data flow with real examples
-    - Bad: "The value is incorrect"
-    - Good: "The function returns '123' when it should return '456'"
-  </general_practices>
-  
-  <contributor_specific>
-    - Only perform issue scoping if user wants to contribute
-    - Reference specific files and line numbers from codebase exploration
-    - Ensure technical proposals align with project architecture
-    - Include implementation steps and issue scoping
-    - Provide clear acceptance criteria in Given/When/Then format
-    - Consider trade-offs and alternative approaches
-    
-    CRITICAL: Prioritize simple solutions:
-    - ALWAYS check if needed functionality already exists before proposing new code
-    - Look for existing variables that just need to be passed/used differently
-    - Prefer using existing patterns over creating new ones
-    - The best fix often involves minimal code changes
-    - Example: "Use existing `modeInfo` from line 234 in export" vs "Create new mode tracking system"
-  </contributor_specific>
-  
-  <backwards_compatibility_focus>
-    ALWAYS consider backwards compatibility:
-    - Think about existing data/configurations already in use
-    - Propose solutions that handle both old and new formats gracefully
-    - Consider migration paths for existing users
-    - Document any breaking changes clearly
-    - Prefer additive changes over breaking changes when possible
-  </backwards_compatibility_focus>
-  
-  <communication_guidelines>
-    - Be supportive and encouraging to problem reporters
-    - Don't overwhelm users with technical questions upfront
-    - Clearly indicate when technical sections are optional
-    - Guide contributors through the additional requirements
-    - Make the "submit now" option clear for problem reporters
-    - When presenting template choices, include template descriptions to help users choose
-    - Explain that you're using the repository's own templates for consistency
-  </communication_guidelines>
-  
-  <template_best_practices>
-    <practice name="template_detection">
-      Always check these locations in order:
-      1. .github/ISSUE_TEMPLATE/*.yml or *.yaml (GitHub form syntax)
-      2. .github/ISSUE_TEMPLATE/*.md (Markdown templates)
-      3. .github/issue_template.md (single template)
-      4. .github/ISSUE_TEMPLATE.md (alternate naming)
-    </practice>
-    
-    <practice name="template_parsing">
-      For YAML templates:
-      - Extract form elements and convert to appropriate markdown sections
-      - Preserve required field indicators
-      - Include field descriptions as context
-      - Respect dropdown options and checkbox lists
-      
-      For Markdown templates:
-      - Parse front matter for metadata
-      - Identify section headers and structure
-      - Replace placeholder text with actual information
-      - Maintain formatting and hierarchy
-    </practice>
-    
-    <practice name="template_filling">
-      - Map gathered information to template sections intelligently
-      - Don't leave placeholder text in the final issue
-      - Add code investigation findings to relevant sections
-      - Include contributor scoping in appropriate section if applicable
-      - Preserve the template's intended structure and flow
-    </practice>
-    
-    <practice name="no_template_handling">
-      When no templates exist:
-      - Create minimal, focused templates
-      - Use simple section headers
-      - Focus on essential information only
-      - Adapt structure based on issue type
-      - Don't overwhelm with unnecessary fields
-    </practice>
-  </template_best_practices>
-  <technical_accuracy_guidelines>
-    <guideline name="thorough_code_analysis">
-      Before proposing ANY solution:
-      1. Use codebase_search extensively to find all related code
-      2. Read multiple files to understand the full context
-      3. Trace variable usage from creation to consumption
-      4. Look for similar working features to understand patterns
-      5. Identify what already exists vs what's actually missing
-    </guideline>
-    
-    <guideline name="simplicity_first">
-      When designing solutions:
-      1. Check if the data/function already exists somewhere
-      2. Look for configuration options before code changes
-      3. Prefer passing existing variables over creating new ones
-      4. Use established patterns from similar features
-      5. Aim for minimal diff size
-    </guideline>
-    
-    <guideline name="precise_technical_details">
-      Always include:
-      - Exact file paths and line numbers
-      - Variable/function names as they appear in code
-      - Before/after code snippets showing minimal changes
-      - Clear explanation of why the simple fix works
-    </guideline>
-  </technical_accuracy_guidelines>
-</best_practices>
\ No newline at end of file
diff --git a/.roo/rules-issue-writer/4_common_mistakes_to_avoid.xml b/.roo/rules-issue-writer/4_common_mistakes_to_avoid.xml
deleted file mode 100644
index a8dd9b590..000000000
--- a/.roo/rules-issue-writer/4_common_mistakes_to_avoid.xml
+++ /dev/null
@@ -1,126 +0,0 @@
-<common_mistakes_to_avoid>
-  <mode_initialization_mistakes>
-    - CRITICAL: Asking "What would you like to do?" when mode starts
-    - Waiting for user to say "create an issue" or "make me an issue"
-    - Not treating the first user message as the issue description
-    - Delaying the workflow start with unnecessary questions
-    - Asking if they want to create an issue when they've already chosen this mode
-    - Not immediately beginning repository detection and codebase discovery
-  </mode_initialization_mistakes>
-  
-  <problem_reporting_mistakes>
-    - Vague descriptions like "doesn't work" or "broken"
-    - Missing reproduction steps for bugs
-    - Feature requests without clear problem statements
-    - Not explaining the impact on users
-    - Forgetting to specify when/how the problem occurs
-    - Using wrong labels or no labels
-    - Titles that don't summarize the issue
-    - Not checking for duplicates
-  </problem_reporting_mistakes>
-  
-  <workflow_mistakes>
-    - Asking for technical details from non-contributing users
-    - Performing issue scoping before confirming user wants to contribute
-    - Requiring acceptance criteria from problem reporters
-    - Making the process too complex for simple problem reports
-    - Not clearly indicating the "submit now" option
-    - Overwhelming users with contributor requirements upfront
-    - Using hardcoded templates instead of repository templates
-    - Not checking for issue templates before creating content
-    - Ignoring template metadata like labels and assignees
-  </workflow_mistakes>
-  
-  <contributor_mistakes>
-    - Starting implementation before approval
-    - Not providing detailed issue scoping when contributing
-    - Missing acceptance criteria for contributed features
-    - Forgetting to include technical context from code exploration
-    - Not considering trade-offs and alternatives
-    - Proposing solutions without understanding current architecture
-  </contributor_mistakes>
-  
-  <technical_analysis_mistakes>
-    <mistake>Not tracing data flow completely through the system</mistake>
-    <impact>Missing that data already exists leads to proposing unnecessary new code</impact>
-    <correct_approach>
-      - Use codebase_search extensively to find ALL related code
-      - Trace variables from creation to consumption
-      - Check if needed data is already calculated but not used
-      - Look for similar working features as patterns
-    </correct_approach>
-    <example>
-      Bad: "Add mode tracking to import function"
-      Good: "The export already includes mode info at line 234, just use it in import at line 567"
-    </example>
-  </technical_analysis_mistakes>
-  
-  <solution_design_mistakes>
-    <mistake>Proposing complex new systems when simple fixes exist</mistake>
-    <impact>Creates unnecessary complexity, maintenance burden, and potential bugs</impact>
-    <correct_approach>
-      - ALWAYS check if functionality already exists first
-      - Look for minimal changes that solve the problem
-      - Prefer using existing variables/functions differently
-      - Aim for the smallest possible diff
-    </correct_approach>
-    <example>
-      Bad: "Create new state management system for mode tracking"
-      Good: "Pass existing modeInfo variable from line 45 to the function at line 78"
-    </example>
-  </solution_design_mistakes>
-  
-  <code_verification_mistakes>
-    <mistake>Not reading actual code before proposing solutions</mistake>
-    <impact>Solutions don't match the actual codebase structure</impact>
-    <correct_approach>
-      - Always read the relevant files first
-      - Verify exact line numbers and content
-      - Check imports/exports to understand data availability
-      - Look at similar features that work correctly
-    </correct_approach>
-  </code_verification_mistakes>
-  
-  <pattern_recognition_mistakes>
-    <mistake>Creating new patterns instead of following existing ones</mistake>
-    <impact>Inconsistent codebase, harder to maintain</impact>
-    <correct_approach>
-      - Find similar features that work correctly
-      - Follow the same patterns and structures
-      - Reuse existing utilities and helpers
-      - Maintain consistency with the codebase style
-    </correct_approach>
-  </pattern_recognition_mistakes>
-  
-  <template_usage_mistakes>
-    <mistake>Using hardcoded templates when repository templates exist</mistake>
-    <impact>Issues don't follow repository conventions, may be rejected or need reformatting</impact>
-    <correct_approach>
-      - Always check .github/ISSUE_TEMPLATE/ directory first
-      - Parse and use repository templates when available
-      - Only create generic templates when none exist
-    </correct_approach>
-  </template_usage_mistakes>
-  
-  <template_parsing_mistakes>
-    <mistake>Not properly parsing YAML template structure</mistake>
-    <impact>Missing required fields, incorrect formatting, lost metadata</impact>
-    <correct_approach>
-      - Parse YAML templates to extract all form elements
-      - Convert form elements to appropriate markdown sections
-      - Preserve field requirements and descriptions
-      - Maintain dropdown options and checkbox lists
-    </correct_approach>
-  </template_parsing_mistakes>
-  
-  <template_filling_mistakes>
-    <mistake>Leaving placeholder text in final issue</mistake>
-    <impact>Unprofessional appearance, confusion about what information is needed</impact>
-    <correct_approach>
-      - Replace all placeholders with actual information
-      - Remove instruction text meant for template users
-      - Fill every section with relevant content
-      - Add "N/A" for truly inapplicable sections
-    </correct_approach>
-  </template_filling_mistakes>
-</common_mistakes_to_avoid>
\ No newline at end of file
diff --git a/.roo/rules-issue-writer/5_github_cli_usage.xml b/.roo/rules-issue-writer/5_github_cli_usage.xml
deleted file mode 100644
index 1792be87e..000000000
--- a/.roo/rules-issue-writer/5_github_cli_usage.xml
+++ /dev/null
@@ -1,342 +0,0 @@
-<github_cli_usage>
-  <overview>
-    The GitHub CLI (gh) provides comprehensive tools for interacting with GitHub.
-    Here's when and how to use each command in the issue creation workflow.
-    
-    Note: This mode prioritizes using repository-specific issue templates over
-    hardcoded ones. Templates are detected and used dynamically from the repository.
-  </overview>
-
-  <pre_creation_commands>
-    <command name="gh issue list">
-      <when_to_use>
-        ALWAYS use this FIRST before creating any issue to check for duplicates.
-        Search for keywords from the user's problem description.
-      </when_to_use>
-      <example>
-        <execute_command>
-        <command>gh issue list --repo $REPO_FULL_NAME --search "dark theme button visibility" --state all --limit 20</command>
-        </execute_command>
-      </example>
-      <options>
-        --search: Search query for issue titles and bodies
-        --state: all, open, or closed
-        --label: Filter by specific labels
-        --limit: Number of results to show
-        --json: Get structured JSON output
-      </options>
-    </command>
-
-    <command name="gh search issues">
-      <when_to_use>
-        Use for more advanced searches across issues and pull requests.
-        Supports GitHub's advanced search syntax.
-      </when_to_use>
-      <example>
-        <execute_command>
-        <command>gh search issues --repo $REPO_FULL_NAME "dark theme button" --limit 10</command>
-        </execute_command>
-      </example>
-    </command>
-
-    <command name="gh issue view">
-      <when_to_use>
-        Use when you find a potentially related issue and need full details.
-        Check if the user's issue is already reported or related.
-      </when_to_use>
-      <example>
-        <execute_command>
-        <command>gh issue view 123 --repo $REPO_FULL_NAME --comments</command>
-        </execute_command>
-      </example>
-      <options>
-        --comments: Include issue comments
-        --json: Get structured data
-        --web: Open in browser
-      </options>
-    </command>
-  </pre_creation_commands>
-
-  <template_detection_commands>
-    <command name="list_files">
-      <when_to_use>
-        Use to check for issue templates in the repository before creating issues.
-        This is not a gh command but necessary for template detection.
-      </when_to_use>
-      <examples>
-        Check for templates in standard location:
-        <list_files>
-        <path>.github/ISSUE_TEMPLATE</path>
-        <recursive>true</recursive>
-        </list_files>
-        
-        Check for single template file:
-        <list_files>
-        <path>.github</path>
-        <recursive>false</recursive>
-        </list_files>
-      </examples>
-    </command>
-
-    <command name="read_file">
-      <when_to_use>
-        Read template files to parse their structure and content.
-        Used after detecting template files.
-      </when_to_use>
-      <examples>
-        Read YAML template:
-        <read_file>
-        <path>.github/ISSUE_TEMPLATE/bug_report.yml</path>
-        </read_file>
-        
-        Read Markdown template:
-        <read_file>
-        <path>.github/ISSUE_TEMPLATE/feature_request.md</path>
-        </read_file>
-      </examples>
-    </command>
-  </template_detection_commands>
-
-  <contributor_only_commands>
-    <note>
-      These commands should ONLY be used if the user has indicated they want to
-      contribute the implementation. Skip these for problem reporters.
-    </note>
-    
-    <command name="gh repo view">
-      <when_to_use>
-        Get repository information and recent activity.
-      </when_to_use>
-      <example>
-        <execute_command>
-        <command>gh repo view $REPO_FULL_NAME --json defaultBranchRef,description,updatedAt</command>
-        </execute_command>
-      </example>
-    </command>
-
-    <command name="gh search prs">
-      <when_to_use>
-        Check recent PRs that might be related to the issue.
-        Look for PRs that modified relevant code.
-      </when_to_use>
-      <example>
-        <execute_command>
-        <command>gh search prs --repo $REPO_FULL_NAME "dark theme" --limit 10 --state all</command>
-        </execute_command>
-      </example>
-    </command>
-
-    <command name="git log">
-      <when_to_use>
-        For bug reports from contributors, check recent commits that might have introduced the issue.
-        Use after cloning the repository locally.
-      </when_to_use>
-      <example>
-        <execute_command>
-        <command>git log --oneline --grep="theme" -n 20</command>
-        </execute_command>
-      </example>
-    </command>
-  </contributor_only_commands>
-
-  <issue_creation_command>
-    <command name="gh issue create">
-      <when_to_use>
-        Only use after:
-        1. Confirming no duplicates exist
-        2. Checking for and using repository templates
-        3. Gathering all required information
-        4. Determining if user is contributing or just reporting
-        5. Getting user confirmation
-      </when_to_use>
-      <bug_report_example>
-        <execute_command>
-        <command>gh issue create --repo $REPO_FULL_NAME --title "[Descriptive title of the bug]" --body-file /tmp/issue_body.md --label "bug"</command>
-        </execute_command>
-      </bug_report_example>
-      <feature_request_example>
-        <execute_command>
-        <command>gh issue create --repo $REPO_FULL_NAME --title "[Problem-focused title]" --body-file /tmp/issue_body.md --label "proposal" --label "enhancement"</command>
-        </execute_command>
-      </feature_request_example>
-      <options>
-        --title: Issue title (required)
-        --body: Issue body text
-        --body-file: Read body from file
-        --label: Add labels (can use multiple times)
-        --assignee: Assign to user
-        --project: Add to project
-        --web: Open in browser to create
-      </options>
-    </command>
-  </issue_creation_command>
-
-  <post_creation_commands>
-    <command name="gh issue comment">
-      <when_to_use>
-        ONLY use if user wants to add additional information after creation.
-      </when_to_use>
-      <example>
-        <execute_command>
-        <command>gh issue comment 456 --repo $REPO_FULL_NAME --body "Additional context or comments."</command>
-        </execute_command>
-      </example>
-    </command>
-
-    <command name="gh issue edit">
-      <when_to_use>
-        Use if user realizes they need to update the issue after creation.
-        Can update title, body, or labels.
-      </when_to_use>
-      <example>
-        <execute_command>
-        <command>gh issue edit 456 --repo $REPO_FULL_NAME --title "[Updated title]" --body "[Updated body]"</command>
-        </execute_command>
-      </example>
-    </command>
-  </post_creation_commands>
-
-  <workflow_integration>
-    <step_1_integration>
-      After user selects issue type, immediately search for related issues:
-      1. Use `gh issue list --search` with keywords from their description
-      2. Show any similar issues found
-      3. Ask if they want to continue or comment on existing issue
-    </step_1_integration>
-
-    <step_2_integration>
-      Template detection (NEW):
-      1. Use list_files to check .github/ISSUE_TEMPLATE/ directory
-      2. Read any template files found (YAML or Markdown)
-      3. Parse template structure and metadata
-      4. If multiple templates, let user choose
-      5. If no templates, prepare to create generic one
-    </step_2_integration>
-
-    <step_3_integration>
-      Decision point for contribution:
-      1. Ask user if they want to contribute implementation
-      2. If yes: Use contributor commands for codebase investigation
-      3. If no: Skip directly to creating a problem-focused issue
-      4. This saves time for problem reporters
-    </step_3_integration>
-
-    <step_4_integration>
-      During codebase exploration (CONTRIBUTORS ONLY):
-      1. Clone repo locally if needed: `gh repo clone $REPO_FULL_NAME`
-      2. Use `git log` to find recent changes to affected files
-      3. Use `gh search prs` for related pull requests
-      4. Include findings in the technical context section
-    </step_4_integration>
-
-    <step_5_integration>
-      When creating the issue:
-      1. Use repository template if found, or generic template if not
-      2. Fill template with gathered information
-      3. Format differently based on contributor vs problem reporter
-      4. Save formatted body to temporary file
-      5. Use `gh issue create` with appropriate labels from template
-      6. Capture the returned issue URL
-      7. Show user the created issue URL
-    </step_5_integration>
-  </workflow_integration>
-
-  <best_practices>
-    <practice name="file_handling">
-      When creating issues with long bodies:
-      1. Save to temporary file: `cat > /tmp/issue_body.md << 'EOF'`
-      2. Use --body-file flag with gh issue create
-      3. Clean up after: `rm /tmp/issue_body.md`
-    </practice>
-
-    <practice name="search_efficiency">
-      Use specific search terms:
-      - Include error messages in quotes
-      - Use label filters when appropriate
-      - Limit results to avoid overwhelming output
-    </practice>
-
-    <practice name="json_output">
-      Use --json flag for structured data when needed:
-      - Easier to parse programmatically
-      - Consistent format across commands
-      - Example: `gh issue list --json number,title,state`
-    </practice>
-  </best_practices>
-
-  <error_handling>
-    <duplicate_found>
-      If search finds exact duplicate:
-      - Show the existing issue to user using `gh issue view`
-      - Ask if they want to add a comment instead
-      - Use `gh issue comment` if they agree
-    </duplicate_found>
-
-    <creation_failed>
-      If `gh issue create` fails:
-      - Check error message (auth, permissions, network)
-      - Ensure gh is authenticated: `gh auth status`
-      - Save the drafted issue content for user
-      - Suggest using --web flag to create in browser
-    </creation_failed>
-
-    <authentication>
-      Ensure GitHub CLI is authenticated:
-      - Check status: `gh auth status`
-      - Login if needed: `gh auth login`
-      - Select appropriate scopes for issue creation
-    </authentication>
-  </error_handling>
-
-  <command_reference>
-    <issues>
-      gh issue create    - Create new issue
-      gh issue list      - List and search issues
-      gh issue view      - View issue details
-      gh issue comment   - Add comment to issue
-      gh issue edit      - Edit existing issue
-      gh issue close     - Close an issue
-      gh issue reopen    - Reopen closed issue
-    </issues>
-
-    <search>
-      gh search issues   - Search issues and PRs
-      gh search prs      - Search pull requests
-      gh search repos    - Search repositories
-    </search>
-
-    <repository>
-      gh repo view       - View repository info
-      gh repo clone      - Clone repository
-    </repository>
-  </command_reference>
-
-  <template_handling_reference>
-    <yaml_template_parsing>
-      When parsing YAML templates:
-      - Extract 'name' for template identification
-      - Get 'labels' array for automatic labeling
-      - Parse 'body' array for form elements
-      - Convert form elements to markdown sections
-      - Preserve 'required' field indicators
-    </yaml_template_parsing>
-    
-    <markdown_template_parsing>
-      When parsing Markdown templates:
-      - Check for YAML front matter
-      - Extract metadata (labels, assignees)
-      - Identify section headers
-      - Replace placeholder text
-      - Maintain formatting structure
-    </markdown_template_parsing>
-    
-    <template_usage_flow>
-      1. Detect templates with list_files
-      2. Read templates with read_file
-      3. Parse structure and metadata
-      4. Let user choose if multiple exist
-      5. Fill template with information
-      6. Create issue with template content
-    </template_usage_flow>
-  </template_handling_reference>
-</github_cli_usage>
\ No newline at end of file
diff --git a/.roo/rules-merge-resolver/1_workflow.xml b/.roo/rules-merge-resolver/1_workflow.xml
deleted file mode 100644
index a63809db7..000000000
--- a/.roo/rules-merge-resolver/1_workflow.xml
+++ /dev/null
@@ -1,142 +0,0 @@
-<merge_resolver_workflow>
-  <mode_overview>
-    This mode resolves merge conflicts for a specific pull request by analyzing git history,
-    commit messages, and code changes to make intelligent resolution decisions. It receives
-    a PR number (e.g., "#123") and handles the entire conflict resolution process.
-  </mode_overview>
-
-  <initialization_steps>
-    <step number="1">
-      <action>Parse PR number from user input</action>
-      <details>
-        Extract the PR number from input like "#123" or "PR #123"
-        Validate that a PR number was provided
-      </details>
-    </step>
-    
-    <step number="2">
-      <action>Fetch PR information</action>
-      <tools>
-        <tool>gh pr view [PR_NUMBER] --json title,body,headRefName,baseRefName</tool>
-      </tools>
-      <details>
-        Get PR title and description to understand the intent
-        Identify the source and target branches
-      </details>
-    </step>
-
-    <step number="3">
-      <action>Checkout PR branch and prepare for rebase</action>
-      <tools>
-        <tool>gh pr checkout [PR_NUMBER] --force</tool>
-        <tool>git fetch origin main</tool>
-        <tool>git rebase origin/main</tool>
-      </tools>
-      <details>
-        Force checkout the PR branch to ensure clean state
-        Fetch the latest main branch
-        Attempt to rebase onto main to reveal conflicts
-      </details>
-    </step>
-
-    <step number="4">
-      <action>Check for merge conflicts</action>
-      <tools>
-        <tool>git status --porcelain</tool>
-        <tool>git diff --name-only --diff-filter=U</tool>
-      </tools>
-      <details>
-        Identify files with merge conflicts (marked with 'UU')
-        Create a list of files that need resolution
-      </details>
-    </step>
-  </initialization_steps>
-
-  <main_workflow>
-    <phase name="conflict_analysis">
-      <description>Analyze each conflicted file to understand the changes</description>
-      <steps>
-        <step>Read the conflicted file to identify conflict markers</step>
-        <step>Extract the conflicting sections between <<<<<<< and >>>>>>></step>
-        <step>Run git blame on both sides of the conflict</step>
-        <step>Fetch commit messages and diffs for relevant commits</step>
-        <step>Analyze the intent behind each change</step>
-      </steps>
-    </phase>
-
-    <phase name="resolution_strategy">
-      <description>Determine the best resolution strategy for each conflict</description>
-      <steps>
-        <step>Categorize changes by intent (bugfix, feature, refactor, etc.)</step>
-        <step>Evaluate recency and relevance of changes</step>
-        <step>Check for structural overlap vs formatting differences</step>
-        <step>Identify if changes can be combined or if one should override</step>
-        <step>Consider test updates and related changes</step>
-      </steps>
-    </phase>
-
-    <phase name="conflict_resolution">
-      <description>Apply the resolution strategy to resolve conflicts</description>
-      <steps>
-        <step>For each conflict, apply the chosen resolution</step>
-        <step>Ensure proper escaping of conflict markers in diffs</step>
-        <step>Validate that resolved code is syntactically correct</step>
-        <step>Stage resolved files with git add</step>
-      </steps>
-    </phase>
-
-    <phase name="validation">
-      <description>Verify the resolution and prepare for commit</description>
-      <steps>
-        <step>Run git status to confirm all conflicts are resolved</step>
-        <step>Check for any compilation or syntax errors</step>
-        <step>Review the final diff to ensure sensible resolutions</step>
-        <step>Prepare a summary of resolution decisions</step>
-      </steps>
-    </phase>
-  </main_workflow>
-
-  <git_commands>
-    <command name="checkout_pr">
-      <syntax>gh pr checkout [PR_NUMBER] --force</syntax>
-      <purpose>Force checkout the PR branch to ensure clean state</purpose>
-    </command>
-    
-    <command name="fetch_main">
-      <syntax>git fetch origin main</syntax>
-      <purpose>Get the latest main branch from origin</purpose>
-    </command>
-    
-    <command name="rebase_main">
-      <syntax>git rebase origin/main</syntax>
-      <purpose>Rebase current branch onto main to reveal conflicts</purpose>
-    </command>
-    
-    <command name="get_blame_info">
-      <syntax>git blame -L [start_line],[end_line] [commit_sha] -- [file_path]</syntax>
-      <purpose>Get commit information for specific lines</purpose>
-    </command>
-    
-    <command name="get_commit_details">
-      <syntax>git show --format="%H%n%an%n%ae%n%ad%n%s%n%b" --no-patch [commit_sha]</syntax>
-      <purpose>Get commit metadata including message</purpose>
-    </command>
-    
-    <command name="get_commit_diff">
-      <syntax>git show [commit_sha] -- [file_path]</syntax>
-      <purpose>Get the actual changes made in a commit</purpose>
-    </command>
-    
-    <command name="check_merge_status">
-      <syntax>git ls-files -u</syntax>
-      <purpose>List unmerged files with stage information</purpose>
-    </command>
-  </git_commands>
-
-  <completion_criteria>
-    <criterion>All merge conflicts have been resolved</criterion>
-    <criterion>Resolved files have been staged</criterion>
-    <criterion>No syntax errors in resolved code</criterion>
-    <criterion>Resolution decisions are documented</criterion>
-  </completion_criteria>
-</merge_resolver_workflow>
\ No newline at end of file
diff --git a/.roo/rules-merge-resolver/2_best_practices.xml b/.roo/rules-merge-resolver/2_best_practices.xml
deleted file mode 100644
index 5bf1b393e..000000000
--- a/.roo/rules-merge-resolver/2_best_practices.xml
+++ /dev/null
@@ -1,165 +0,0 @@
-<merge_resolver_best_practices>
-  <general_principles>
-    <principle priority="high">
-      <name>Intent-Based Resolution</name>
-      <description>
-        Always prioritize understanding the intent behind changes rather than
-        just looking at the code differences. Commit messages, PR descriptions,
-        and issue references provide crucial context.
-      </description>
-      <rationale>
-        Code changes have purpose - bugfixes should be preserved, features
-        should be integrated properly, and refactors should maintain consistency.
-      </rationale>
-      <example>
-        <scenario>Conflict between a bugfix and a refactor</scenario>
-        <good>Apply the bugfix logic within the refactored structure</good>
-        <bad>Simply choose one side without considering both intents</bad>
-      </example>
-    </principle>
-
-    <principle priority="high">
-      <name>Preserve All Valuable Changes</name>
-      <description>
-        When possible, combine non-conflicting changes from both sides rather
-        than discarding one side entirely.
-      </description>
-      <rationale>
-        Both sides of a conflict often contain valuable changes that can coexist
-        if properly integrated.
-      </rationale>
-    </principle>
-
-    <principle priority="high">
-      <name>Escape Conflict Markers</name>
-      <description>
-        When using apply_diff or search_and_replace tools, always escape merge
-        conflict markers with backslashes to prevent parsing errors.
-      </description>
-      <example><![CDATA[
-        Correct: \<<<<<<< HEAD
-        Wrong: <<<<<<< HEAD
-      ]]></example>
-    </principle>
-
-    <principle priority="medium">
-      <name>Consider Related Changes</name>
-      <description>
-        Look beyond the immediate conflict to understand related changes in
-        tests, documentation, or dependent code.
-      </description>
-      <rationale>
-        A change might seem isolated but could be part of a larger feature
-        or fix that spans multiple files.
-      </rationale>
-    </principle>
-  </general_principles>
-
-  <resolution_heuristics>
-    <heuristic category="bugfix_vs_feature">
-      <rule>Bugfixes generally take precedence over features</rule>
-      <reasoning>
-        Bugfixes address existing problems and should be preserved,
-        while features can be reintegrated around the fix.
-      </reasoning>
-    </heuristic>
-
-    <heuristic category="recent_vs_old">
-      <rule>More recent changes are often more relevant</rule>
-      <reasoning>
-        Recent changes likely reflect the current understanding of
-        requirements and may supersede older implementations.
-      </reasoning>
-      <exception>
-        When older changes are bugfixes or security patches that
-        haven't been addressed in newer code.
-      </exception>
-    </heuristic>
-
-    <heuristic category="test_updates">
-      <rule>Changes that include test updates are likely more complete</rule>
-      <reasoning>
-        Developers who update tests alongside code changes demonstrate
-        thoroughness and understanding of the impact.
-      </reasoning>
-    </heuristic>
-
-    <heuristic category="formatting_vs_logic">
-      <rule>Logic changes take precedence over formatting changes</rule>
-      <reasoning>
-        Formatting can be reapplied, but logic changes represent
-        functional improvements or fixes.
-      </reasoning>
-    </heuristic>
-  </resolution_heuristics>
-
-  <common_pitfalls>
-    <pitfall>
-      <description>Blindly choosing one side without analysis</description>
-      <why_problematic>
-        You might lose important changes or introduce regressions
-      </why_problematic>
-      <correct_approach>
-        Always analyze both sides using git blame and commit history
-      </correct_approach>
-    </pitfall>
-
-    <pitfall>
-      <description>Ignoring the PR description and context</description>
-      <why_problematic>
-        The PR description often explains the why behind changes,
-        which is crucial for proper resolution
-      </why_problematic>
-      <correct_approach>
-        Always fetch and read the PR information before resolving
-      </correct_approach>
-    </pitfall>
-
-    <pitfall>
-      <description>Not validating the resolved code</description>
-      <why_problematic>
-        Merged code might be syntactically incorrect or introduce
-        logical errors
-      </why_problematic>
-      <correct_approach>
-        Always check for syntax errors and review the final diff
-      </correct_approach>
-    </pitfall>
-
-    <pitfall>
-      <description>Not escaping conflict markers in diffs</description>
-      <why_problematic>
-        Unescaped conflict markers (<<<<<<, =======, >>>>>>) in SEARCH
-        or REPLACE sections will be interpreted as actual diff syntax,
-        causing the apply_diff tool to fail or produce incorrect results
-      </why_problematic>
-      <correct_approach>
-        Always escape conflict markers with a backslash (\) when they
-        appear in the content you're searching for or replacing.
-        Example: \<<<<<<< HEAD instead of <<<<<<< HEAD
-      </correct_approach>
-    </pitfall>
-  </common_pitfalls>
-
-  <quality_checklist>
-    <category name="before_resolution">
-      <item>Fetch PR title and description for context</item>
-      <item>Identify all files with conflicts</item>
-      <item>Understand the overall change being merged</item>
-    </category>
-    
-    <category name="during_resolution">
-      <item>Run git blame on conflicting sections</item>
-      <item>Read commit messages for intent</item>
-      <item>Consider if changes can be combined</item>
-      <item>Escape conflict markers in diffs</item>
-    </category>
-    
-    <category name="after_resolution">
-      <item>Verify no conflict markers remain</item>
-      <item>Check for syntax/compilation errors</item>
-      <item>Review the complete diff</item>
-      <item>Document resolution decisions</item>
-    </category>
-  </quality_checklist>
-</merge_resolver_best_practices>
\ No newline at end of file
diff --git a/.roo/rules-merge-resolver/3_tool_usage.xml b/.roo/rules-merge-resolver/3_tool_usage.xml
deleted file mode 100644
index 35f3b5da7..000000000
--- a/.roo/rules-merge-resolver/3_tool_usage.xml
+++ /dev/null
@@ -1,228 +0,0 @@
-<merge_resolver_tool_usage>
-  <tool_priorities>
-    <priority level="1">
-      <tool>execute_command</tool>
-      <when>For all git and gh CLI operations</when>
-      <why>Git commands provide the historical context needed for intelligent resolution</why>
-    </priority>
-    
-    <priority level="2">
-      <tool>read_file</tool>
-      <when>To examine conflicted files and understand the conflict structure</when>
-      <why>Need to see the actual conflict markers and code</why>
-    </priority>
-    
-    <priority level="3">
-      <tool>apply_diff or search_and_replace</tool>
-      <when>To resolve conflicts by replacing conflicted sections</when>
-      <why>Precise editing of specific conflict blocks</why>
-    </priority>
-  </tool_priorities>
-
-  <tool_specific_guidance>
-    <tool name="execute_command">
-      <best_practices>
-        <practice>Always use gh CLI for GitHub operations instead of MCP tools</practice>
-        <practice>Chain git commands with && for efficiency</practice>
-        <practice>Use --format options for structured output</practice>
-        <practice>Capture command output for parsing</practice>
-      </best_practices>
-      
-      <common_commands>
-        <command>
-          <purpose>Get PR information</purpose>
-          <syntax>gh pr view [PR_NUMBER] --json title,body,headRefName,baseRefName</syntax>
-        </command>
-        
-        <command>
-          <purpose>Checkout PR branch</purpose>
-          <syntax>gh pr checkout [PR_NUMBER] --force</syntax>
-        </command>
-        
-        <command>
-          <purpose>Fetch latest main branch</purpose>
-          <syntax>git fetch origin main</syntax>
-        </command>
-        
-        <command>
-          <purpose>Rebase onto main to reveal conflicts</purpose>
-          <syntax>git rebase origin/main</syntax>
-        </command>
-        
-        <command>
-          <purpose>Check conflict status</purpose>
-          <syntax>git status --porcelain | grep "^UU"</syntax>
-        </command>
-        
-        <command>
-          <purpose>Get blame for specific lines</purpose>
-          <syntax>git blame -L [start],[end] HEAD -- [file] | cut -d' ' -f1</syntax>
-        </command>
-        
-        <command>
-          <purpose>Get commit message</purpose>
-          <syntax>git log -1 --format="%s%n%n%b" [commit_sha]</syntax>
-        </command>
-        
-        <command>
-          <purpose>Stage resolved file</purpose>
-          <syntax>git add [file_path]</syntax>
-        </command>
-        
-        <command>
-          <purpose>Continue rebase after resolution</purpose>
-          <syntax>git rebase --continue</syntax>
-        </command>
-      </common_commands>
-    </tool>
-
-    <tool name="read_file">
-      <best_practices>
-        <practice>Read the entire conflicted file first to understand structure</practice>
-        <practice>Note line numbers of conflict markers for precise editing</practice>
-        <practice>Identify the pattern of conflicts (multiple vs single)</practice>
-      </best_practices>
-      
-      <conflict_parsing>
-        <marker><<<<<<< HEAD - Start of current branch changes</marker>
-        <marker>======= - Separator between versions</marker>
-        <marker>>>>>>>> [branch] - End of incoming changes</marker>
-      </conflict_parsing>
-    </tool>
-
-    <tool name="apply_diff">
-      <best_practices>
-        <practice>Always escape conflict markers with backslash</practice>
-        <practice>Include enough context to ensure unique matches</practice>
-        <practice>Use :start_line: for precision</practice>
-        <practice>Combine multiple resolutions in one diff when possible</practice>
-      </best_practices>
-      
-      <example><![CDATA[
-<apply_diff>
-<path>src/feature.ts</path>
-<diff>
-<<<<<<< SEARCH
-:start_line:45
--------
-\<<<<<<< HEAD
-function oldImplementation() {
-  return "old";
-}
-\=======
-function newImplementation() {
-  return "new";
-}
-\>>>>>>> feature-branch
-=======
-function mergedImplementation() {
-  // Combining both approaches
-  return "merged";
-}
->>>>>>> REPLACE
-</diff>
-</apply_diff>
-      ]]></example>
-    </tool>
-
-    <tool name="search_and_replace">
-      <best_practices>
-        <practice>Use for simple conflict resolutions</practice>
-        <practice>Enable regex mode for complex patterns</practice>
-        <practice>Always escape special characters</practice>
-      </best_practices>
-      
-      <example><![CDATA[
-<search_and_replace>
-<path>src/config.ts</path>
-<search>\<<<<<<< HEAD[\s\S]*?\>>>>>>> \w+</search>
-<replace>// Resolved configuration
-const config = {
-  // Merged settings from both branches
-}</replace>
-<use_regex>true</use_regex>
-</search_and_replace>
-      ]]></example>
-    </tool>
-  </tool_specific_guidance>
-
-  <tool_combination_patterns>
-    <pattern name="initialize_pr_resolution">
-      <sequence>
-        <step>execute_command - Get PR info with gh CLI</step>
-        <step>execute_command - Checkout PR with gh pr checkout --force</step>
-        <step>execute_command - Fetch origin main</step>
-        <step>execute_command - Rebase onto origin/main</step>
-        <step>execute_command - Check for conflicts with git status</step>
-      </sequence>
-    </pattern>
-    
-    <pattern name="analyze_conflict">
-      <sequence>
-        <step>execute_command - List conflicted files</step>
-        <step>read_file - Examine conflict structure</step>
-        <step>execute_command - Git blame on conflict regions</step>
-        <step>execute_command - Fetch commit messages</step>
-      </sequence>
-    </pattern>
-    
-    <pattern name="resolve_conflict">
-      <sequence>
-        <step>read_file - Get exact conflict content</step>
-        <step>apply_diff - Replace conflict with resolution</step>
-        <step>execute_command - Stage resolved file</step>
-        <step>execute_command - Verify resolution status</step>
-      </sequence>
-    </pattern>
-    
-    <pattern name="complete_rebase">
-      <sequence>
-        <step>execute_command - Check all conflicts resolved</step>
-        <step>execute_command - Continue rebase with git rebase --continue</step>
-        <step>execute_command - Verify clean status</step>
-      </sequence>
-    </pattern>
-  </tool_combination_patterns>
-
-  <error_handling>
-    <scenario name="no_conflicts_after_rebase">
-      <description>Rebase completes without conflicts</description>
-      <approach>
-        Inform user that PR can be merged without conflicts
-        No resolution needed
-      </approach>
-    </scenario>
-    
-    <scenario name="rebase_in_progress">
-      <description>A rebase is already in progress</description>
-      <approach>
-        Check status with git status
-        Either continue existing rebase or abort with git rebase --abort
-      </approach>
-    </scenario>
-    
-    <scenario name="malformed_conflicts">
-      <description>Conflict markers are incomplete or nested</description>
-      <approach>
-        Use search_and_replace with careful regex patterns
-        Manual inspection may be required
-      </approach>
-    </scenario>
-    
-    <scenario name="binary_conflicts">
-      <description>Binary files cannot be merged automatically</description>
-      <approach>
-        Identify which version to keep based on PR intent
-        Use git checkout --theirs or --ours
-      </approach>
-    </scenario>
-    
-    <scenario name="escaped_markers">
-      <description>Code contains literal conflict marker strings</description>
-      <approach>
-        Extra careful escaping in diffs
-        Consider using search_and_replace with precise patterns
-      </approach>
-    </scenario>
-  </error_handling>
-</merge_resolver_tool_usage>
\ No newline at end of file
diff --git a/.roo/rules-merge-resolver/4_complete_example.xml b/.roo/rules-merge-resolver/4_complete_example.xml
deleted file mode 100644
index dae858799..000000000
--- a/.roo/rules-merge-resolver/4_complete_example.xml
+++ /dev/null
@@ -1,315 +0,0 @@
-<merge_resolver_example>
-  <scenario>
-    User provides PR #123 which has merge conflicts between a bugfix branch
-    and a feature branch that refactored the same code.
-  </scenario>
-
-  <user_request>
-    #123
-  </user_request>
-
-  <workflow>
-    <step number="1">
-      <description>Parse PR number and fetch PR information</description>
-      <tool_use><![CDATA[
-<execute_command>
-<command>gh pr view 123 --json title,body,headRefName,baseRefName</command>
-</execute_command>
-      ]]></tool_use>
-      <expected_output><![CDATA[
-{
-  "title": "Fix memory leak in data processor",
-  "body": "This PR fixes a memory leak that occurs when processing large datasets. The leak was caused by event listeners not being properly removed.",
-  "headRefName": "fix/memory-leak",
-  "baseRefName": "main"
-}
-      ]]></expected_output>
-      <analysis>
-        The PR is a bugfix for a memory leak issue. This context will help
-        prioritize preserving the fix during conflict resolution.
-      </analysis>
-    </step>
-
-    <step number="2">
-      <description>Checkout PR branch and prepare for rebase</description>
-      <tool_use><![CDATA[
-<execute_command>
-<command>gh pr checkout 123 --force</command>
-</execute_command>
-      ]]></tool_use>
-      <expected_output><![CDATA[
-Switched to branch 'fix/memory-leak'
-Your branch is up to date with 'origin/fix/memory-leak'.
-      ]]></expected_output>
-      
-      <tool_use><![CDATA[
-<execute_command>
-<command>git fetch origin main</command>
-</execute_command>
-      ]]></tool_use>
-      <expected_output><![CDATA[
-From github.com:user/repo
- * branch            main       -> FETCH_HEAD
-      ]]></expected_output>
-      
-      <tool_use><![CDATA[
-<execute_command>
-<command>git rebase origin/main</command>
-</execute_command>
-      ]]></tool_use>
-      <expected_output><![CDATA[
-Auto-merging src/data/processor.ts
-CONFLICT (content): Merge conflict in src/data/processor.ts
-Auto-merging src/data/processor.test.ts
-CONFLICT (content): Merge conflict in src/data/processor.test.ts
-error: could not apply abc123... Fix memory leak in data processor
-Resolve all conflicts manually, mark them as resolved with
-"git add/rm <conflicted_files>", then run "git rebase --continue".
-      ]]></expected_output>
-    </step>
-
-    <step number="3">
-      <description>Check for merge conflicts</description>
-      <tool_use><![CDATA[
-<execute_command>
-<command>git status --porcelain | grep "^UU"</command>
-</execute_command>
-      ]]></tool_use>
-      <expected_output><![CDATA[
-UU src/data/processor.ts
-UU src/data/processor.test.ts
-      ]]></expected_output>
-      <analysis>
-        Two files have conflicts: the main processor file and its test file.
-        Both need to be resolved before continuing the rebase.
-      </analysis>
-    </step>
-
-    <step number="4">
-      <description>Examine the conflicted processor file</description>
-      <tool_use><![CDATA[
-<read_file>
-<path>src/data/processor.ts</path>
-</read_file>
-      ]]></tool_use>
-      <expected_output><![CDATA[
-45 | export class DataProcessor {
-46 |   private listeners: Map<string, EventListener> = new Map();
-47 | 
-48 | <<<<<<< HEAD
-49 |   async processData(data: DataInput): Promise<ProcessedData> {
-50 |     // Refactored to use async/await
-51 |     const result = await this.transform(data);
-52 |     return result;
-53 |   }
-54 | =======
-55 |   processData(data: any[]): ProcessedData {
-56 |     const listener = this.createListener();
-57 |     this.listeners.set(data.id, listener);
-58 |     
-59 |     return this.transform(data);
-60 |   }
-61 | >>>>>>> abc123 (Fix memory leak in data processor)
-62 | 
-63 |   cleanup() {
-64 | <<<<<<< HEAD
-65 |     // TODO: Implement cleanup
-66 | =======
-67 |     // Fix: Clear all listeners to prevent memory leak
-68 |     this.listeners.forEach(listener => {
-69 |       listener.removeAllListeners();
-70 |     });
-71 |     this.listeners.clear();
-72 | >>>>>>> abc123 (Fix memory leak in data processor)
-73 |   }
-74 | }
-      ]]></expected_output>
-    </step>
-
-    <step number="5">
-      <description>Analyze the conflicts using git blame</description>
-      <tool_use><![CDATA[
-<execute_command>
-<command>git blame -L 49,53 HEAD -- src/data/processor.ts | cut -d' ' -f1 | sort -u | xargs -I {} git log -1 --format="%h %s" {}</command>
-</execute_command>
-      ]]></tool_use>
-      <expected_output><![CDATA[
-def456 Refactor: Convert processData to async/await pattern
-      ]]></expected_output>
-      
-      <tool_use><![CDATA[
-<execute_command>
-<command>git log -1 --format="%h %s" abc123</command>
-</execute_command>
-      ]]></tool_use>
-      <expected_output><![CDATA[
-abc123 Fix: Add listener cleanup to prevent memory leak
-      ]]></expected_output>
-      
-      <analysis>
-        HEAD (main after rebase): Has async/await refactor but missing listener logic
-        Incoming (bugfix branch): Adds listener tracking and cleanup for memory leak fix
-        
-        Resolution strategy: Combine both changes - keep async/await refactor
-        but include the listener tracking and cleanup logic.
-      </analysis>
-    </step>
-
-    <step number="6">
-      <description>Resolve the conflicts</description>
-      <tool_use><![CDATA[
-<apply_diff>
-<path>src/data/processor.ts</path>
-<diff>
-<<<<<<< SEARCH
-:start_line:48
--------
-\<<<<<<< HEAD
-  async processData(data: DataInput): Promise<ProcessedData> {
-    // Refactored to use async/await
-    const result = await this.transform(data);
-    return result;
-  }
-\=======
-  processData(data: any[]): ProcessedData {
-    const listener = this.createListener();
-    this.listeners.set(data.id, listener);
-    
-    return this.transform(data);
-  }
-\>>>>>>> abc123 (Fix memory leak in data processor)
-=======
-  async processData(data: DataInput): Promise<ProcessedData> {
-    // Create and track listener for cleanup (memory leak fix)
-    const listener = this.createListener();
-    this.listeners.set(data.id, listener);
-    
-    // Refactored to use async/await
-    const result = await this.transform(data);
-    return result;
-  }
->>>>>>> REPLACE
-
-<<<<<<< SEARCH
-:start_line:63
--------
-  cleanup() {
-\<<<<<<< HEAD
-    // TODO: Implement cleanup
-\=======
-    // Fix: Clear all listeners to prevent memory leak
-    this.listeners.forEach(listener => {
-      listener.removeAllListeners();
-    });
-    this.listeners.clear();
-\>>>>>>> abc123 (Fix memory leak in data processor)
-  }
-=======
-  cleanup() {
-    // Fix: Clear all listeners to prevent memory leak
-    this.listeners.forEach(listener => {
-      listener.removeAllListeners();
-    });
-    this.listeners.clear();
-  }
->>>>>>> REPLACE
-</diff>
-</apply_diff>
-      ]]></tool_use>
-      <explanation>
-        Combined both changes: kept the async/await refactor from main
-        while preserving the memory leak fix (listener tracking and cleanup)
-        from the bugfix branch.
-      </explanation>
-    </step>
-
-    <step number="7">
-      <description>Resolve test file conflicts</description>
-      <tool_use><![CDATA[
-<read_file>
-<path>src/data/processor.test.ts</path>
-</read_file>
-      ]]></tool_use>
-      <!-- Similar process for test file -->
-      <tool_use><![CDATA[
-<apply_diff>
-<path>src/data/processor.test.ts</path>
-<diff>
-<!-- Test resolution would go here -->
-</diff>
-</apply_diff>
-      ]]></tool_use>
-    </step>
-
-    <step number="8">
-      <description>Stage resolved files and continue rebase</description>
-      <tool_use><![CDATA[
-<execute_command>
-<command>git add src/data/processor.ts src/data/processor.test.ts</command>
-</execute_command>
-      ]]></tool_use>
-      
-      <tool_use><![CDATA[
-<execute_command>
-<command>git rebase --continue</command>
-</execute_command>
-      ]]></tool_use>
-      <expected_output><![CDATA[
-[detached HEAD def789] Fix memory leak in data processor
- 2 files changed, 12 insertions(+), 2 deletions(-)
-Successfully rebased and updated refs/heads/fix/memory-leak.
-      ]]></expected_output>
-    </step>
-
-    <step number="9">
-      <description>Final validation</description>
-      <tool_use><![CDATA[
-<execute_command>
-<command>git status</command>
-</execute_command>
-      ]]></tool_use>
-      <expected_output><![CDATA[
-On branch fix/memory-leak
-Your branch is ahead of 'origin/fix/memory-leak' by 1 commit.
-  (use "git push" to publish your local commits)
-
-nothing to commit, working tree clean
-      ]]></expected_output>
-      
-      <tool_use><![CDATA[
-<execute_command>
-<command>git diff origin/main --stat</command>
-</execute_command>
-      ]]></tool_use>
-      <expected_output><![CDATA[
- src/data/processor.ts      | 8 ++++++--
- src/data/processor.test.ts | 4 ++--
- 2 files changed, 8 insertions(+), 4 deletions(-)
-      ]]></expected_output>
-    </step>
-  </workflow>
-
-  <completion><![CDATA[
-<attempt_completion>
-<result>
-Successfully resolved merge conflicts for PR #123 "Fix memory leak in data processor".
-
-Resolution Summary:
-- src/data/processor.ts: Combined the async/await refactor with the memory leak fix by preserving listener tracking and cleanup logic within the refactored async method
-- src/data/processor.test.ts: Updated tests to work with the async implementation while maintaining memory leak test coverage
-
-Both the feature refactor and the critical bugfix have been preserved in the resolution. The rebase has been completed successfully and the branch is ready to be pushed.
-</result>
-</attempt_completion>
-  ]]></completion>
-
-  <key_takeaways>
-    <takeaway>Always checkout PR with --force and rebase to reveal conflicts</takeaway>
-    <takeaway>Fetch PR context to understand the intent of changes</takeaway>
-    <takeaway>Use git blame and commit messages to understand the history</takeaway>
-    <takeaway>Combine non-conflicting improvements when possible</takeaway>
-    <takeaway>Prioritize bugfixes while accommodating refactors</takeaway>
-    <takeaway>Complete the rebase process with git rebase --continue</takeaway>
-    <takeaway>Validate that both sets of changes work together</takeaway>
-  </key_takeaways>
-</merge_resolver_example>
\ No newline at end of file
diff --git a/.roo/rules-merge-resolver/5_communication.xml b/.roo/rules-merge-resolver/5_communication.xml
deleted file mode 100644
index 18594d526..000000000
--- a/.roo/rules-merge-resolver/5_communication.xml
+++ /dev/null
@@ -1,153 +0,0 @@
-<merge_resolver_communication>
-  <tone_and_style>
-    <principle>Be direct and technical when explaining resolution decisions</principle>
-    <principle>Focus on the rationale behind each conflict resolution</principle>
-    <principle>Provide clear summaries of what was merged and why</principle>
-    
-    <avoid>
-      <phrase>I'll help you resolve these conflicts...</phrase>
-      <phrase>Let me handle this for you...</phrase>
-      <phrase>Don't worry about the conflicts...</phrase>
-    </avoid>
-    
-    <prefer>
-      <phrase>Analyzing PR #123 for merge conflicts...</phrase>
-      <phrase>Resolving conflicts based on commit history analysis...</phrase>
-      <phrase>Applied resolution strategy: [specific strategy]</phrase>
-    </prefer>
-  </tone_and_style>
-
-  <initial_response>
-    <structure>
-      <element>Acknowledge the PR number</element>
-      <element>State that you're fetching PR information</element>
-      <element>Indicate the analysis will begin</element>
-    </structure>
-    
-    <example>
-      Fetching information for PR #123 to understand the context and identify merge conflicts...
-    </example>
-  </initial_response>
-
-  <progress_updates>
-    <when>During each major phase of resolution</when>
-    <format>
-      <update>Analyzing [X] conflicted files...</update>
-      <update>Running git blame on [file] to understand change history...</update>
-      <update>Resolving conflicts in [file] by [strategy]...</update>
-      <update>Validating resolved changes...</update>
-    </format>
-    
-    <include_details>
-      <detail>Number of conflicts found</detail>
-      <detail>Files being processed</detail>
-      <detail>Resolution strategy being applied</detail>
-    </include_details>
-  </progress_updates>
-
-  <conflict_explanations>
-    <guideline>Explain each significant resolution decision</guideline>
-    <guideline>Reference specific commits when relevant</guideline>
-    <guideline>Justify why certain changes were kept or merged</guideline>
-    
-    <format>
-      <explanation>
-        Conflict in [file]:
-        - HEAD: [brief description of changes]
-        - Incoming: [brief description of changes]
-        - Resolution: [what was decided and why]
-      </explanation>
-    </format>
-  </conflict_explanations>
-
-  <error_handling>
-    <scenario name="no_pr_number">
-      <response>
-        Expected a PR number (e.g., "#123" or "123"). Please provide the PR number to resolve conflicts for.
-      </response>
-    </scenario>
-    
-    <scenario name="no_conflicts">
-      <response>
-        PR #[number] does not have any merge conflicts. The branch can be merged without conflict resolution.
-      </response>
-    </scenario>
-    
-    <scenario name="pr_not_found">
-      <response>
-        Could not find PR #[number]. Please verify the PR number and ensure you have access to the repository.
-      </response>
-    </scenario>
-    
-    <scenario name="complex_conflicts">
-      <response>
-        Found complex conflicts in [file] that require careful analysis. Examining commit history to determine the best resolution strategy...
-      </response>
-    </scenario>
-  </error_handling>
-
-  <completion_messages>
-    <structure>
-      <element>State that conflicts are resolved</element>
-      <element>Provide resolution summary</element>
-      <element>List files that were resolved</element>
-      <element>Mention key decisions made</element>
-    </structure>
-    
-    <template><![CDATA[
-Successfully resolved merge conflicts for PR #[number] "[title]".
-
-Resolution Summary:
-- [file1]: [brief description of resolution]
-- [file2]: [brief description of resolution]
-
-[Key decision explanation if applicable]
-
-All conflicts have been resolved and files have been staged for commit.
-    ]]></template>
-    
-    <avoid>
-      <element>Questions about next steps</element>
-      <element>Offers to do additional work</element>
-      <element>Uncertain language about the resolution</element>
-    </avoid>
-  </completion_messages>
-
-  <decision_documentation>
-    <principle>Document why specific resolutions were chosen</principle>
-    <principle>Reference commit SHAs when they influenced decisions</principle>
-    <principle>Explain trade-offs when both sides had valid changes</principle>
-    
-    <examples>
-      <example>
-        Preserved bugfix from commit abc123 while adapting it to the refactored structure from def456
-      </example>
-      <example>
-        Combined both implementations as they addressed different aspects of the same feature
-      </example>
-      <example>
-        Chose the more recent implementation as it included additional error handling
-      </example>
-    </examples>
-  </decision_documentation>
-
-  <special_cases>
-    <case name="binary_files">
-      <message>
-        Binary file conflict in [file]. Based on PR intent "[title]", choosing [which version] version.
-      </message>
-    </case>
-    
-    <case name="deleted_vs_modified">
-      <message>
-        Conflict: [file] was deleted in one branch but modified in another. Based on the changes, [keeping/removing] the file because [reason].
-      </message>
-    </case>
-    
-    <case name="whitespace_only">
-      <message>
-        Conflict in [file] involves only whitespace/formatting. Applying consistent formatting from [which] branch.
-      </message>
-    </case>
-  </special_cases>
-</merge_resolver_communication>
\ No newline at end of file
diff --git a/.roo/rules-mode-writer/1_mode_creation_workflow.xml b/.roo/rules-mode-writer/1_mode_creation_workflow.xml
deleted file mode 100644
index 77a172859..000000000
--- a/.roo/rules-mode-writer/1_mode_creation_workflow.xml
+++ /dev/null
@@ -1,301 +0,0 @@
-<mode_management_workflow>
-  <overview>
-    This workflow guides you through creating new custom modes or editing existing modes
-    for the Roo Code Software, ensuring comprehensive understanding and cohesive implementation.
-  </overview>
-
-  <initial_determination>
-    <step number="1">
-      <title>Determine User Intent</title>
-      <description>
-        Identify whether the user wants to create a new mode or edit an existing one
-      </description>
-      <detection_patterns>
-        <pattern type="edit_existing">
-          <indicators>
-            <indicator>User mentions a specific mode by name or slug</indicator>
-            <indicator>User references a mode directory path (e.g., .roo/rules-[mode-slug])</indicator>
-            <indicator>User asks to modify, update, enhance, or fix an existing mode</indicator>
-            <indicator>User says "edit this mode" or "change this mode"</indicator>
-          </indicators>
-        </pattern>
-        <pattern type="create_new">
-          <indicators>
-            <indicator>User asks to create a new mode</indicator>
-            <indicator>User describes a new capability not covered by existing modes</indicator>
-            <indicator>User says "make a mode for" or "create a mode that"</indicator>
-          </indicators>
-        </pattern>
-      </detection_patterns>
-      <clarification_question>
-        <ask_followup_question>
-          <question>I want to make sure I understand correctly. Are you looking to create a brand new mode or modify an existing one?</question>
-          <follow_up>
-            <suggest>Create a new mode for a specific purpose</suggest>
-            <suggest>Edit an existing mode to add new capabilities</suggest>
-            <suggest>Fix issues in an existing mode</suggest>
-            <suggest>Enhance an existing mode with better workflows</suggest>
-          </follow_up>
-        </ask_followup_question>
-      </clarification_question>
-    </step>
-  </initial_determination>
-
-  <workflow_branches>
-    <branch name="create_new_mode">
-      <step number="2a">
-        <title>Gather Requirements for New Mode</title>
-        <description>
-          Understand what the user wants the new mode to accomplish
-        </description>
-        <actions>
-          <action>Ask about the mode's primary purpose and use cases</action>
-          <action>Identify what types of tasks the mode should handle</action>
-          <action>Determine what tools and file access the mode needs</action>
-          <action>Clarify any special behaviors or restrictions</action>
-        </actions>
-        <example>
-          <ask_followup_question>
-            <question>What is the primary purpose of this new mode? What types of tasks should it handle?</question>
-            <follow_up>
-              <suggest>A mode for writing and maintaining documentation</suggest>
-              <suggest>A mode for database schema design and migrations</suggest>
-              <suggest>A mode for API endpoint development and testing</suggest>
-              <suggest>A mode for performance optimization and profiling</suggest>
-            </follow_up>
-          </ask_followup_question>
-        </example>
-      </step>
-
-      <step number="3a">
-        <title>Design Mode Configuration</title>
-        <description>
-          Create the mode definition with all required fields
-        </description>
-        <required_fields>
-          <field name="slug">
-            <description>Unique identifier (lowercase, hyphens allowed)</description>
-            <best_practice>Keep it short and descriptive (e.g., "api-dev", "docs-writer")</best_practice>
-          </field>
-          <field name="name">
-            <description>Display name with optional emoji</description>
-            <best_practice>Use an emoji that represents the mode's purpose</best_practice>
-          </field>
-          <field name="roleDefinition">
-            <description>Detailed description of the mode's role and expertise</description>
-            <best_practice>
-              Start with "You are Roo Code, a [specialist type]..."
-              List specific areas of expertise
-              Mention key technologies or methodologies
-            </best_practice>
-          </field>
-          <field name="groups">
-            <description>Tool groups the mode can access</description>
-            <options>
-              <option name="read">File reading and searching tools</option>
-              <option name="edit">File editing tools (can be restricted by regex)</option>
-              <option name="command">Command execution tools</option>
-              <option name="browser">Browser interaction tools</option>
-              <option name="mcp">MCP server tools</option>
-            </options>
-          </field>
-        </required_fields>
-        <recommended_fields>
-          <field name="whenToUse">
-            <description>Clear description for the Orchestrator</description>
-            <best_practice>Explain specific scenarios and task types</best_practice>
-          </field>
-        </recommended_fields>
-        <important_note>
-          Do not include customInstructions in the .roomodes configuration.
-          All detailed instructions should be placed in XML files within
-          the .roo/rules-[mode-slug]/ directory instead.
-        </important_note>
-      </step>
-
-      <step number="4a">
-        <title>Implement File Restrictions</title>
-        <description>
-          Configure appropriate file access permissions
-        </description>
-        <example>
-          <comment>Restrict edit access to specific file types</comment>
-          <code>
-groups:
-  - read
-  - - edit
-    - fileRegex: \.(md|txt|rst)$
-      description: Documentation files only
-  - command
-          </code>
-        </example>
-        <guidelines>
-          <guideline>Use regex patterns to limit file editing scope</guideline>
-          <guideline>Provide clear descriptions for restrictions</guideline>
-          <guideline>Consider the principle of least privilege</guideline>
-        </guidelines>
-      </step>
-
-      <step number="5a">
-        <title>Create XML Instruction Files</title>
-        <description>
-          Design structured instruction files in .roo/rules-[mode-slug]/
-        </description>
-        <file_structure>
-          <file name="1_workflow.xml">Main workflow and step-by-step processes</file>
-          <file name="2_best_practices.xml">Guidelines and conventions</file>
-          <file name="3_common_patterns.xml">Reusable code patterns and examples</file>
-          <file name="4_tool_usage.xml">Specific tool usage instructions</file>
-          <file name="5_examples.xml">Complete workflow examples</file>
-        </file_structure>
-        <xml_best_practices>
-          <practice>Use semantic tag names that describe content</practice>
-          <practice>Nest tags hierarchically for better organization</practice>
-          <practice>Include code examples in CDATA sections when needed</practice>
-          <practice>Add comments to explain complex sections</practice>
-        </xml_best_practices>
-      </step>
-    </branch>
-
-    <branch name="edit_existing_mode">
-      <step number="2b">
-        <title>Immerse in Existing Mode</title>
-        <description>
-          Fully understand the existing mode before making any changes
-        </description>
-        <actions>
-          <action>Locate and read the mode configuration in .roomodes</action>
-          <action>Read all XML instruction files in .roo/rules-[mode-slug]/</action>
-          <action>Analyze the mode's current capabilities and limitations</action>
-          <action>Understand the mode's role in the broader ecosystem</action>
-        </actions>
-        <questions_to_ask>
-          <ask_followup_question>
-            <question>What specific aspects of the mode would you like to change or enhance?</question>
-            <follow_up>
-              <suggest>Add new capabilities or tool permissions</suggest>
-              <suggest>Fix issues with current workflows or instructions</suggest>
-              <suggest>Improve the mode's roleDefinition or whenToUse description</suggest>
-              <suggest>Enhance XML instructions for better clarity</suggest>
-            </follow_up>
-          </ask_followup_question>
-        </questions_to_ask>
-      </step>
-
-      <step number="3b">
-        <title>Analyze Change Impact</title>
-        <description>
-          Understand how proposed changes will affect the mode
-        </description>
-        <analysis_areas>
-          <area>Compatibility with existing workflows</area>
-          <area>Impact on file permissions and tool access</area>
-          <area>Consistency with mode's core purpose</area>
-          <area>Integration with other modes</area>
-        </analysis_areas>
-        <validation_questions>
-          <ask_followup_question>
-            <question>I've analyzed the existing mode. Here's what I understand about your requested changes. Is this correct?</question>
-            <follow_up>
-              <suggest>Yes, that's exactly what I want to change</suggest>
-              <suggest>Mostly correct, but let me clarify some details</suggest>
-              <suggest>No, I meant something different</suggest>
-              <suggest>I'd like to add additional changes</suggest>
-            </follow_up>
-          </ask_followup_question>
-        </validation_questions>
-      </step>
-
-      <step number="4b">
-        <title>Plan Modifications</title>
-        <description>
-          Create a detailed plan for modifying the mode
-        </description>
-        <planning_steps>
-          <step>Identify which files need to be modified</step>
-          <step>Determine if new XML instruction files are needed</step>
-          <step>Check for potential conflicts or contradictions</step>
-          <step>Plan the order of changes for minimal disruption</step>
-        </planning_steps>
-      </step>
-
-      <step number="5b">
-        <title>Implement Changes</title>
-        <description>
-          Apply the planned modifications to the mode
-        </description>
-        <implementation_order>
-          <change>Update .roomodes configuration if needed</change>
-          <change>Modify existing XML instruction files</change>
-          <change>Create new XML instruction files if required</change>
-          <change>Update examples and documentation</change>
-        </implementation_order>
-      </step>
-    </branch>
-  </workflow_branches>
-
-  <validation_and_cohesion>
-    <step number="6">
-      <title>Validate Cohesion and Consistency</title>
-      <description>
-        Ensure all changes are cohesive and don't contradict each other
-      </description>
-      <validation_checks>
-        <check type="configuration">
-          <item>Mode slug follows naming conventions</item>
-          <item>File restrictions align with mode purpose</item>
-          <item>Tool permissions are appropriate</item>
-          <item>whenToUse clearly differentiates from other modes</item>
-        </check>
-        <check type="instructions">
-          <item>All XML files follow consistent structure</item>
-          <item>No contradicting instructions between files</item>
-          <item>Examples align with stated workflows</item>
-          <item>Tool usage matches granted permissions</item>
-        </check>
-        <check type="integration">
-          <item>Mode integrates well with Orchestrator</item>
-          <item>Clear boundaries with other modes</item>
-          <item>Handoff points are well-defined</item>
-        </check>
-      </validation_checks>
-      <cohesion_questions>
-        <ask_followup_question>
-          <question>I've completed the validation checks. Would you like me to review any specific aspect in more detail?</question>
-          <follow_up>
-            <suggest>Review the file permission patterns</suggest>
-            <suggest>Check for workflow contradictions</suggest>
-            <suggest>Verify integration with other modes</suggest>
-            <suggest>Everything looks good, proceed to testing</suggest>
-          </follow_up>
-        </ask_followup_question>
-      </cohesion_questions>
-    </step>
-
-    <step number="7">
-      <title>Test and Refine</title>
-      <description>
-        Verify the mode works as intended
-      </description>
-      <checklist>
-        <item>Mode appears in the mode list</item>
-        <item>File restrictions work correctly</item>
-        <item>Instructions are clear and actionable</item>
-        <item>Mode integrates well with Orchestrator</item>
-        <item>All examples are accurate and helpful</item>
-        <item>Changes don't break existing functionality (for edits)</item>
-        <item>New capabilities work as expected</item>
-      </checklist>
-    </step>
-  </validation_and_cohesion>
-
-  <quick_reference>
-    <command>Create mode in .roomodes for project-specific modes</command>
-    <command>Create mode in global custom_modes.yaml for system-wide modes</command>
-    <command>Use list_files to verify .roo folder structure</command>
-    <command>Test file regex patterns with search_files</command>
-    <command>Use codebase_search to find existing mode implementations</command>
-    <command>Read all XML files in a mode directory to understand its structure</command>
-    <command>Always validate changes for cohesion and consistency</command>
-  </quick_reference>
-</mode_management_workflow>
\ No newline at end of file
diff --git a/.roo/rules-mode-writer/2_xml_structuring_best_practices.xml b/.roo/rules-mode-writer/2_xml_structuring_best_practices.xml
deleted file mode 100644
index 639f855c0..000000000
--- a/.roo/rules-mode-writer/2_xml_structuring_best_practices.xml
+++ /dev/null
@@ -1,220 +0,0 @@
-<xml_structuring_best_practices>
-  <overview>
-    XML tags help Claude parse prompts more accurately, leading to higher-quality outputs.
-    This guide covers best practices for structuring mode instructions using XML.
-  </overview>
-
-  <why_use_xml_tags>
-    <benefit type="clarity">
-      Clearly separate different parts of your instructions and ensure well-structured content
-    </benefit>
-    <benefit type="accuracy">
-      Reduce errors caused by Claude misinterpreting parts of your instructions
-    </benefit>
-    <benefit type="flexibility">
-      Easily find, add, remove, or modify parts of instructions without rewriting everything
-    </benefit>
-    <benefit type="parseability">
-      Having Claude use XML tags in its output makes it easier to extract specific parts of responses
-    </benefit>
-  </why_use_xml_tags>
-
-  <core_principles>
-    <principle name="consistency">
-      <description>Use the same tag names throughout your instructions</description>
-      <example>
-        Always use <step> for workflow steps, not sometimes <action> or <task>
-      </example>
-    </principle>
-    
-    <principle name="semantic_naming">
-      <description>Tag names should clearly describe their content</description>
-      <good_examples>
-        <tag>detailed_steps</tag>
-        <tag>error_handling</tag>
-        <tag>validation_rules</tag>
-      </good_examples>
-      <bad_examples>
-        <tag>stuff</tag>
-        <tag>misc</tag>
-        <tag>data1</tag>
-      </bad_examples>
-    </principle>
-
-    <principle name="hierarchical_nesting">
-      <description>Nest tags to show relationships and structure</description>
-      <example>
-        <workflow>
-          <phase name="preparation">
-            <step>Gather requirements</step>
-            <step>Validate inputs</step>
-          </phase>
-          <phase name="execution">
-            <step>Process data</step>
-            <step>Generate output</step>
-          </phase>
-        </workflow>
-      </example>
-    </principle>
-  </core_principles>
-
-  <common_tag_patterns>
-    <pattern name="workflow_structure">
-      <usage>For step-by-step processes</usage>
-      <template><![CDATA[
-<workflow>
-  <overview>High-level description</overview>
-  <prerequisites>
-    <prerequisite>Required condition 1</prerequisite>
-    <prerequisite>Required condition 2</prerequisite>
-  </prerequisites>
-  <steps>
-    <step number="1">
-      <title>Step Title</title>
-      <description>What this step accomplishes</description>
-      <actions>
-        <action>Specific action to take</action>
-      </actions>
-      <validation>How to verify success</validation>
-    </step>
-  </steps>
-</workflow>
-      ]]></template>
-    </pattern>
-
-    <pattern name="examples_structure">
-      <usage>For providing code examples and demonstrations</usage>
-      <template><![CDATA[
-<examples>
-  <example name="descriptive_name">
-    <description>What this example demonstrates</description>
-    <context>When to use this approach</context>
-    <code language="typescript">
-      // Your code example here
-    </code>
-    <explanation>
-      Key points about the implementation
-    </explanation>
-  </example>
-</examples>
-      ]]></template>
-    </pattern>
-
-    <pattern name="guidelines_structure">
-      <usage>For rules and best practices</usage>
-      <template><![CDATA[
-<guidelines category="category_name">
-  <guideline priority="high">
-    <rule>The specific rule or guideline</rule>
-    <rationale>Why this is important</rationale>
-    <exceptions>When this doesn't apply</exceptions>
-  </guideline>
-</guidelines>
-      ]]></template>
-    </pattern>
-
-    <pattern name="tool_usage_structure">
-      <usage>For documenting how to use specific tools</usage>
-      <template><![CDATA[
-<tool_usage tool="tool_name">
-  <purpose>What this tool accomplishes</purpose>
-  <when_to_use>Specific scenarios for this tool</when_to_use>
-  <syntax>
-    <command>The exact command format</command>
-    <parameters>
-      <parameter name="param1" required="true">
-        <description>What this parameter does</description>
-        <type>string|number|boolean</type>
-        <example>example_value</example>
-      </parameter>
-    </parameters>
-  </syntax>
-  <examples>
-    <example scenario="common_use_case">
-      <code>Actual usage example</code>
-      <output>Expected output</output>
-    </example>
-  </examples>
-</tool_usage>
-      ]]></template>
-    </pattern>
-  </common_tag_patterns>
-
-  <formatting_guidelines>
-    <guideline name="indentation">
-      Use consistent indentation (2 or 4 spaces) for nested elements
-    </guideline>
-    <guideline name="line_breaks">
-      Add line breaks between major sections for readability
-    </guideline>
-    <guideline name="comments">
-      Use XML comments <!-- like this --> to explain complex sections
-    </guideline>
-    <guideline name="cdata_sections">
-      Use CDATA for code blocks or content with special characters:
-      <![CDATA[<code><![CDATA[your code here]]></code>]]>
-    </guideline>
-    <guideline name="attributes_vs_elements">
-      Use attributes for metadata, elements for content:
-      <example type="good">
-        <step number="1" priority="high">
-          <description>The actual step content</description>
-        </step>
-      </example>
-    </guideline>
-  </formatting_guidelines>
-
-  <anti_patterns>
-    <anti_pattern name="flat_structure">
-      <description>Avoid completely flat structures without hierarchy</description>
-      <bad><![CDATA[
-<instructions>
-<item1>Do this</item1>
-<item2>Then this</item2>
-<item3>Finally this</item3>
-</instructions>
-      ]]></bad>
-      <good><![CDATA[
-<instructions>
-  <steps>
-    <step order="1">Do this</step>
-    <step order="2">Then this</step>
-    <step order="3">Finally this</step>
-  </steps>
-</instructions>
-      ]]></good>
-    </anti_pattern>
-
-    <anti_pattern name="inconsistent_naming">
-      <description>Don't mix naming conventions</description>
-      <bad>
-        Mixing camelCase, snake_case, and kebab-case in tag names
-      </bad>
-      <good>
-        Pick one convention (preferably snake_case for XML) and stick to it
-      </good>
-    </anti_pattern>
-
-    <anti_pattern name="overly_generic_tags">
-      <description>Avoid tags that don't convey meaning</description>
-      <bad>data, info, stuff, thing, item</bad>
-      <good>user_input, validation_result, error_message, configuration</good>
-    </anti_pattern>
-  </anti_patterns>
-
-  <integration_tips>
-    <tip>
-      Reference XML content in instructions:
-      "Using the workflow defined in &lt;workflow&gt; tags..."
-    </tip>
-    <tip>
-      Combine XML structure with other techniques like multishot prompting
-    </tip>
-    <tip>
-      Use XML tags in expected outputs to make parsing easier
-    </tip>
-    <tip>
-      Create reusable XML templates for common patterns
-    </tip>
-  </integration_tips>
-</xml_structuring_best_practices>
\ No newline at end of file
diff --git a/.roo/rules-mode-writer/3_mode_configuration_patterns.xml b/.roo/rules-mode-writer/3_mode_configuration_patterns.xml
deleted file mode 100644
index 82a5f845a..000000000
--- a/.roo/rules-mode-writer/3_mode_configuration_patterns.xml
+++ /dev/null
@@ -1,261 +0,0 @@
-<mode_configuration_patterns>
-  <overview>
-    Common patterns and templates for creating different types of modes, with examples from existing modes in the Roo-Code software.
-  </overview>
-
-  <mode_types>
-    <type name="specialist_mode">
-      <description>
-        Modes focused on specific technical domains or tasks
-      </description>
-      <characteristics>
-        <characteristic>Deep expertise in a particular area</characteristic>
-        <characteristic>Restricted file access based on domain</characteristic>
-        <characteristic>Specialized tool usage patterns</characteristic>
-      </characteristics>
-      <example_template><![CDATA[
-- slug: api-specialist
-  name: 🔌 API Specialist
-  roleDefinition: >-
-    You are Roo Code, an API development specialist with expertise in:
-    - RESTful API design and implementation
-    - GraphQL schema design
-    - API documentation with OpenAPI/Swagger
-    - Authentication and authorization patterns
-    - Rate limiting and caching strategies
-    - API versioning and deprecation
-    
-    You ensure APIs are:
-    - Well-documented and discoverable
-    - Following REST principles or GraphQL best practices
-    - Secure and performant
-    - Properly versioned and maintainable
-  whenToUse: >-
-    Use this mode when designing, implementing, or refactoring APIs.
-    This includes creating new endpoints, updating API documentation,
-    implementing authentication, or optimizing API performance.
-  groups:
-    - read
-    - - edit
-      - fileRegex: (api/.*\.(ts|js)|.*\.openapi\.yaml|.*\.graphql|docs/api/.*)$
-        description: API implementation files, OpenAPI specs, and API documentation
-    - command
-    - mcp
-      ]]></example_template>
-    </type>
-
-    <type name="workflow_mode">
-      <description>
-        Modes that guide users through multi-step processes
-      </description>
-      <characteristics>
-        <characteristic>Step-by-step workflow guidance</characteristic>
-        <characteristic>Heavy use of ask_followup_question</characteristic>
-        <characteristic>Process validation at each step</characteristic>
-      </characteristics>
-      <example_template><![CDATA[
-- slug: migration-guide
-  name: 🔄 Migration Guide
-  roleDefinition: >-
-    You are Roo Code, a migration specialist who guides users through
-    complex migration processes:
-    - Database schema migrations
-    - Framework version upgrades
-    - API version migrations
-    - Dependency updates
-    - Breaking change resolutions
-    
-    You provide:
-    - Step-by-step migration plans
-    - Automated migration scripts
-    - Rollback strategies
-    - Testing approaches for migrations
-  whenToUse: >-
-    Use this mode when performing any kind of migration or upgrade.
-    This mode will analyze the current state, plan the migration,
-    and guide you through each step with validation.
-  groups:
-    - read
-    - edit
-    - command
-      ]]></example_template>
-    </type>
-
-    <type name="analysis_mode">
-      <description>
-        Modes focused on code analysis and reporting
-      </description>
-      <characteristics>
-        <characteristic>Read-heavy operations</characteristic>
-        <characteristic>Limited or no edit permissions</characteristic>
-        <characteristic>Comprehensive reporting outputs</characteristic>
-      </characteristics>
-      <example_template><![CDATA[
-- slug: security-auditor
-  name: 🔒 Security Auditor
-  roleDefinition: >-
-    You are Roo Code, a security analysis specialist focused on:
-    - Identifying security vulnerabilities
-    - Analyzing authentication and authorization
-    - Reviewing data validation and sanitization
-    - Checking for common security anti-patterns
-    - Evaluating dependency vulnerabilities
-    - Assessing API security
-    
-    You provide detailed security reports with:
-    - Vulnerability severity ratings
-    - Specific remediation steps
-    - Security best practice recommendations
-  whenToUse: >-
-    Use this mode to perform security audits on codebases.
-    This mode will analyze code for vulnerabilities, check
-    dependencies, and provide actionable security recommendations.
-  groups:
-    - read
-    - command
-    - - edit
-      - fileRegex: (SECURITY\.md|\.github/security/.*|docs/security/.*)$
-        description: Security documentation files only
-      ]]></example_template>
-    </type>
-
-    <type name="creative_mode">
-      <description>
-        Modes for generating new content or features
-      </description>
-      <characteristics>
-        <characteristic>Broad file creation permissions</characteristic>
-        <characteristic>Template and boilerplate generation</characteristic>
-        <characteristic>Interactive design process</characteristic>
-      </characteristics>
-      <example_template><![CDATA[
-- slug: component-designer
-  name: 🎨 Component Designer
-  roleDefinition: >-
-    You are Roo Code, a UI component design specialist who creates:
-    - Reusable React/Vue/Angular components
-    - Component documentation and examples
-    - Storybook stories
-    - Unit tests for components
-    - Accessibility-compliant interfaces
-    
-    You follow design system principles and ensure components are:
-    - Highly reusable and composable
-    - Well-documented with examples
-    - Fully tested
-    - Accessible (WCAG compliant)
-    - Performance optimized
-  whenToUse: >-
-    Use this mode when creating new UI components or refactoring
-    existing ones. This mode helps design component APIs, implement
-    the components, and create comprehensive documentation.
-  groups:
-    - read
-    - - edit
-      - fileRegex: (components/.*|stories/.*|__tests__/.*\.test\.(tsx?|jsx?))$
-        description: Component files, stories, and component tests
-    - browser
-    - command
-      ]]></example_template>
-    </type>
-  </mode_types>
-
-  <permission_patterns>
-    <pattern name="documentation_only">
-      <description>For modes that only work with documentation</description>
-      <configuration><![CDATA[
-groups:
-  - read
-  - - edit
-    - fileRegex: \.(md|mdx|rst|txt)$
-      description: Documentation files only
-      ]]></configuration>
-    </pattern>
-
-    <pattern name="test_focused">
-      <description>For modes that work with test files</description>
-      <configuration><![CDATA[
-groups:
-  - read
-  - command
-  - - edit
-    - fileRegex: (__tests__/.*|__mocks__/.*|.*\.test\.(ts|tsx|js|jsx)$|.*\.spec\.(ts|tsx|js|jsx)$)
-      description: Test files and mocks
-      ]]></configuration>
-    </pattern>
-
-    <pattern name="config_management">
-      <description>For modes that manage configuration</description>
-      <configuration><![CDATA[
-groups:
-  - read
-  - - edit
-    - fileRegex: (.*\.config\.(js|ts|json)|.*rc\.json|.*\.yaml|.*\.yml|\.env\.example)$
-      description: Configuration files (not .env)
-      ]]></configuration>
-    </pattern>
-
-    <pattern name="full_stack">
-      <description>For modes that need broad access</description>
-      <configuration><![CDATA[
-groups:
-  - read
-  - edit  # No restrictions
-  - command
-  - browser
-  - mcp
-      ]]></configuration>
-    </pattern>
-  </permission_patterns>
-
-  <naming_conventions>
-    <convention category="slug">
-      <rule>Use lowercase with hyphens</rule>
-      <good>api-dev, test-writer, docs-manager</good>
-      <bad>apiDev, test_writer, DocsManager</bad>
-    </convention>
-    
-    <convention category="name">
-      <rule>Use title case with descriptive emoji</rule>
-      <good>🔧 API Developer, 📝 Documentation Writer</good>
-      <bad>api developer, DOCUMENTATION WRITER</bad>
-    </convention>
-
-    <convention category="emoji_selection">
-      <common_emojis>
-        <emoji meaning="testing">🧪</emoji>
-        <emoji meaning="documentation">📝</emoji>
-        <emoji meaning="design">🎨</emoji>
-        <emoji meaning="debugging">🪲</emoji>
-        <emoji meaning="building">🏗️</emoji>
-        <emoji meaning="security">🔒</emoji>
-        <emoji meaning="api">🔌</emoji>
-        <emoji meaning="database">🗄️</emoji>
-        <emoji meaning="performance">⚡</emoji>
-        <emoji meaning="configuration">⚙️</emoji>
-      </common_emojis>
-    </convention>
-  </naming_conventions>
-
-  <integration_guidelines>
-    <guideline name="orchestrator_compatibility">
-      <description>Ensure whenToUse is clear for Orchestrator mode</description>
-      <checklist>
-        <item>Specify concrete task types the mode handles</item>
-        <item>Include trigger keywords or phrases</item>
-        <item>Differentiate from similar modes</item>
-        <item>Mention specific file types or areas</item>
-      </checklist>
-    </guideline>
-
-    <guideline name="mode_boundaries">
-      <description>Define clear boundaries between modes</description>
-      <checklist>
-        <item>Avoid overlapping responsibilities</item>
-        <item>Make handoff points explicit</item>
-        <item>Use switch_mode when appropriate</item>
-        <item>Document mode interactions</item>
-      </checklist>
-    </guideline>
-  </integration_guidelines>
-</mode_configuration_patterns>
\ No newline at end of file
diff --git a/.roo/rules-mode-writer/4_instruction_file_templates.xml b/.roo/rules-mode-writer/4_instruction_file_templates.xml
deleted file mode 100644
index 3afcfa28f..000000000
--- a/.roo/rules-mode-writer/4_instruction_file_templates.xml
+++ /dev/null
@@ -1,367 +0,0 @@
-<instruction_file_templates>
-  <overview>
-    Templates and examples for creating XML instruction files that provide
-    detailed guidance for each mode's behavior and workflows.
-  </overview>
-
-  <file_organization>
-    <principle>Number files to indicate execution order</principle>
-    <principle>Use descriptive names that indicate content</principle>
-    <principle>Keep related instructions together</principle>
-    <standard_structure>
-      <file>1_workflow.xml - Main workflow and processes</file>
-      <file>2_best_practices.xml - Guidelines and conventions</file>
-      <file>3_common_patterns.xml - Reusable code patterns</file>
-      <file>4_tool_usage.xml - Specific tool instructions</file>
-      <file>5_examples.xml - Complete workflow examples</file>
-      <file>6_error_handling.xml - Error scenarios and recovery</file>
-      <file>7_communication.xml - User interaction guidelines</file>
-    </standard_structure>
-  </file_organization>
-
-  <workflow_file_template>
-    <description>Template for main workflow files (1_workflow.xml)</description>
-    <template><![CDATA[
-<workflow_instructions>
-  <mode_overview>
-    Brief description of what this mode does and its primary purpose
-  </mode_overview>
-
-  <initialization_steps>
-    <step number="1">
-      <action>Understand the user's request</action>
-      <details>
-        Parse the user's input to identify:
-        - Primary objective
-        - Specific requirements
-        - Constraints or limitations
-      </details>
-    </step>
-    
-    <step number="2">
-      <action>Gather necessary context</action>
-      <tools>
-        <tool>codebase_search - Find relevant existing code</tool>
-        <tool>list_files - Understand project structure</tool>
-        <tool>read_file - Examine specific implementations</tool>
-      </tools>
-    </step>
-  </initialization_steps>
-
-  <main_workflow>
-    <phase name="analysis">
-      <description>Analyze the current state and requirements</description>
-      <steps>
-        <step>Identify affected components</step>
-        <step>Assess impact of changes</step>
-        <step>Plan implementation approach</step>
-      </steps>
-    </phase>
-
-    <phase name="implementation">
-      <description>Execute the planned changes</description>
-      <steps>
-        <step>Create/modify necessary files</step>
-        <step>Ensure consistency across codebase</step>
-        <step>Add appropriate documentation</step>
-      </steps>
-    </phase>
-
-    <phase name="validation">
-      <description>Verify the implementation</description>
-      <steps>
-        <step>Check for errors or inconsistencies</step>
-        <step>Validate against requirements</step>
-        <step>Ensure no regressions</step>
-      </steps>
-    </phase>
-  </main_workflow>
-
-  <completion_criteria>
-    <criterion>All requirements have been addressed</criterion>
-    <criterion>Code follows project conventions</criterion>
-    <criterion>Changes are properly documented</criterion>
-    <criterion>No breaking changes introduced</criterion>
-  </completion_criteria>
-</workflow_instructions>
-    ]]></template>
-  </workflow_file_template>
-
-  <best_practices_template>
-    <description>Template for best practices files (2_best_practices.xml)</description>
-    <template><![CDATA[
-<best_practices>
-  <general_principles>
-    <principle priority="high">
-      <name>Principle Name</name>
-      <description>Detailed explanation of the principle</description>
-      <rationale>Why this principle is important</rationale>
-      <example>
-        <scenario>When this applies</scenario>
-        <good>Correct approach</good>
-        <bad>What to avoid</bad>
-      </example>
-    </principle>
-  </general_principles>
-
-  <code_conventions>
-    <convention category="naming">
-      <rule>Specific naming convention</rule>
-      <examples>
-        <good>goodExampleName</good>
-        <bad>bad_example-name</bad>
-      </examples>
-    </convention>
-    
-    <convention category="structure">
-      <rule>How to structure code/files</rule>
-      <template>
-        // Example structure
-      </template>
-    </convention>
-  </code_conventions>
-
-  <common_pitfalls>
-    <pitfall>
-      <description>Common mistake to avoid</description>
-      <why_problematic>Explanation of issues it causes</why_problematic>
-      <correct_approach>How to do it properly</correct_approach>
-    </pitfall>
-  </common_pitfalls>
-
-  <quality_checklist>
-    <category name="before_starting">
-      <item>Understand requirements fully</item>
-      <item>Check existing implementations</item>
-    </category>
-    <category name="during_implementation">
-      <item>Follow established patterns</item>
-      <item>Write clear documentation</item>
-    </category>
-    <category name="before_completion">
-      <item>Review all changes</item>
-      <item>Verify requirements met</item>
-    </category>
-  </quality_checklist>
-</best_practices>
-    ]]></template>
-  </best_practices_template>
-
-  <tool_usage_template>
-    <description>Template for tool usage files (4_tool_usage.xml)</description>
-    <template><![CDATA[
-<tool_usage_guide>
-  <tool_priorities>
-    <priority level="1">
-      <tool>codebase_search</tool>
-      <when>Always use first to find relevant code</when>
-      <why>Semantic search finds functionality better than keywords</why>
-    </priority>
-    <priority level="2">
-      <tool>read_file</tool>
-      <when>After identifying files with codebase_search</when>
-      <why>Get full context of implementations</why>
-    </priority>
-  </tool_priorities>
-
-  <tool_specific_guidance>
-    <tool name="apply_diff">
-      <best_practices>
-        <practice>Always read file first to ensure exact content match</practice>
-        <practice>Make multiple changes in one diff when possible</practice>
-        <practice>Include line numbers for accuracy</practice>
-      </best_practices>
-      <example><![CDATA[
-<apply_diff>
-<path>src/config.ts</path>
-<diff>
-<<<<<<< SEARCH
-:start_line:10
--------
-export const config = {
-  apiUrl: 'http://localhost:3000',
-  timeout: 5000
-};
-=======
-export const config = {
-  apiUrl: process.env.API_URL || 'http://localhost:3000',
-  timeout: parseInt(process.env.TIMEOUT || '5000'),
-  retries: 3
-};
->>>>>>> REPLACE
-</diff>
-</apply_diff>
-      ]]></example>
-    </tool>
-
-    <tool name="ask_followup_question">
-      <best_practices>
-        <practice>Provide 2-4 specific, actionable suggestions</practice>
-        <practice>Order suggestions by likelihood or importance</practice>
-        <practice>Make suggestions complete (no placeholders)</practice>
-      </best_practices>
-      <example><![CDATA[
-<ask_followup_question>
-<question>Which database system should I configure for this project?</question>
-<follow_up>
-<suggest>PostgreSQL with the default configuration</suggest>
-<suggest>MySQL 8.0 with InnoDB storage engine</suggest>
-<suggest>SQLite for local development only</suggest>
-<suggest>MongoDB for document-based storage</suggest>
-</follow_up>
-</ask_followup_question>
-      ]]></example>
-    </tool>
-  </tool_specific_guidance>
-
-  <tool_combination_patterns>
-    <pattern name="explore_then_modify">
-      <sequence>
-        <step>codebase_search - Find relevant files</step>
-        <step>list_code_definition_names - Understand structure</step>
-        <step>read_file - Get full context</step>
-        <step>apply_diff or write_to_file - Make changes</step>
-      </sequence>
-    </pattern>
-    
-    <pattern name="verify_then_proceed">
-      <sequence>
-        <step>list_files - Check file exists</step>
-        <step>read_file - Verify current content</step>
-        <step>ask_followup_question - Confirm approach</step>
-        <step>apply_diff - Implement changes</step>
-      </sequence>
-    </pattern>
-  </tool_combination_patterns>
-</tool_usage_guide>
-    ]]></template>
-  </tool_usage_template>
-
-  <examples_file_template>
-    <description>Template for example files (5_examples.xml)</description>
-    <template><![CDATA[
-<complete_examples>
-  <example name="descriptive_example_name">
-    <scenario>
-      Detailed description of the use case this example covers
-    </scenario>
-    
-    <user_request>
-      The initial request from the user
-    </user_request>
-
-    <workflow>
-      <step number="1">
-        <description>First step description</description>
-        <tool_use><![CDATA[
-<codebase_search>
-<query>search query here</query>
-</codebase_search>
-        ]]></tool_use>
-        <expected_outcome>What we learn from this step</expected_outcome>
-      </step>
-
-      <step number="2">
-        <description>Second step description</description>
-        <tool_use><![CDATA[
-<read_file>
-<path>path/to/file.ts</path>
-</read_file>
-        ]]></tool_use>
-        <analysis>How we interpret the results</analysis>
-      </step>
-
-      <step number="3">
-        <description>Implementation step</description>
-        <tool_use><![CDATA[
-<apply_diff>
-<path>path/to/file.ts</path>
-<diff>
-<<<<<<< SEARCH
-:start_line:1
--------
-original content
-=======
-new content
->>>>>>> REPLACE
-</diff>
-</apply_diff>
-        ]]></tool_use>
-      </step>
-    </workflow>
-
-    <completion><![CDATA[
-<attempt_completion>
-<result>
-Summary of what was accomplished and how it addresses the user's request
-</result>
-</attempt_completion>
-    ]]></completion>
-
-    <key_takeaways>
-      <takeaway>Important lesson from this example</takeaway>
-      <takeaway>Pattern that can be reused</takeaway>
-    </key_takeaways>
-  </example>
-</complete_examples>
-    ]]></template>
-  </examples_file_template>
-
-  <communication_template>
-    <description>Template for communication guidelines (7_communication.xml)</description>
-    <template><![CDATA[
-<communication_guidelines>
-  <tone_and_style>
-    <principle>Be direct and technical, not conversational</principle>
-    <principle>Focus on actions taken and results achieved</principle>
-    <avoid>
-      <phrase>Great! I'll help you with that...</phrase>
-      <phrase>Certainly! Let me...</phrase>
-      <phrase>Sure thing!</phrase>
-    </avoid>
-    <prefer>
-      <phrase>I'll analyze the codebase to...</phrase>
-      <phrase>Implementing the requested changes...</phrase>
-      <phrase>The analysis shows...</phrase>
-    </prefer>
-  </tone_and_style>
-
-  <user_interaction>
-    <when_to_ask_questions>
-      <scenario>Missing critical information</scenario>
-      <scenario>Multiple valid approaches exist</scenario>
-      <scenario>Potential breaking changes</scenario>
-    </when_to_ask_questions>
-    
-    <question_format>
-      <guideline>Be specific about what you need</guideline>
-      <guideline>Provide actionable options</guideline>
-      <guideline>Explain implications of choices</guideline>
-    </question_format>
-  </user_interaction>
-
-  <progress_updates>
-    <when>During long-running operations</when>
-    <format>
-      <update>Analyzing [X] files for [purpose]...</update>
-      <update>Implementing [feature] in [location]...</update>
-      <update>Validating changes against [criteria]...</update>
-    </format>
-  </progress_updates>
-
-  <completion_messages>
-    <structure>
-      <element>What was accomplished</element>
-      <element>Key changes made</element>
-      <element>Any important notes or warnings</element>
-    </structure>
-    <avoid>
-      <element>Questions at the end</element>
-      <element>Offers for further assistance</element>
-      <element>Conversational closings</element>
-    </avoid>
-  </completion_messages>
-</communication_guidelines>
-    ]]></template>
-  </communication_template>
-</instruction_file_templates>
\ No newline at end of file
diff --git a/.roo/rules-mode-writer/5_complete_mode_examples.xml b/.roo/rules-mode-writer/5_complete_mode_examples.xml
deleted file mode 100644
index 7c8f8a4cd..000000000
--- a/.roo/rules-mode-writer/5_complete_mode_examples.xml
+++ /dev/null
@@ -1,214 +0,0 @@
-<complete_examples>
-  <example name="mode_editing_enhancement">
-    <scenario>
-      Edit the test mode to add support for performance testing and benchmarking
-    </scenario>
-    
-    <user_request>
-      I want to edit the test mode to add benchmark testing capabilities
-    </user_request>
-
-    <workflow>
-      <step number="1">
-        <description>Determine user intent and clarify scope</description>
-        <tool_use><![CDATA[
-<ask_followup_question>
-<question>I understand you want to edit the test mode to add performance testing capabilities. Before we proceed, let me confirm the scope of changes. What specific performance testing features do you need?</question>
-<follow_up>
-<suggest>Add benchmark testing with Vitest's bench API</suggest>
-<suggest>Include performance profiling and memory usage tracking</suggest>
-<suggest>Add load testing capabilities for API endpoints</suggest>
-<suggest>All of the above - comprehensive performance testing suite</suggest>
-</follow_up>
-</ask_followup_question>
-        ]]></tool_use>
-        <expected_outcome>User selected: Add benchmark testing with Vitest's bench API</expected_outcome>
-      </step>
-
-      <step number="2">
-        <description>Immerse in existing test mode configuration</description>
-        <tool_use><![CDATA[
-<read_file>
-<path>.roomodes</path>
-</read_file>
-        ]]></tool_use>
-        <analysis>Found test mode configuration with current roleDefinition and file restrictions</analysis>
-      </step>
-
-      <step number="3">
-        <description>Explore existing test mode instructions</description>
-        <tool_use><![CDATA[
-<list_files>
-<path>.roo/rules-test</path>
-<recursive>true</recursive>
-</list_files>
-        ]]></tool_use>
-        <tool_use><![CDATA[
-<read_file>
-<path>.roo/rules-test/1_workflow.xml</path>
-</read_file>
-        ]]></tool_use>
-        <analysis>Understood current test workflows and patterns</analysis>
-      </step>
-
-      <step number="4">
-        <description>Validate changes for cohesion</description>
-        <tool_use><![CDATA[
-<ask_followup_question>
-<question>I've analyzed the test mode. Adding benchmark testing would require:
-1. Updating the roleDefinition to include performance testing expertise
-2. Modifying file restrictions to include .bench.ts files
-3. Adding new workflow instructions for benchmark creation
-4. Including Vitest bench API examples
-
-This aligns well with the existing testing focus. Should I proceed with all these changes?</question>
-<follow_up>
-<suggest>Yes, implement all the changes as described</suggest>
-<suggest>Start with just the roleDefinition and file restrictions</suggest>
-<suggest>Focus only on the workflow instructions first</suggest>
-<suggest>Let me review the specific changes before proceeding</suggest>
-</follow_up>
-</ask_followup_question>
-        ]]></tool_use>
-        <expected_outcome>User selected: Yes, implement all the changes as described</expected_outcome>
-      </step>
-
-      <step number="5">
-        <description>Update mode configuration in .roomodes</description>
-        <tool_use><![CDATA[
-<apply_diff>
-<path>.roomodes</path>
-<diff>
-<<<<<<< SEARCH
-    roleDefinition: |-
-      You are Roo, a Vitest testing specialist with deep expertise in: - Writing and maintaining Vitest test suites - Test-driven development (TDD) practices - Mocking and stubbing with Vitest - Integration testing strategies - TypeScript testing patterns - Code coverage analysis - Test performance optimization
-=======
-    roleDefinition: |-
-      You are Roo, a Vitest testing specialist with deep expertise in: - Writing and maintaining Vitest test suites - Test-driven development (TDD) practices - Mocking and stubbing with Vitest - Integration testing strategies - TypeScript testing patterns - Code coverage analysis - Test performance optimization - Benchmark testing with Vitest bench API - Performance profiling and optimization - Memory usage analysis in tests
->>>>>>> REPLACE
-</diff>
-</apply_diff>
-        ]]></tool_use>
-      </step>
-
-      <step number="6">
-        <description>Update file restrictions to include benchmark files</description>
-        <tool_use><![CDATA[
-<apply_diff>
-<path>.roomodes</path>
-<diff>
-<<<<<<< SEARCH
-        - fileRegex: (__tests__/.*|__mocks__/.*|\.test\.(ts|tsx|js|jsx)$|\.spec\.(ts|tsx|js|jsx)$|/test/.*|vitest\.config\.(js|ts)$|vitest\.setup\.(js|ts)$)
-          description: Test files, mocks, and Vitest configuration
-=======
-        - fileRegex: (__tests__/.*|__mocks__/.*|\.test\.(ts|tsx|js|jsx)$|\.spec\.(ts|tsx|js|jsx)$|\.bench\.(ts|tsx|js|jsx)$|/test/.*|vitest\.config\.(js|ts)$|vitest\.setup\.(js|ts)$)
-          description: Test files, benchmarks, mocks, and Vitest configuration
->>>>>>> REPLACE
-</diff>
-</apply_diff>
-        ]]></tool_use>
-      </step>
-
-      <step number="7">
-        <description>Create new benchmark workflow instructions</description>
-        <tool_use><![CDATA[
-<write_to_file>
-<path>.roo/rules-test/5_benchmark_testing.xml</path>
-<content>
-<benchmark_testing_guide>
-  <overview>
-    Guidelines for creating and maintaining performance benchmarks using Vitest bench API
-  </overview>
-
-  <benchmark_patterns>
-    <pattern name="basic_benchmark">
-      <description>Basic benchmark structure</description>
-      <example><![CDATA[
-import { bench, describe } from 'vitest';
-
-describe('Array operations', () => {
-  bench('Array.push', () => {
-    const arr = [];
-    for (let i = 0; i < 1000; i++) {
-      arr.push(i);
-    }
-  });
-
-  bench('Array spread', () => {
-    let arr = [];
-    for (let i = 0; i < 1000; i++) {
-      arr = [...arr, i];
-    }
-  });
-});
-      ]]></example>
-    </pattern>
-  </benchmark_patterns>
-
-  <best_practices>
-    <practice>Use meaningful benchmark names that describe what's being measured</practice>
-    <practice>Include baseline comparisons when optimizing code</practice>
-    <practice>Run benchmarks in isolation to avoid interference</practice>
-    <practice>Document performance expectations and thresholds</practice>
-  </best_practices>
-</benchmark_testing_guide>
-</content>
-<line_count>38</line_count>
-</write_to_file>
-        ]]></tool_use>
-      </step>
-
-      <step number="8">
-        <description>Validate all changes for consistency</description>
-        <tool_use><![CDATA[
-<ask_followup_question>
-<question>I've completed all the changes to add benchmark testing capabilities to the test mode:
-
-1. ✓ Updated roleDefinition to include benchmark expertise
-2. ✓ Modified file restrictions to include .bench.ts files
-3. ✓ Created new benchmark workflow instructions
-4. ✓ Added Vitest bench API examples
-
-All changes are cohesive and align with the existing test mode structure. Would you like me to test any specific aspect of these changes?</question>
-<follow_up>
-<suggest>Test creating a new benchmark file to verify file permissions</suggest>
-<suggest>Review the complete changes one more time</suggest>
-<suggest>Everything looks good, the mode is ready</suggest>
-<suggest>Create a simple benchmark example to test</suggest>
-</follow_up>
-</ask_followup_question>
-        ]]></tool_use>
-      </step>
-    </workflow>
-
-    <completion><![CDATA[
-<attempt_completion>
-<result>
-I've successfully enhanced the test mode with benchmark testing capabilities:
-
-1. Updated the roleDefinition to include:
-   - Benchmark testing with Vitest bench API
-   - Performance profiling and optimization
-   - Memory usage analysis in tests
-
-2. Modified file restrictions to include .bench.ts files, allowing the mode to create and edit benchmark files
-
-3. Created new workflow instructions at .roo/rules-test/5_benchmark_testing.xml with:
-   - Basic benchmark patterns
-   - Best practices for performance testing
-   - Example code using Vitest's bench API
-
-All changes have been validated for cohesion and consistency with the existing test mode structure. The mode now supports comprehensive performance testing alongside its existing unit and integration testing capabilities.
-</result>
-</attempt_completion>
-    ]]></completion>
-
-    <key_takeaways>
-      <takeaway>Always immerse yourself in the existing mode before making changes</takeaway>
-      <takeaway>Use ask_followup_question aggressively to clarify scope and validate changes</takeaway>
-      <takeaway>Validate all changes for cohesion and consistency</takeaway>
-      <takeaway>Update all relevant parts: configuration, file restrictions, and instructions</takeaway>
-      <takeaway>Test changes to ensure they work as expected</takeaway>
-    </key_takeaways>
-  </example>
-</complete_examples>
\ No newline at end of file
diff --git a/.roo/rules-mode-writer/6_mode_testing_validation.xml b/.roo/rules-mode-writer/6_mode_testing_validation.xml
deleted file mode 100644
index db65b31c2..000000000
--- a/.roo/rules-mode-writer/6_mode_testing_validation.xml
+++ /dev/null
@@ -1,207 +0,0 @@
-<mode_testing_validation>
-  <overview>
-    Guidelines for testing and validating newly created modes to ensure they function correctly and integrate well with the Roo Code ecosystem.
-  </overview>
-
-  <validation_checklist>
-    <category name="configuration_validation">
-      <item priority="critical">
-        <check>Mode slug is unique and follows naming conventions</check>
-        <validation>No spaces, lowercase, hyphens only</validation>
-      </item>
-      <item priority="critical">
-        <check>All required fields are present and non-empty</check>
-        <fields>slug, name, roleDefinition, groups</fields>
-      </item>
-      <item priority="critical">
-        <check>No customInstructions field in .roomodes</check>
-        <validation>All instructions must be in XML files in .roo/rules-[slug]/</validation>
-      </item>
-      <item priority="high">
-        <check>File restrictions use valid regex patterns</check>
-        <test_method><![CDATA[
-<search_files>
-<path>.</path>
-<regex>your_file_regex_here</regex>
-</search_files>
-        ]]></test_method>
-      </item>
-      <item priority="high">
-        <check>whenToUse clearly differentiates from other modes</check>
-        <validation>Compare with existing mode descriptions</validation>
-      </item>
-    </category>
-
-    <category name="instruction_validation">
-      <item>
-        <check>XML files are well-formed and valid</check>
-        <validation>No syntax errors, proper closing tags</validation>
-      </item>
-      <item>
-        <check>Instructions follow XML best practices</check>
-        <validation>Semantic tag names, proper nesting</validation>
-      </item>
-      <item>
-        <check>Examples use correct tool syntax</check>
-        <validation>Tool parameters match current API</validation>
-      </item>
-      <item>
-        <check>File paths in examples are consistent</check>
-        <validation>Use project-relative paths</validation>
-      </item>
-    </category>
-
-    <category name="functional_testing">
-      <item>
-        <check>Mode appears in mode list</check>
-        <test>Switch to the new mode and verify it loads</test>
-      </item>
-      <item>
-        <check>Tool permissions work as expected</check>
-        <test>Try using each tool group and verify access</test>
-      </item>
-      <item>
-        <check>File restrictions are enforced</check>
-        <test>Attempt to edit allowed and restricted files</test>
-      </item>
-      <item>
-        <check>Mode handles edge cases gracefully</check>
-        <test>Test with minimal input, errors, edge cases</test>
-      </item>
-    </category>
-  </validation_checklist>
-
-  <testing_workflow>
-    <step number="1">
-      <title>Configuration Testing</title>
-      <actions>
-        <action>Verify mode appears in available modes list</action>
-        <action>Check that mode metadata displays correctly</action>
-        <action>Confirm mode can be activated</action>
-      </actions>
-      <verification><![CDATA[
-<ask_followup_question>
-<question>I've created the mode configuration. Can you see the new mode in your mode list?</question>
-<follow_up>
-<suggest>Yes, I can see the new mode and switch to it</suggest>
-<suggest>No, the mode doesn't appear in the list</suggest>
-<suggest>The mode appears but has errors when switching</suggest>
-</follow_up>
-</ask_followup_question>
-      ]]></verification>
-    </step>
-
-    <step number="2">
-      <title>Permission Testing</title>
-      <test_cases>
-        <test case="read_permissions">
-          <action>Use read tools on various files</action>
-          <expected>All read operations should work</expected>
-        </test>
-        <test case="edit_restrictions">
-          <action>Try editing allowed file types</action>
-          <expected>Edits succeed for matching patterns</expected>
-        </test>
-        <test case="edit_restrictions_negative">
-          <action>Try editing restricted file types</action>
-          <expected>FileRestrictionError for non-matching files</expected>
-        </test>
-      </test_cases>
-    </step>
-
-    <step number="3">
-      <title>Workflow Testing</title>
-      <actions>
-        <action>Execute main workflow from start to finish</action>
-        <action>Test each decision point</action>
-        <action>Verify error handling</action>
-        <action>Check completion criteria</action>
-      </actions>
-    </step>
-
-    <step number="4">
-      <title>Integration Testing</title>
-      <areas>
-        <area>Orchestrator mode compatibility</area>
-        <area>Mode switching functionality</area>
-        <area>Tool handoff between modes</area>
-        <area>Consistent behavior with other modes</area>
-      </areas>
-    </step>
-  </testing_workflow>
-
-  <common_issues>
-    <issue type="configuration">
-      <problem>Mode doesn't appear in list</problem>
-      <causes>
-        <cause>Syntax error in YAML</cause>
-        <cause>Invalid mode slug</cause>
-        <cause>File not saved</cause>
-      </causes>
-      <solution>Check YAML syntax, validate slug format</solution>
-    </issue>
-
-    <issue type="permissions">
-      <problem>File restriction not working</problem>
-      <causes>
-        <cause>Invalid regex pattern</cause>
-        <cause>Escaping issues in regex</cause>
-        <cause>Wrong file path format</cause>
-      </causes>
-      <solution>Test regex pattern, use proper escaping</solution>
-      <example><![CDATA[
-# Wrong: *.ts (glob pattern)
-# Right: .*\.ts$ (regex pattern)
-      ]]></example>
-    </issue>
-
-    <issue type="behavior">
-      <problem>Mode not following instructions</problem>
-      <causes>
-        <cause>Instructions not in .roo/rules-[slug]/ folder</cause>
-        <cause>XML parsing errors</cause>
-        <cause>Conflicting instructions</cause>
-      </causes>
-      <solution>Verify file locations and XML validity</solution>
-    </issue>
-  </common_issues>
-
-  <debugging_tools>
-    <tool name="list_files">
-      <usage>Verify instruction files exist in correct location</usage>
-      <command><![CDATA[
-<list_files>
-<path>.roo</path>
-<recursive>true</recursive>
-</list_files>
-      ]]></command>
-    </tool>
-
-    <tool name="read_file">
-      <usage>Check mode configuration syntax</usage>
-      <command><![CDATA[
-<read_file>
-<path>.roomodes</path>
-</read_file>
-      ]]></command>
-    </tool>
-
-    <tool name="search_files">
-      <usage>Test file restriction patterns</usage>
-      <command><![CDATA[
-<search_files>
-<path>.</path>
-<regex>your_file_pattern_here</regex>
-</search_files>
-      ]]></command>
-    </tool>
-  </debugging_tools>
-
-  <best_practices>
-    <practice>Test incrementally as you build the mode</practice>
-    <practice>Start with minimal configuration and add complexity</practice>
-    <practice>Document any special requirements or dependencies</practice>
-    <practice>Consider edge cases and error scenarios</practice>
-    <practice>Get feedback from potential users of the mode</practice>
-  </best_practices>
-</mode_testing_validation>
\ No newline at end of file
diff --git a/.roo/rules-mode-writer/7_validation_cohesion_checking.xml b/.roo/rules-mode-writer/7_validation_cohesion_checking.xml
deleted file mode 100644
index a327a1e46..000000000
--- a/.roo/rules-mode-writer/7_validation_cohesion_checking.xml
+++ /dev/null
@@ -1,201 +0,0 @@
-<validation_cohesion_checking>
-  <overview>
-    Guidelines for thoroughly validating mode changes to ensure cohesion,
-    consistency, and prevent contradictions across all mode components.
-  </overview>
-
-  <validation_principles>
-    <principle name="comprehensive_review">
-      <description>
-        Every change must be reviewed in context of the entire mode
-      </description>
-      <checklist>
-        <item>Read all existing XML instruction files</item>
-        <item>Verify new changes align with existing patterns</item>
-        <item>Check for duplicate or conflicting instructions</item>
-        <item>Ensure terminology is consistent throughout</item>
-      </checklist>
-    </principle>
-
-    <principle name="aggressive_questioning">
-      <description>
-        Use ask_followup_question extensively to clarify ambiguities
-      </description>
-      <when_to_ask>
-        <scenario>User's intent is unclear</scenario>
-        <scenario>Multiple interpretations are possible</scenario>
-        <scenario>Changes might conflict with existing functionality</scenario>
-        <scenario>Impact on other modes needs clarification</scenario>
-      </when_to_ask>
-      <example><![CDATA[
-<ask_followup_question>
-<question>I notice this change might affect how the mode interacts with file permissions. Should we also update the file regex patterns to match?</question>
-<follow_up>
-<suggest>Yes, update the file regex to include the new file types</suggest>
-<suggest>No, keep the current file restrictions as they are</suggest>
-<suggest>Let me explain what file types I need to work with</suggest>
-<suggest>Show me the current file restrictions first</suggest>
-</follow_up>
-</ask_followup_question>
-      ]]></example>
-    </principle>
-
-    <principle name="contradiction_detection">
-      <description>
-        Actively search for and resolve contradictions
-      </description>
-      <common_contradictions>
-        <contradiction>
-          <type>Permission Mismatch</type>
-          <description>Instructions reference tools the mode doesn't have access to</description>
-          <resolution>Either grant the tool permission or update the instructions</resolution>
-        </contradiction>
-        <contradiction>
-          <type>Workflow Conflicts</type>
-          <description>Different XML files describe conflicting workflows</description>
-          <resolution>Consolidate workflows and ensure single source of truth</resolution>
-        </contradiction>
-        <contradiction>
-          <type>Role Confusion</type>
-          <description>Mode's roleDefinition doesn't match its actual capabilities</description>
-          <resolution>Update roleDefinition to accurately reflect the mode's purpose</resolution>
-        </contradiction>
-      </common_contradictions>
-    </principle>
-  </validation_principles>
-
-  <validation_workflow>
-    <phase name="pre_change_analysis">
-      <description>Before making any changes</description>
-      <steps>
-        <step>Read and understand all existing mode files</step>
-        <step>Create a mental model of current mode behavior</step>
-        <step>Identify potential impact areas</step>
-        <step>Ask clarifying questions about intended changes</step>
-      </steps>
-    </phase>
-
-    <phase name="change_implementation">
-      <description>While making changes</description>
-      <steps>
-        <step>Document each change and its rationale</step>
-        <step>Cross-reference with other files after each change</step>
-        <step>Verify examples still work with new changes</step>
-        <step>Update related documentation immediately</step>
-      </steps>
-    </phase>
-
-    <phase name="post_change_validation">
-      <description>After changes are complete</description>
-      <validation_checklist>
-        <category name="structural_validation">
-          <check>All XML files are well-formed and valid</check>
-          <check>File naming follows established patterns</check>
-          <check>Tag names are consistent across files</check>
-          <check>No orphaned or unused instructions</check>
-        </category>
-
-        <category name="content_validation">
-          <check>roleDefinition accurately describes the mode</check>
-          <check>whenToUse is clear and distinguishable</check>
-          <check>Tool permissions match instruction requirements</check>
-          <check>File restrictions align with mode purpose</check>
-          <check>Examples are accurate and functional</check>
-        </category>
-
-        <category name="integration_validation">
-          <check>Mode boundaries are well-defined</check>
-          <check>Handoff points to other modes are clear</check>
-          <check>No overlap with other modes' responsibilities</check>
-          <check>Orchestrator can correctly route to this mode</check>
-        </category>
-      </validation_checklist>
-    </phase>
-  </validation_workflow>
-
-  <cohesion_patterns>
-    <pattern name="consistent_voice">
-      <description>Maintain consistent tone and terminology</description>
-      <guidelines>
-        <guideline>Use the same terms for the same concepts throughout</guideline>
-        <guideline>Keep instruction style consistent across files</guideline>
-        <guideline>Maintain the same level of detail in similar sections</guideline>
-      </guidelines>
-    </pattern>
-
-    <pattern name="logical_flow">
-      <description>Ensure instructions flow logically</description>
-      <guidelines>
-        <guideline>Prerequisites come before dependent steps</guideline>
-        <guideline>Complex concepts build on simpler ones</guideline>
-        <guideline>Examples follow the explained patterns</guideline>
-      </guidelines>
-    </pattern>
-
-    <pattern name="complete_coverage">
-      <description>Ensure all aspects are covered without gaps</description>
-      <guidelines>
-        <guideline>Every mentioned tool has usage instructions</guideline>
-        <guideline>All workflows have complete examples</guideline>
-        <guideline>Error scenarios are addressed</guideline>
-      </guidelines>
-    </pattern>
-  </cohesion_patterns>
-
-  <validation_questions>
-    <question_set name="before_changes">
-      <ask_followup_question>
-        <question>Before we proceed with changes, I want to ensure I understand the full scope. What is the main goal of these modifications?</question>
-        <follow_up>
-          <suggest>Add new functionality while keeping existing features</suggest>
-          <suggest>Fix issues with current implementation</suggest>
-          <suggest>Refactor for better organization</suggest>
-          <suggest>Expand the mode's capabilities into new areas</suggest>
-        </follow_up>
-      </ask_followup_question>
-    </question_set>
-
-    <question_set name="during_changes">
-      <ask_followup_question>
-        <question>This change might affect other parts of the mode. How should we handle the impact on [specific area]?</question>
-        <follow_up>
-          <suggest>Update all affected areas to maintain consistency</suggest>
-          <suggest>Keep the existing behavior for backward compatibility</suggest>
-          <suggest>Create a migration path from old to new behavior</suggest>
-          <suggest>Let me review the impact first</suggest>
-        </follow_up>
-      </ask_followup_question>
-    </question_set>
-
-    <question_set name="after_changes">
-      <ask_followup_question>
-        <question>I've completed the changes and validation. Which aspect would you like me to test more thoroughly?</question>
-        <follow_up>
-          <suggest>Test the new workflow end-to-end</suggest>
-          <suggest>Verify file permissions work correctly</suggest>
-          <suggest>Check integration with other modes</suggest>
-          <suggest>Review all changes one more time</suggest>
-        </follow_up>
-      </ask_followup_question>
-    </question_set>
-  </validation_questions>
-
-  <red_flags>
-    <flag priority="high">
-      <description>Instructions reference tools not in the mode's groups</description>
-      <action>Either add the tool group or remove the instruction</action>
-    </flag>
-    <flag priority="high">
-      <description>File regex doesn't match described file types</description>
-      <action>Update regex pattern to match intended files</action>
-    </flag>
-    <flag priority="medium">
-      <description>Examples don't follow stated best practices</description>
-      <action>Update examples to demonstrate best practices</action>
-    </flag>
-    <flag priority="medium">
-      <description>Duplicate instructions in different files</description>
-      <action>Consolidate to single location and reference</action>
-    </flag>
-  </red_flags>
-</validation_cohesion_checking>
\ No newline at end of file
diff --git a/.roo/rules-pr-fixer/1_workflow.xml b/.roo/rules-pr-fixer/1_workflow.xml
deleted file mode 100644
index fb487e5fd..000000000
--- a/.roo/rules-pr-fixer/1_workflow.xml
+++ /dev/null
@@ -1,75 +0,0 @@
-<workflow_instructions>
-  <mode_overview>
-    This mode is designed to help resolve issues in existing pull requests. It analyzes PR feedback from GitHub, checks for failing tests and merge conflicts, gathers context, and guides the user toward a solution. All GitHub operations are performed using the GitHub CLI.
-  </mode_overview>
-
-  <initialization_steps>
-    <step number="1">
-      <action>Understand the user's request</action>
-      <details>
-        Parse the user's input to identify the pull request URL or number. Extract the repository owner and name.
-      </details>
-    </step>
-    <step number="2">
-      <action>Gather PR context</action>
-      <tools>
-        <tool>gh pr view [PR_NUMBER] --repo [owner]/[repo] --json number,title,author,state,body,url,headRefName,baseRefName,files,additions,deletions,changedFiles,comments,reviews</tool>
-        <tool>gh pr checks [PR_NUMBER] --repo [owner]/[repo] - Check workflow status for failing tests</tool>
-        <tool>gh pr view [PR_NUMBER] --repo [owner]/[repo] --json mergeable,mergeStateStatus - Check for merge conflicts</tool>
-      </tools>
-    </step>
-  </initialization_steps>
-
-  <main_workflow>
-    <phase name="analysis">
-      <description>Analyze the gathered information to identify the core problems.</description>
-      <steps>
-        <step>Summarize review comments and requested changes from gh pr view output.</step>
-        <step>Identify the root cause of failing tests by analyzing workflow logs with 'gh run view'.</step>
-        <step>Determine if merge conflicts exist from mergeable status.</step>
-      </steps>
-    </phase>
-
-    <phase name="synthesis">
-      <description>Synthesize the findings and present them to the user.</description>
-      <steps>
-        <step>Present a summary of the issues found (reviews, failing tests, conflicts).</step>
-        <step>Use ask_followup_question to ask the user how they want to proceed with fixing the issues.</step>
-      </steps>
-    </phase>
-
-    <phase name="implementation">
-      <description>Execute the user's chosen course of action.</description>
-      <steps>
-        <step>Check out the PR branch locally using 'gh pr checkout [PR_NUMBER] --repo [owner]/[repo] --force'.</step>
-        <step>Determine if the PR is from a fork by checking 'gh pr view [PR_NUMBER] --repo [owner]/[repo] --json isCrossRepository'.</step>
-        <step>Apply code changes based on review feedback using file editing tools.</step>
-        <step>Fix failing tests by modifying test files or source code as needed.</step>
-        <step>For conflict resolution: Delegate to merge-resolver mode using new_task with the PR number.</step>
-        <step>If changes affect user-facing content (i18n files, UI components, announcements), delegate translation updates using the new_task tool with translate mode.</step>
-        <step>Review modified files with 'git status --porcelain' to ensure no temporary files are included.</step>
-        <step>Stage files selectively using 'git add -u' (for modified tracked files) or 'git add <specific-files>' (for new files).</step>
-        <step>Verify staged files with 'git diff --cached --name-only' before committing.</step>
-        <step>Commit changes using git commands with descriptive messages.</step>
-        <step>Push changes to the correct remote (origin for same-repo PRs, fork remote for cross-repo PRs) using 'git push --force-with-lease'.</step>
-      </steps>
-    </phase>
-
-    <phase name="validation">
-      <description>Verify that the pushed changes resolve the issues.</description>
-      <steps>
-        <step>Use 'gh pr checks [PR_NUMBER] --repo [owner]/[repo] --watch' to monitor check status in real-time until all checks complete.</step>
-        <step>If needed, check specific workflow runs with 'gh run list --pr [PR_NUMBER] --repo [owner]/[repo]' for detailed CI/CD pipeline status.</step>
-        <step>Verify that all translation updates (if any) have been completed and committed.</step>
-        <step>Confirm PR is ready for review by checking mergeable state with 'gh pr view [PR_NUMBER] --repo [owner]/[repo] --json mergeable,mergeStateStatus'.</step>
-      </steps>
-    </phase>
-  </main_workflow>
-
-  <completion_criteria>
-    <criterion>All actionable review comments have been addressed.</criterion>
-    <criterion>All tests are passing.</criterion>
-    <criterion>The PR is free of merge conflicts.</criterion>
-    <criterion>All required translations have been completed and committed (if changes affect user-facing content).</criterion>
-  </completion_criteria>
-</workflow_instructions>
\ No newline at end of file
diff --git a/.roo/rules-pr-fixer/2_best_practices.xml b/.roo/rules-pr-fixer/2_best_practices.xml
deleted file mode 100644
index 2dc5775ce..000000000
--- a/.roo/rules-pr-fixer/2_best_practices.xml
+++ /dev/null
@@ -1,75 +0,0 @@
-<best_practices>
-  <general_principles>
-    <principle priority="high">
-      <name>Context is Key</name>
-      <description>Always gather full context before attempting a fix. This includes reading all relevant PR comments, checking CI/CD logs, and understanding the surrounding code.</description>
-      <rationale>Without full context, fixes may be incomplete or introduce new issues.</rationale>
-    </principle>
-    <principle priority="medium">
-      <name>Incremental Fixes</name>
-      <description>Address issues one at a time (e.g., fix tests first, then address comments). This makes the process more manageable and easier to validate.</description>
-      <rationale>Tackling all issues at once can be complex and error-prone.</rationale>
-    </principle>
-    <principle priority="high">
-      <name>Handle Fork Remotes Correctly</name>
-      <description>Always check if a PR comes from a fork (cross-repository) before pushing changes. Use 'gh pr view --json isCrossRepository' to determine the correct remote.</description>
-      <rationale>Pushing to the wrong remote (e.g., origin instead of fork) will fail for cross-repository PRs.</rationale>
-      <example>
-        <scenario>PR from a fork</scenario>
-        <good>Check isCrossRepository, add fork remote if needed, push to fork</good>
-        <bad>Always push to origin without checking PR source</bad>
-      </example>
-    </principle>
-    <principle priority="high">
-      <name>Safe File Staging</name>
-      <description>Always review files before staging to avoid committing temporary files, build artifacts, or system files. Use selective git commands that respect .gitignore.</description>
-      <rationale>Committing unwanted files can expose sensitive data, clutter the repository, and cause CI/CD failures.</rationale>
-      <example>
-        <scenario>Staging files for commit</scenario>
-        <good>Use 'git add -u' to stage only modified tracked files, or explicitly list files to add</good>
-        <bad>Use 'git add .' which stages everything including temp files</bad>
-      </example>
-      <checklist>
-        <item>Review git status before staging</item>
-        <item>Check for temporary files (.swp, .DS_Store, *.tmp)</item>
-        <item>Exclude build artifacts (dist/, build/, *.pyc)</item>
-        <item>Avoid IDE-specific files (.idea/, .vscode/)</item>
-        <item>Verify .gitignore is properly configured</item>
-      </checklist>
-    </principle>
-  </general_principles>
-
-  <code_conventions>
-    <convention category="merge_conflicts">
-      <rule>Delegate merge conflict resolution to the merge-resolver mode.</rule>
-      <template>
-When merge conflicts are detected, do not attempt to resolve them manually. Instead, use the new_task tool to create a task for the merge-resolver mode:
-
-```xml
-<new_task>
-<mode>merge-resolver</mode>
-<message>#[PR_NUMBER]</message>
-</new_task>
-```
-
-The merge-resolver mode will:
-- Checkout the PR branch
-- Perform the rebase
-- Intelligently resolve conflicts based on commit history and intent
-- Push the resolved changes
-- Return control back to pr-fixer mode
-
-This ensures consistent and intelligent conflict resolution across all PRs.
-      </template>
-    </convention>
-  </code_conventions>
-
-  <quality_checklist>
-    <category name="before_completion">
-      <item>Have all review comments been addressed?</item>
-      <item>Are all CI/CD checks passing?</item>
-      <item>Is the PR free of merge conflicts?</item>
-      <item>Have the changes been tested locally?</item>
-    </category>
-  </quality_checklist>
-</best_practices>
\ No newline at end of file
diff --git a/.roo/rules-pr-fixer/3_common_patterns.xml b/.roo/rules-pr-fixer/3_common_patterns.xml
deleted file mode 100644
index 4ef2a34b9..000000000
--- a/.roo/rules-pr-fixer/3_common_patterns.xml
+++ /dev/null
@@ -1,136 +0,0 @@
-<common_patterns>
-  <pattern name="checking_pr_status">
-    <usage>A set of commands to quickly assess the state of a Pull Request.</usage>
-    <template>
-      <command tool="gh">
-        gh pr status --json number,title,state,conflict,reviewDecision,headRefName,headRepositoryOwner
-      </command>
-      <command tool="gh">
-        gh pr checks
-      </command>
-      <command tool="gh">
-        gh pr view --comments
-      </command>
-    </template>
-  </pattern>
-  <pattern name="analyzing_failing_tests">
-    <usage>Commands to investigate why a specific test is failing.</usage>
-    <template>
-      <command tool="gh">
-        gh run list --workflow=<workflow_id> --branch=<branch_name> --json databaseId,name,status,conclusion
-      </command>
-      <command tool="gh">
-        gh run view --log-failed <run_id>
-      </command>
-    </template>
-  </pattern>
-  <pattern name="detecting_conflicts">
-    <usage>Commands to detect merge conflicts.</usage>
-    <template>
-      <comment>Check PR mergeable status</comment>
-      <command tool="gh">gh pr view <pr_number> --json mergeable,mergeStateStatus</command>
-      <comment>If mergeable is false or mergeStateStatus is CONFLICTING, delegate to merge-resolver</comment>
-    </template>
-  </pattern>
-  
-  <pattern name="delegating_conflict_resolution">
-    <usage>Delegate merge conflict resolution to the merge-resolver mode.</usage>
-    <template>
-      <comment>When conflicts are detected, create a new task for merge-resolver</comment>
-      <command tool="new_task"><![CDATA[
-<new_task>
-<mode>merge-resolver</mode>
-<message>#<pr_number></message>
-</new_task>
-      ]]></command>
-      <comment>Wait for merge-resolver to complete before continuing with other fixes</comment>
-    </template>
-  </pattern>
-  
-  <pattern name="checking_out_pr">
-    <usage>Check out a pull request branch locally.</usage>
-    <template>
-      <command tool="gh">gh pr checkout <pr_number_or_url> --force</command>
-      <comment>Alternative if gh checkout fails:</comment>
-      <command tool="git">git fetch origin pull/<pr_number>/head:<branch_name> && git checkout <branch_name></command>
-    </template>
-  </pattern>
-  
-  <pattern name="determine_push_remote">
-    <usage>Determine the correct remote to push to (handles forks).</usage>
-    <template>
-      <comment>Get PR metadata to check if it's from a fork</comment>
-      <command tool="gh">gh pr view <pr_number> --json headRepositoryOwner,headRefName,isCrossRepository</command>
-      <comment>If isCrossRepository is true, it's from a fork</comment>
-      <command tool="git">git remote -v</command>
-      <comment>Check if fork remote exists, otherwise add it</comment>
-      <command tool="git">git remote add fork https://github.com/<fork_owner>/<repo_name>.git</command>
-      <comment>Use appropriate remote based on PR source</comment>
-    </template>
-  </pattern>
-  
-  <pattern name="real_time_monitoring">
-    <usage>Monitor PR checks in real-time as they run.</usage>
-    <template>
-      <command tool="gh">gh pr checks <pr_number> --watch</command>
-      <comment>Continuously monitor check status with automatic updates</comment>
-      <alternative>For one-time status check: gh pr checks <pr_number> --json state,conclusion,name,detailsUrl</alternative>
-      <command tool="gh">gh run list --pr <pr_number> --json databaseId,status,conclusion</command>
-    </template>
-  </pattern>
-  
-  <pattern name="safe_push_operations">
-    <usage>Push operations that handle both origin and fork remotes correctly.</usage>
-    <template>
-      <comment>First determine the correct remote (origin or fork)</comment>
-      <command tool="gh">gh pr view <pr_number> --json headRepositoryOwner,headRefName,isCrossRepository</command>
-      <comment>If isCrossRepository is false, push to origin</comment>
-      <command tool="git">git push --force-with-lease origin <branch_name></command>
-      <comment>If isCrossRepository is true, push to fork remote</comment>
-      <command tool="git">git push --force-with-lease fork <branch_name></command>
-      <comment>If force-with-lease fails, fetch and retry</comment>
-      <command tool="git">git fetch <remote> <branch_name></command>
-      <command tool="git">git push --force <remote> <branch_name></command>
-    </template>
-  </pattern>
-
-  <pattern name="automated_commit_operations">
-    <usage>Commit operations that work in automated environments while respecting .gitignore.</usage>
-    <template>
-      <comment>Review what files have been modified</comment>
-      <command tool="git">git status --porcelain</command>
-      <comment>Add only tracked files that were modified (respects .gitignore)</comment>
-      <command tool="git">git add -u</command>
-      <comment>If you need to add specific new files, list them explicitly</comment>
-      <command tool="git">git add <specific_file_path></command>
-      <command tool="git">git commit -m "<commit_message>"</command>
-    </template>
-  </pattern>
-  <pattern name="safe_file_staging">
-    <usage>Safely stage files for commit while avoiding temporary files and respecting .gitignore.</usage>
-    <template>
-      <comment>First, check what files are currently modified or untracked</comment>
-      <command tool="git">git status --porcelain</command>
-      <comment>Review the output to identify files that should NOT be committed:</comment>
-      <comment>- Files starting with . (hidden files like .DS_Store, .swp)</comment>
-      <comment>- Build artifacts (dist/, build/, *.pyc, *.o)</comment>
-      <comment>- IDE files (.idea/, .vscode/, *.iml)</comment>
-      <comment>- Temporary files (*.tmp, *.temp, *~)</comment>
-      
-      <comment>Option 1: Stage only modified tracked files (safest)</comment>
-      <command tool="git">git add -u</command>
-      
-      <comment>Option 2: Stage specific files by path</comment>
-      <command tool="git">git add src/file1.ts src/file2.ts</command>
-      
-      <comment>Option 3: Use pathspec to add files matching a pattern</comment>
-      <command tool="git">git add '*.ts' '*.tsx' --</command>
-      
-      <comment>Option 4: Interactive staging to review each change</comment>
-      <command tool="git">git add -p</command>
-      
-      <comment>Always verify what's staged before committing</comment>
-      <command tool="git">git diff --cached --name-only</command>
-    </template>
-  </pattern>
-</common_patterns>
diff --git a/.roo/rules-pr-fixer/4_tool_usage.xml b/.roo/rules-pr-fixer/4_tool_usage.xml
deleted file mode 100644
index d8ce7e885..000000000
--- a/.roo/rules-pr-fixer/4_tool_usage.xml
+++ /dev/null
@@ -1,156 +0,0 @@
-<tool_usage_guide>
-  <tool_priorities>
-    <priority level="1">
-      <tool>gh pr view</tool>
-      <when>Use at the start to get all review comments and PR metadata.</when>
-      <why>Provides the core context of what needs to be fixed from a human perspective.</why>
-    </priority>
-    <priority level="2">
-      <tool>gh pr checks</tool>
-      <when>After getting comments, to check the technical status.</when>
-      <why>Quickly identifies if there are failing automated checks that need investigation.</why>
-   </priority>
-   <priority level="3">
-     <tool>new_task (mode: translate)</tool>
-     <when>When changes affect user-facing content, i18n files, or UI components that require translation.</when>
-     <why>Ensures translation consistency across all supported languages when PR fixes involve user-facing changes.</why>
-   </priority>
-   <priority level="4">
-     <tool>gh pr checks --watch</tool>
-     <when>After pushing a fix, to confirm that the changes have resolved the CI/CD failures.</when>
-     <why>Provides real-time feedback on whether the fix was successful.</why>
-   </priority>
- </tool_priorities>
-
-  <tool_specific_guidance>
-    <tool name="gh pr view">
-      <best_practices>
-        <practice>Always fetch details with --json to get structured data: gh pr view [PR_NUMBER] --repo [owner]/[repo] --json number,title,author,state,body,url,headRefName,baseRefName,files,additions,deletions,changedFiles,comments,reviews,mergeable,mergeStateStatus,isCrossRepository</practice>
-        <practice>Parse the JSON output to extract branch name, owner, repo slug, and mergeable state.</practice>
-      </best_practices>
-    </tool>
-
-    <tool name="gh pr comments">
-      <best_practices>
-        <practice>Use gh pr view --json comments to get all comments in structured format.</practice>
-        <practice>Parse all comments to create a checklist of required changes.</practice>
-        <practice>Ignore comments that are not actionable or have been resolved.</practice>
-      </best_practices>
-    </tool>
-
-    <tool name="gh run view --log-failed">
-      <best_practices>
-        <practice>Use this command to get the exact error messages from failing tests.</practice>
-        <practice>Search the log for keywords like 'error', 'failed', or 'exception' to quickly find the root cause.</practice>
-        <practice>Always specify run ID explicitly to avoid interactive selection prompts: gh run view [RUN_ID] --log-failed</practice>
-        <practice>Get run IDs with: gh run list --pr [PR_NUMBER] --repo [owner]/[repo]</practice>
-      </best_practices>
-    </tool>
-
-    <tool name="gh pr checkout">
-      <best_practices>
-        <practice>Use --force flag: 'gh pr checkout [PR_NUMBER] --repo [owner]/[repo] --force'</practice>
-        <practice>If gh checkout fails, use: git fetch origin pull/[PR_NUMBER]/head:[branch_name]</practice>
-      </best_practices>
-    </tool>
-
-    <tool name="git operations">
-      <best_practices>
-        <practice>Use --force-with-lease for safer force pushing.</practice>
-        <practice>Use GIT_EDITOR=true to prevent interactive prompts during rebases.</practice>
-        <practice>Always determine the correct remote before pushing (origin vs fork).</practice>
-      </best_practices>
-      <remote_handling>
-        <step>Check if PR is from a fork: 'gh pr view [PR_NUMBER] --repo [owner]/[repo] --json isCrossRepository'</step>
-        <step>If isCrossRepository is true, add fork remote if needed</step>
-        <step>Push to appropriate remote: 'git push --force-with-lease [remote] [branch]'</step>
-      </remote_handling>
-      <conflict_resolution>
-        <step>Delegate to merge-resolver mode using new_task</step>
-        <step>Provide the PR number (e.g., "#123") as the message</step>
-        <step>The merge-resolver mode will handle all conflict resolution automatically</step>
-      </conflict_resolution>
-    </tool>
-
-    <tool name="gh pr checks">
-      <best_practices>
-        <practice>Use --watch flag to monitor checks in real-time: 'gh pr checks [PR_NUMBER] --repo [owner]/[repo] --watch'</practice>
-        <practice>For one-time status checks, use --json flag: 'gh pr checks [PR_NUMBER] --repo [owner]/[repo] --json state,conclusion,name'</practice>
-        <practice>The --watch flag automatically updates the display as check statuses change.</practice>
-        <practice>Use 'gh run list --pr [PR_NUMBER] --repo [owner]/[repo]' to get detailed workflow status if needed.</practice>
-      </best_practices>
-    </tool>
-    
-    <tool name="ask_followup_question">
-      <best_practices>
-        <practice>After analyzing all the problems (reviews, tests, conflicts), present a summary to the user.</practice>
-        <practice>Provide clear, actionable next steps as suggestions.</practice>
-        <practice>Example suggestions: "Address review comments first.", "Tackle the failing tests.", "Resolve merge conflicts."</practice>
-      </best_practices>
-    </tool>
-
-    <tool name="new_task (mode: translate)">
-      <best_practices>
-        <practice>Use when PR fixes involve changes to user-facing strings, i18n files, or UI components.</practice>
-        <practice>Provide specific details about what content needs translation in the message.</practice>
-        <practice>Include file paths and descriptions of the changes made.</practice>
-        <practice>List all affected languages that need updates.</practice>
-        <practice>Wait for translation completion before proceeding to validation phase.</practice>
-      </best_practices>
-      <when_to_use>
-        <trigger>Changes to webview-ui/src/i18n/locales/en/*.json files</trigger>
-        <trigger>Changes to src/i18n/locales/en/*.json files</trigger>
-        <trigger>Modifications to UI components with user-facing text</trigger>
-        <trigger>Updates to announcement files or documentation requiring localization</trigger>
-        <trigger>Addition of new error messages or user notifications</trigger>
-      </when_to_use>
-      <example_usage><![CDATA[
-<new_task>
-<mode>translate</mode>
-<message>Translation updates needed for PR #1234 fixes. Please translate the following changes:
-
-Files modified:
-- webview-ui/src/i18n/locales/en/common.json: Added new error message "connection_failed"
-- webview-ui/src/components/settings/ApiSettings.tsx: Updated button text from "Save" to "Save Configuration"
-
-Please ensure all supported languages (ca, de, es, fr, hi, id, it, ja, ko, nl, pl, pt-BR, ru, tr, vi, zh-CN, zh-TW) are updated with appropriate translations for these changes.</message>
-</new_task>
-      ]]></example_usage>
-    </tool>
-    
-    <tool name="new_task (mode: merge-resolver)">
-      <best_practices>
-        <practice>Use when PR has merge conflicts that need to be resolved.</practice>
-        <practice>Simply provide the PR number (e.g., "#123") as the message.</practice>
-        <practice>The merge-resolver mode will handle checkout, rebase, conflict resolution, and pushing.</practice>
-        <practice>Wait for merge-resolver to complete before continuing with other PR fixes.</practice>
-      </best_practices>
-      <when_to_use>
-        <trigger>When gh pr view shows mergeable: false or mergeStateStatus: CONFLICTING</trigger>
-        <trigger>When git rebase fails with conflicts</trigger>
-        <trigger>When git status shows unmerged paths</trigger>
-      </when_to_use>
-      <example_usage><![CDATA[
-<new_task>
-<mode>merge-resolver</mode>
-<message>#1234</message>
-</new_task>
-      ]]></example_usage>
-    </tool>
-  </tool_specific_guidance>
-
-  <github_cli_reference>
-    <command_group name="pr_operations">
-      <command>gh pr view [PR_NUMBER] --repo [owner]/[repo] --json [fields]</command>
-      <command>gh pr checkout [PR_NUMBER] --repo [owner]/[repo] --force</command>
-      <command>gh pr checks [PR_NUMBER] --repo [owner]/[repo] [--watch|--json]</command>
-      <command>gh pr comment [PR_NUMBER] --repo [owner]/[repo] --body "[text]"</command>
-    </command_group>
-
-    <command_group name="workflow_operations">
-      <command>gh run list --pr [PR_NUMBER] --repo [owner]/[repo]</command>
-      <command>gh run view [RUN_ID] --repo [owner]/[repo] --log-failed</command>
-      <command>gh workflow view [WORKFLOW_NAME] --repo [owner]/[repo]</command>
-    </command_group>
-  </github_cli_reference>
-</tool_usage_guide>
\ No newline at end of file
diff --git a/.roo/rules-pr-fixer/5_examples.xml b/.roo/rules-pr-fixer/5_examples.xml
deleted file mode 100644
index 640e6398a..000000000
--- a/.roo/rules-pr-fixer/5_examples.xml
+++ /dev/null
@@ -1,304 +0,0 @@
-<complete_examples>
-  <example name="fix_failing_tests_and_address_comments">
-    <scenario>
-      A pull request has a failing CI check and a review comment asking for a change.
-    </scenario>
-    
-    <user_request>
-      Fix PR #4365 in RooCodeInc/Roo-Code.
-    </user_request>
-
-    <workflow>
-      <step number="1">
-        <description>Get PR details and review comments.</description>
-        <tool_use>
-<execute_command>
-<command>gh pr view 4365 --repo RooCodeInc/Roo-Code --json number,title,author,state,body,url,headRefName,baseRefName,files,additions,deletions,changedFiles,comments,reviews,mergeable,mergeStateStatus</command>
-</execute_command>
-        </tool_use>
-        <expected_outcome>Get the branch name, list of review comments, and check for mergeability.</expected_outcome>
-      </step>
-
-      <step number="2">
-        <description>Check CI status.</description>
-        <tool_use>
-<execute_command>
-<command>gh pr checks 4365 --repo RooCodeInc/Roo-Code</command>
-</execute_command>
-        </tool_use>
-        <analysis>Identify which check is failing.</analysis>
-      </step>
-
-      <step number="3">
-        <description>Get logs for the failing check.</description>
-        <tool_use>
-<execute_command>
-<command>gh run list --pr 4365 --repo RooCodeInc/Roo-Code</command>
-</execute_command>
-        </tool_use>
-        <analysis>Get the run ID of the failing workflow.</analysis>
-      </step>
-
-      <step number="3a">
-        <description>View the failed logs.</description>
-        <tool_use>
-<execute_command>
-<command>gh run view [run_id] --repo RooCodeInc/Roo-Code --log-failed</command>
-</execute_command>
-        </tool_use>
-        <analysis>Find the specific error message causing the test to fail.</analysis>
-      </step>
-      
-      <step number="4">
-        <description>Check out the pull request branch.</description>
-        <tool_use>
-          <execute_command>
-            <command>gh pr checkout 4365 --repo RooCodeInc/Roo-Code --force</command>
-          </execute_command>
-        </tool_use>
-        <analysis>The PR branch is now ready for local edits.</analysis>
-      </step>
-
-      <step number="5">
-        <description>Summarize findings and ask the user for the next action.</description>
-        <tool_use>
-<ask_followup_question>
-<question>I've checked out the branch. I've found a failing test related to 'XYZ' and a review comment asking to rename a variable. How should we proceed?</question>
-<follow_up>
-<suggest>First, apply the change requested in the review comment.</suggest>
-<suggest>Let's start by fixing the failing test.</suggest>
-<suggest>Show me the code for the failing test and the file with the requested change.</suggest>
-</follow_up>
-</ask_followup_question>
-        </tool_use>
-      </step>
-     <step number="6">
-       <description>After pushing the changes, monitor PR checks in real-time.</description>
-       <tool_use>
-         <execute_command>
-           <command>gh pr checks 4365 --repo RooCodeInc/Roo-Code --watch</command>
-         </execute_command>
-       </tool_use>
-       <analysis>Monitor checks continuously until all complete. The --watch flag provides real-time updates as check statuses change.</analysis>
-     </step>
-    </workflow>
-
-    <key_takeaways>
-      <takeaway>Always gather all information before proposing a solution.</takeaway>
-      <takeaway>Use the GitHub CLI to get a complete picture of the PR's status.</takeaway>
-      <takeaway>The --watch flag on gh pr checks provides real-time monitoring of CI status.</takeaway>
-    </key_takeaways>
-  </example>
-
-  <example name="fix_pr_with_translation_requirements">
-    <scenario>
-      A pull request has review comments requesting UI text changes that require translation updates across all supported languages.
-    </scenario>
-    
-    <user_request>
-      Fix PR #1234 in RooCodeInc/Roo-Code - the reviewer asked to change button text and there are some failing tests.
-    </user_request>
-
-    <workflow>
-      <step number="1">
-        <description>Get PR details and analyze changes.</description>
-        <tool_use>
-<execute_command>
-<command>gh pr view 1234 --repo RooCodeInc/Roo-Code --json number,title,author,state,body,url,headRefName,baseRefName,files,additions,deletions,changedFiles,comments,reviews</command>
-</execute_command>
-        </tool_use>
-        <expected_outcome>Identify the files changed and review feedback requiring UI text modifications.</expected_outcome>
-      </step>
-
-      <step number="2">
-        <description>Check out PR and apply the requested changes.</description>
-        <tool_use>
-<execute_command>
-<command>gh pr checkout 1234 --repo RooCodeInc/Roo-Code --force</command>
-</execute_command>
-        </tool_use>
-        <analysis>Make the requested button text changes in the UI components.</analysis>
-      </step>
-
-      <step number="3">
-        <description>Identify translation requirements and delegate to translate mode.</description>
-        <tool_use>
-<new_task>
-<mode>translate</mode>
-<message>Translation updates needed for PR #1234 fixes. The following changes were made based on review feedback:
-
-Files modified:
-- webview-ui/src/components/settings/ApiSettings.tsx: Changed button text from "Save" to "Save Configuration"
-- webview-ui/src/i18n/locales/en/common.json: Updated key "save_button" to "save_config_button"
-
-Please update all supported languages (ca, de, es, fr, hi, id, it, ja, ko, nl, pl, pt-BR, ru, tr, vi, zh-CN, zh-TW) with appropriate translations for:
-- New key "save_config_button" with translation equivalent to "Save Configuration"
-- Any other text changes that affect user-facing content
-
-Ensure consistency across all language files and maintain the same context and tone as existing translations.</message>
-</new_task>
-        </tool_use>
-        <expected_outcome>Translation subtask created and all language files updated.</expected_outcome>
-      </step>
-
-      <step number="4">
-        <description>Review and commit changes including translations.</description>
-        <tool_use>
-<execute_command>
-<command>git status --porcelain</command>
-</execute_command>
-        </tool_use>
-        <analysis>Review the list of modified files to ensure only intended changes are present.</analysis>
-      </step>
-      
-      <step number="4a">
-        <description>Stage only the intended files for commit.</description>
-        <tool_use>
-<execute_command>
-<command>git add -u && git commit -m "fix: update button text and translations as requested in review"</command>
-</execute_command>
-        </tool_use>
-        <analysis>Using 'git add -u' stages only modified tracked files, avoiding any temporary files.</analysis>
-      </step>
-
-      <step number="5">
-        <description>Check if PR is from a fork and push to correct remote.</description>
-        <tool_use>
-<execute_command>
-<command>gh pr view 1234 --repo RooCodeInc/Roo-Code --json isCrossRepository,headRepositoryOwner,headRefName</command>
-</execute_command>
-        </tool_use>
-        <analysis>Determine if this is a cross-repository PR to know which remote to push to.</analysis>
-      </step>
-      
-      <step number="6">
-        <description>Push changes to the appropriate remote.</description>
-        <tool_use>
-<execute_command>
-<command>git push --force-with-lease origin [branch_name]</command>
-</execute_command>
-        </tool_use>
-        <analysis>Push changes safely to update the pull request. Use 'fork' remote instead if PR is from a fork.</analysis>
-      </step>
-
-      <step number="7">
-        <description>Monitor CI status in real-time.</description>
-        <tool_use>
-<execute_command>
-<command>gh pr checks 1234 --repo RooCodeInc/Roo-Code --watch</command>
-</execute_command>
-        </tool_use>
-        <analysis>Watch CI checks continuously until all tests pass. The --watch flag provides automatic updates as check statuses change.</analysis>
-      </step>
-    </workflow>
-
-    <key_takeaways>
-      <takeaway>Always check if PR fixes involve user-facing content that requires translation.</takeaway>
-      <takeaway>Use new_task with translate mode to ensure consistent translation updates.</takeaway>
-      <takeaway>Include detailed context about what changed and why in translation requests.</takeaway>
-      <takeaway>Verify translation completeness before considering the PR fix complete.</takeaway>
-      <takeaway>Use gh pr view --json to get structured data about PR properties.</takeaway>
-    </key_takeaways>
-  </example>
-
-  <example name="fix_pr_with_merge_conflicts">
-    <scenario>
-      A pull request has merge conflicts that need to be resolved before other fixes can be applied.
-    </scenario>
-    
-    <user_request>
-      Fix PR #5678 in RooCodeInc/Roo-Code - it has merge conflicts and failing tests.
-    </user_request>
-
-    <workflow>
-      <step number="1">
-        <description>Get PR details and check merge status.</description>
-        <tool_use>
-<execute_command>
-<command>gh pr view 5678 --repo RooCodeInc/Roo-Code --json number,title,author,state,body,url,headRefName,baseRefName,mergeable,mergeStateStatus</command>
-</execute_command>
-        </tool_use>
-        <expected_outcome>Identify that mergeable is false and mergeStateStatus is CONFLICTING.</expected_outcome>
-      </step>
-
-      <step number="2">
-        <description>Delegate merge conflict resolution to merge-resolver mode.</description>
-        <tool_use>
-<new_task>
-<mode>merge-resolver</mode>
-<message>#5678</message>
-</new_task>
-        </tool_use>
-        <expected_outcome>The merge-resolver mode will handle checkout, rebase, conflict resolution, and pushing the resolved changes.</expected_outcome>
-      </step>
-
-      <step number="3">
-        <description>After merge-resolver completes, check PR status again.</description>
-        <tool_use>
-<execute_command>
-<command>gh pr view 5678 --repo RooCodeInc/Roo-Code --json mergeable,mergeStateStatus</command>
-</execute_command>
-        </tool_use>
-        <analysis>Verify that the PR is now mergeable after conflict resolution.</analysis>
-      </step>
-
-      <step number="4">
-        <description>Check CI status for any remaining failures.</description>
-        <tool_use>
-<execute_command>
-<command>gh pr checks 5678 --repo RooCodeInc/Roo-Code</command>
-</execute_command>
-        </tool_use>
-        <analysis>Identify any tests that are still failing after the merge conflict resolution.</analysis>
-      </step>
-
-      <step number="5">
-        <description>If tests are still failing, proceed with fixing them.</description>
-        <tool_use>
-<execute_command>
-<command>gh pr checkout 5678 --repo RooCodeInc/Roo-Code --force</command>
-</execute_command>
-        </tool_use>
-        <analysis>Now that conflicts are resolved, we can focus on fixing the failing tests.</analysis>
-      </step>
-
-      <step number="6">
-        <description>Apply test fixes and push changes.</description>
-        <tool_use>
-<execute_command>
-<command>git add -u && git commit -m "fix: resolve failing tests after merge conflict resolution"</command>
-</execute_command>
-        </tool_use>
-        <analysis>Commit the test fixes separately from the merge conflict resolution.</analysis>
-      </step>
-
-      <step number="7">
-        <description>Push changes and monitor CI status.</description>
-        <tool_use>
-<execute_command>
-<command>git push --force-with-lease origin [branch_name]</command>
-</execute_command>
-        </tool_use>
-        <analysis>Push the test fixes to update the PR.</analysis>
-      </step>
-
-      <step number="8">
-        <description>Monitor CI checks in real-time.</description>
-        <tool_use>
-<execute_command>
-<command>gh pr checks 5678 --repo RooCodeInc/Roo-Code --watch</command>
-</execute_command>
-        </tool_use>
-        <analysis>Watch CI checks continuously until all tests pass.</analysis>
-      </step>
-    </workflow>
-
-    <key_takeaways>
-      <takeaway>Always check for merge conflicts before attempting other fixes.</takeaway>
-      <takeaway>Delegate merge conflict resolution to the specialized merge-resolver mode.</takeaway>
-      <takeaway>The merge-resolver mode handles the entire conflict resolution workflow including pushing.</takeaway>
-      <takeaway>After conflict resolution, continue with other PR fixes like failing tests.</takeaway>
-      <takeaway>Keep conflict resolution commits separate from other fix commits for clarity.</takeaway>
-    </key_takeaways>
-  </example>
-</complete_examples>
diff --git a/.roo/rules-pr-reviewer/1_workflow.xml b/.roo/rules-pr-reviewer/1_workflow.xml
deleted file mode 100644
index 444694a52..000000000
--- a/.roo/rules-pr-reviewer/1_workflow.xml
+++ /dev/null
@@ -1,493 +0,0 @@
-<workflow>
-  <step number="1">
-    <name>Initialize Review Process</name>
-    <instructions>
-      Create a todo list to track the PR review workflow:
-      
-      <update_todo_list>
-      <todos>
-      [ ] Fetch pull request information
-      [ ] Fetch associated issue (if any)
-      [ ] Fetch pull request diff
-      [ ] Fetch existing PR comments and reviews
-      [ ] Check out pull request locally
-      [ ] Verify existing comments against current code
-      [ ] Perform comprehensive review
-      [ ] Prepare review comments
-      [ ] Preview review with user
-      [ ] Submit review or create tasks
-      </todos>
-      </update_todo_list>
-      
-      This helps track progress through the review process and ensures all steps are completed.
-    </instructions>
-  </step>
-
-  <step number="2">
-    <name>Fetch Pull Request Information</name>
-    <instructions>
-      If the user provides a PR number or URL, extract the necessary information:
-      - Repository owner and name
-      - Pull request number
-      
-      Use the GitHub CLI to fetch the PR details:
-      
-      <execute_command>
-      <command>gh pr view [PR_NUMBER] --repo [owner]/[repo] --json number,title,body,author,state,url,headRefName,baseRefName,headRefOid,mergeable,isDraft,createdAt,updatedAt</command>
-      </execute_command>
-      
-      Parse the JSON output to understand the PR's current state and metadata.
-      IMPORTANT: Save the headRefOid value as it will be needed for submitting the review via the API.
-      
-      <update_todo_list>
-      <todos>
-      [x] Fetch pull request information
-      [ ] Fetch associated issue (if any)
-      [ ] Fetch pull request diff
-      [ ] Fetch existing PR comments and reviews
-      [ ] Check out pull request locally
-      [ ] Verify existing comments against current code
-      [ ] Perform comprehensive review
-      [ ] Prepare review comments
-      [ ] Preview review with user
-      [ ] Submit review or create tasks
-      </todos>
-      </update_todo_list>
-    </instructions>
-  </step>
-
-  <step number="3">
-    <name>Fetch Associated Issue (If Any)</name>
-    <instructions>
-      Check the pull request body for a reference to a GitHub issue (e.g., "Fixes #123", "Closes #456").
-      If an issue is referenced, use the GitHub CLI to fetch its details:
-
-      <execute_command>
-      <command>gh issue view [issue_number] --repo [owner]/[repo] --json number,title,body,author,state,url,createdAt,updatedAt,comments</command>
-      </execute_command>
-
-      The issue description and comments can provide valuable context for the review.
-      
-      <update_todo_list>
-      <todos>
-      [x] Fetch pull request information
-      [x] Fetch associated issue (if any)
-      [ ] Fetch pull request diff
-      [ ] Fetch existing PR comments and reviews
-      [ ] Check out pull request locally
-      [ ] Verify existing comments against current code
-      [ ] Perform comprehensive review
-      [ ] Prepare review comments
-      [ ] Preview review with user
-      [ ] Submit review or create tasks
-      </todos>
-      </update_todo_list>
-    </instructions>
-  </step>
-
-  <step number="4">
-    <name>Fetch Pull Request Diff</name>
-    <instructions>
-      Get the pull request diff to understand the changes:
-      
-      <execute_command>
-      <command>gh pr diff [PR_NUMBER] --repo [owner]/[repo]</command>
-      </execute_command>
-      
-      This will show the complete diff of all changes in the PR.
-      
-      <update_todo_list>
-      <todos>
-      [x] Fetch pull request information
-      [x] Fetch associated issue (if any)
-      [x] Fetch pull request diff
-      [ ] Fetch existing PR comments and reviews
-      [ ] Check out pull request locally
-      [ ] Verify existing comments against current code
-      [ ] Perform comprehensive review
-      [ ] Prepare review comments
-      [ ] Preview review with user
-      [ ] Submit review or create tasks
-      </todos>
-      </update_todo_list>
-    </instructions>
-  </step>
-
-  <step number="5">
-    <name>Fetch Existing PR Comments and Reviews</name>
-    <instructions>
-      IMPORTANT: Before reviewing any code, first get all existing comments and reviews to understand what feedback has already been provided:
-      
-      Fetch all review comments:
-      <execute_command>
-      <command>gh pr view [PR_NUMBER] --repo [owner]/[repo] --comments</command>
-      </execute_command>
-      
-      Also fetch review details:
-      <execute_command>
-      <command>gh api repos/[owner]/[repo]/pulls/[PR_NUMBER]/reviews</command>
-      </execute_command>
-      
-      Create a mental or written list of:
-      - All issues/suggestions that have been raised
-      - The specific files and line numbers mentioned
-      - Whether comments appear to be resolved or still pending
-      
-      This information will guide your review to avoid duplicate feedback.
-      
-      <update_todo_list>
-      <todos>
-      [x] Fetch pull request information
-      [x] Fetch associated issue (if any)
-      [x] Fetch pull request diff
-      [x] Fetch existing PR comments and reviews
-      [ ] Check out pull request locally
-      [ ] Verify existing comments against current code
-      [ ] Perform comprehensive review
-      [ ] Prepare review comments
-      [ ] Preview review with user
-      [ ] Submit review or create tasks
-      </todos>
-      </update_todo_list>
-    </instructions>
-  </step>
-
-  <step number="6">
-    <name>Check Out Pull Request Locally</name>
-    <instructions>
-      Use the GitHub CLI to check out the pull request locally:
-      
-      <execute_command>
-      <command>gh pr checkout [PR_NUMBER] --repo [owner]/[repo]</command>
-      </execute_command>
-      
-      This allows you to:
-      - Navigate the actual code structure
-      - Understand how changes interact with existing code
-      - Get better context for your review
-      
-      <update_todo_list>
-      <todos>
-      [x] Fetch pull request information
-      [x] Fetch associated issue (if any)
-      [x] Fetch pull request diff
-      [x] Fetch existing PR comments and reviews
-      [x] Check out pull request locally
-      [ ] Verify existing comments against current code
-      [ ] Perform comprehensive review
-      [ ] Prepare review comments
-      [ ] Preview review with user
-      [ ] Submit review or create tasks
-      </todos>
-      </update_todo_list>
-    </instructions>
-  </step>
-
-  <step number="7">
-    <name>Verify Existing Comments Against Current Code</name>
-    <instructions>
-      Now that you have the code checked out locally and know what comments exist:
-      
-      1. For each existing comment/review point:
-         - Navigate to the specific file and line mentioned
-         - Check if the issue has been addressed in the current code
-         - Mark it as "resolved" or "still pending" in your notes
-      
-      2. Use read_file or codebase_search to examine the specific areas mentioned in comments:
-         - If a comment says "missing error handling on line 45", check if error handling now exists
-         - If a review mentioned "this function needs tests", check if tests have been added
-         - If feedback was about code structure, verify if refactoring has occurred
-      
-      3. Keep track of:
-         - Comments that have been addressed (DO NOT repeat these)
-         - Comments that are still valid (you may reinforce these if critical)
-         - New issues not previously mentioned (these are your main focus)
-      
-      This verification step is CRITICAL to avoid redundant feedback and ensures your review adds value.
-      
-      <update_todo_list>
-      <todos>
-      [x] Fetch pull request information
-      [x] Fetch associated issue (if any)
-      [x] Fetch pull request diff
-      [x] Fetch existing PR comments and reviews
-      [x] Check out pull request locally
-      [x] Verify existing comments against current code
-      [ ] Perform comprehensive review
-      [ ] Prepare review comments
-      [ ] Preview review with user
-      [ ] Submit review or create tasks
-      </todos>
-      </update_todo_list>
-    </instructions>
-  </step>
-
-  <step number="8">
-    <name>Perform Comprehensive Review</name>
-    <instructions>
-      Review the pull request thoroughly:
-      - Verify that the changes are directly related to the linked issue and do not include unrelated modifications.
-      - Focus primarily on the changes made in the PR.
-      - Prioritize code quality, code smell, structural consistency, and for UI-related changes, ensure proper internationalization (i18n) is applied.
-      - Watch for signs of technical debt (e.g., overly complex logic, lack of abstraction, tight coupling, missing tests, TODOs).
-      - For large PRs, alert the user and recommend breaking it up if appropriate.
-      - NEVER run tests or execute code in PR Reviewer mode. The repository likely has automated testing. Your role is limited to:
-        - Code review and analysis
-        - Leaving review comments
-        - Checking code quality and structure
-        - Reviewing test coverage and quality (without execution)
-      
-      Document your findings in a numbered list format:
-      1. Code quality issues
-      2. Structural improvements
-      3. Missing tests or documentation
-      4. Potential bugs or edge cases
-      5. Performance concerns
-      6. Security considerations
-      7. Internationalization (i18n) issues
-      8. Technical debt indicators
-      
-      <update_todo_list>
-      <todos>
-      [x] Fetch pull request information
-      [x] Fetch associated issue (if any)
-      [x] Fetch pull request diff
-      [x] Fetch existing PR comments and reviews
-      [x] Check out pull request locally
-      [x] Verify existing comments against current code
-      [x] Perform comprehensive review
-      [ ] Prepare review comments
-      [ ] Preview review with user
-      [ ] Submit review or create tasks
-      </todos>
-      </update_todo_list>
-    </instructions>
-  </step>
-
-  <step number="9">
-    <name>Prepare Review Comments</name>
-    <instructions>
-      Format your review comments following these guidelines:
-      
-      CRITICAL: Before adding any comment, verify it's not already addressed:
-      - Cross-reference with your notes from Step 7
-      - Only comment on NEW issues or UNRESOLVED existing issues
-      - Never repeat feedback that has been addressed in the current code
-      
-      Your suggestions should:
-      - Use a **friendly, curious tone** — prefer asking: "Is this intentional?" or "Could we approach this differently to improve X?"
-      - Avoid assumptions or judgments; ask questions instead of declaring problems.
-      - Skip ALL praise and positive comments. Focus exclusively on issues that need attention.
-      - Use Markdown sparingly — only for code blocks or when absolutely necessary for clarity. Avoid markdown headings (###, ##, etc.) entirely.
-      - Avoid including internal evaluation terminology (e.g., scores or internal tags) in public comments.
-      
-      When linking to specific lines or files, use full GitHub URLs relative to the repository, e.g.
-      `https://github.com/[owner]/[repo]/blob/[branch]/[path/to/file]#L[line-number]`.
-      
-      Present your findings as a numbered list organized by priority:
-      
-      **Critical Issues (Must Fix):**
-      1. [Issue description with file/line reference]
-      2. [Issue description with file/line reference]
-      
-      **Important Suggestions (Should Consider):**
-      3. [Suggestion with rationale]
-      4. [Suggestion with rationale]
-      
-      **Minor Improvements (Nice to Have):**
-      5. [Improvement suggestion]
-      6. [Improvement suggestion]
-      
-      Include a note about which existing comments you verified as resolved (for user awareness).
-      
-      <update_todo_list>
-      <todos>
-      [x] Fetch pull request information
-      [x] Fetch associated issue (if any)
-      [x] Fetch pull request diff
-      [x] Fetch existing PR comments and reviews
-      [x] Check out pull request locally
-      [x] Verify existing comments against current code
-      [x] Perform comprehensive review
-      [x] Prepare review comments
-      [ ] Preview review with user
-      [ ] Submit review or create tasks
-      </todos>
-      </update_todo_list>
-    </instructions>
-  </step>
-
-  <step number="10">
-    <name>Preview Review with User</name>
-    <instructions>
-      Always show the user a preview of your review suggestions and comments before taking any action.
-      Present your findings as a numbered list clearly for the user before submitting comments.
-      
-      <ask_followup_question>
-      <question>I've completed my review of PR #[number]. Here's what I found:
-
-      [If applicable: **Existing comments that have been resolved:**
-      - Comment about X on file Y - now addressed
-      - Suggestion about Z - implemented]
-
-      **Review Findings:**
-      
-      **Critical Issues (Must Fix):**
-      1. [Specific issue with file/line reference]
-      2. [Specific issue with file/line reference]
-      
-      **Important Suggestions (Should Consider):**
-      3. [Suggestion with rationale]
-      4. [Suggestion with rationale]
-      
-      **Minor Improvements (Nice to Have):**
-      5. [Improvement suggestion]
-      6. [Improvement suggestion]
-
-      Would you like me to:</question>
-      <follow_up>
-      <suggest>Create a comprehensive review with all comments</suggest>
-      <suggest>Create individual tasks for each suggestion using new_task</suggest>
-      <suggest>Let me modify the suggestions first</suggest>
-      <suggest>Skip submission - just wanted the analysis</suggest>
-      </follow_up>
-      </ask_followup_question>
-      
-      <update_todo_list>
-      <todos>
-      [x] Fetch pull request information
-      [x] Fetch associated issue (if any)
-      [x] Fetch pull request diff
-      [x] Fetch existing PR comments and reviews
-      [x] Check out pull request locally
-      [x] Verify existing comments against current code
-      [x] Perform comprehensive review
-      [x] Prepare review comments
-      [x] Preview review with user
-      [ ] Submit review or create tasks
-      </todos>
-      </update_todo_list>
-    </instructions>
-  </step>
-
-  <step number="11">
-    <name>Submit Review</name>
-    <instructions>
-      Based on user preference, submit the review using the GitHub API to support inline comments:
-      
-      1. Construct the review payload with inline comments. For each comment, you need:
-         - The file path (relative to repository root)
-         - The line number where the comment should appear
-         - The comment body text
-         - The side ("RIGHT" for new code, "LEFT" for old code)
-      
-      2. Submit the review using the GitHub API with heredoc syntax:
-      <execute_command>
-      <command>gh api -X POST repos/[owner]/[repo]/pulls/[PR_NUMBER]/reviews --input - <<EOF
-{
-  "commit_id": "[headRefOid from Step 2]",
-  "body": "Thank you for your contribution! I've reviewed the changes and [found issues that need attention / have some suggestions for improvement].",
-  "event": "COMMENT",
-  "comments": [
-    {
-      "path": "[file/path/to/code.ts]",
-      "body": "[Your comment text here - use friendly, curious tone]",
-      "line": [line_number],
-      "side": "RIGHT"
-    }
-  ]
-}
-EOF</command>
-      </execute_command>
-      
-      The review will be created with all inline comments attached to specific lines of code.
-      
-      Example for a review:
-      <execute_command>
-      <command>gh api -X POST repos/RooCodeInc/Roo-Code/pulls/6378/reviews --input - <<EOF
-{
-  "commit_id": "abc123def4567890...",
-  "body": "Thank you for your contribution! I've reviewed the changes and found that the critical issues from the previous review are still pending. I've left some suggestions inline to help improve the implementation.",
-  "event": "COMMENT",
-  "comments": [
-    {
-      "path": "packages/cloud/src/CloudService.ts",
-      "body": "Missing error handling here...",
-      "line": 19,
-      "side": "RIGHT"
-    },
-    {
-      "path": "packages/cloud/src/CloudService.ts",
-      "body": "Is this intentional? The timeout seems quite high (30s). Could we consider reducing it or making it configurable?",
-      "line": 45,
-      "side": "RIGHT"
-    }
-  ]
-}
-EOF</command>
-      </execute_command>
-      
-      <update_todo_list>
-      <todos>
-      [x] Fetch pull request information
-      [x] Fetch associated issue (if any)
-      [x] Fetch pull request diff
-      [x] Fetch existing PR comments and reviews
-      [x] Check out pull request locally
-      [x] Verify existing comments against current code
-      [x] Perform comprehensive review
-      [x] Prepare review comments
-      [x] Preview review with user
-      [x] Submit review or create tasks
-      </todos>
-      </update_todo_list>
-    </instructions>
-  </step>
-
-  <step number="12">
-    <name>Create Tasks for Suggestions (Optional)</name>
-    <instructions>
-      If the user chooses to create individual tasks for each suggestion, use the new_task tool to create separate tasks:
-      
-      For each numbered finding from your review:
-      1. Determine the appropriate mode based on the type of work needed:
-         - Use "code" mode for bug fixes, implementation changes, or refactoring
-         - Use "translate" mode for internationalization (i18n) issues
-         - Use "test" mode for missing or inadequate test coverage
-         - Use "docs-extractor" mode for documentation issues
-         - Use "architect" mode for structural or design improvements
-         - Use "debug" mode for investigating potential bugs
-      
-      2. Create a clear, actionable task message that includes:
-         - The specific issue or suggestion
-         - The file(s) and line numbers affected
-         - Any relevant context from the PR
-         - The expected outcome
-      
-      3. Use the new_task tool for each suggestion:
-      <new_task>
-      <mode>[appropriate mode based on task type]</mode>
-      <message>Fix [issue type] in [file]: [specific description of what needs to be done]</message>
-      </new_task>
-      
-      Example task creation:
-      <new_task>
-      <mode>code</mode>
-      <message>Fix missing error handling in src/api/users.ts:45-52. The getUserById function should handle cases where the user is not found and return an appropriate error response.</message>
-      </new_task>
-      
-      <new_task>
-      <mode>translate</mode>
-      <message>Add missing i18n translations for new user profile fields in src/components/UserProfile.tsx. The fields 'bio', 'location', and 'website' need to be wrapped with translation functions.</message>
-      </new_task>
-      
-      After creating all tasks, provide a summary:
-      "I've created [X] individual tasks for the review findings:
-      - [Y] code fixes/improvements
-      - [Z] translation/i18n tasks
-      - [etc.]
-      
-      Each task contains the specific context and requirements for addressing the issue."
-    </instructions>
-  </step>
-</workflow>
\ No newline at end of file
diff --git a/.roo/rules-pr-reviewer/2_best_practices.xml b/.roo/rules-pr-reviewer/2_best_practices.xml
deleted file mode 100644
index f367f25b6..000000000
--- a/.roo/rules-pr-reviewer/2_best_practices.xml
+++ /dev/null
@@ -1,40 +0,0 @@
-<best_practices>
-  - ALWAYS create a todo list at the start to track the review workflow (Step 1)
-  - Use GitHub CLI (`gh`) commands instead of MCP tools for all GitHub operations
-  - ALWAYS fetch the PR's headRefOid in Step 2 - this is required for API review submission
-  - ALWAYS fetch existing comments and reviews BEFORE reviewing any code (Step 5)
-  - Create a list of all existing feedback before starting your review
-  - Check out the PR locally using `gh pr checkout` for better context understanding
-  - Systematically verify each existing comment against the current code (Step 7)
-  - Track which comments are resolved vs still pending
-  - Only provide feedback on NEW issues or UNRESOLVED existing issues
-  - Never duplicate feedback that has already been addressed
-  - Always fetch and review the entire PR diff before commenting
-  - Check for and review any associated issue for context
-  - Focus on the changes made, not unrelated code
-  - Ensure all changes are directly related to the linked issue
-  - Use a friendly, curious tone in all comments
-  - Ask questions rather than making assumptions - there may be intentions behind the code choices
-  - Provide actionable feedback with specific suggestions
-  - Focus exclusively on issues and improvements - skip all praise or positive comments
-  - Use minimal markdown - avoid headings (###, ##) and excessive formatting
-  - Only use markdown for code blocks or when absolutely necessary for clarity
-  - Consider the PR's scope - suggest breaking up large PRs
-  - Verify proper i18n implementation for UI changes
-  - Check for test coverage without executing tests
-  - Look for signs of technical debt and code smells
-  - Ensure consistency with existing code patterns
-  - Link to specific lines using full GitHub URLs
-  - Present findings in a numbered list format for clarity
-  - Group feedback by priority (critical, important, minor)
-  - Always preview comments with the user before submitting
-  - Use the GitHub API for submitting reviews to support inline comments
-  - Construct proper JSON payloads with commit_id, body, event, and comments array
-  - Each inline comment needs: path, body, line number, and side (RIGHT for new code)
-  - Use COMMENT when submitting the review
-  - Use heredoc syntax (--input - <<EOF) to pass JSON directly
-  - Offer the option to create individual tasks for each suggestion
-  - When creating tasks, choose the appropriate mode for each type of work
-  - Include specific context and file references in each task
-  - Update the todo list after each major step to track progress
-</best_practices>
\ No newline at end of file
diff --git a/.roo/rules-pr-reviewer/3_common_mistakes_to_avoid.xml b/.roo/rules-pr-reviewer/3_common_mistakes_to_avoid.xml
deleted file mode 100644
index 0aee6e609..000000000
--- a/.roo/rules-pr-reviewer/3_common_mistakes_to_avoid.xml
+++ /dev/null
@@ -1,43 +0,0 @@
-<common_mistakes_to_avoid>
-  - Not creating a todo list at the start to track the review workflow
-  - Using MCP tools instead of GitHub CLI commands for GitHub operations
-  - Forgetting to fetch headRefOid in Step 2 - this is REQUIRED for API review submission
-  - Starting to review code WITHOUT first fetching existing comments and reviews
-  - Failing to create a list of existing feedback before reviewing
-  - Not systematically checking each existing comment against the current code
-  - Repeating feedback that has already been addressed in the current code
-  - Ignoring existing PR comments or failing to verify if they have already been resolved
-  - Running tests or executing code during review
-  - Making judgmental or harsh comments
-  - Providing feedback on code outside the PR's scope
-  - Overlooking unrelated changes not tied to the main issue
-  - Including ANY praise or positive comments - focus only on issues
-  - Using markdown headings (###, ##, #) in review comments
-  - Using excessive markdown formatting when plain text would suffice
-  - Submitting comments without user preview/approval
-  - Forgetting to check for an associated issue for additional context
-  - Missing critical security or performance issues
-  - Not checking for proper i18n in UI changes
-  - Failing to suggest breaking up large PRs
-  - Using internal evaluation terminology in public comments
-  - Not providing actionable suggestions for improvements
-  - Reviewing only the diff without local context
-  - Making assumptions instead of asking clarifying questions about potential intentions
-  - Forgetting to link to specific lines with full GitHub URLs
-  - Not presenting findings in a clear numbered list format
-  - Failing to offer the task creation option for addressing suggestions
-  - Creating tasks without specific context or file references
-  - Choosing inappropriate modes when creating tasks for suggestions
-  - Not updating the todo list after completing each step
-  - Not including --repo flag when using gh commands for non-default repositories
-  - Using wrong commit_id in review payload (must use headRefOid from PR info)
-  - Forgetting to specify "side": "RIGHT" for comments on new code
-  - Using incorrect line numbers that don't match the actual diff
-  - Not escaping special characters in JSON payload properly
-  - Not using COMMENT as the event type in the review payload
-  - Not constructing proper file paths relative to repository root
-  - Submitting empty comments array when inline comments are needed
-  - Forgetting to use <<EOF syntax properly in the command
-  - Not properly escaping special characters in heredoc JSON content
-  - Missing the EOF delimiter at the end of the heredoc
-</common_mistakes_to_avoid>
\ No newline at end of file
diff --git a/.roo/rules-translate/001-general-rules.md b/.roo/rules-translate/001-general-rules.md
deleted file mode 100644
index e27b9793e..000000000
--- a/.roo/rules-translate/001-general-rules.md
+++ /dev/null
@@ -1,106 +0,0 @@
-# 1. SUPPORTED LANGUAGES AND LOCATION
-
-- Localize all strings into the following locale files: ca, de, en, es, fr, hi, id, it, ja, ko, nl, pl, pt-BR, ru, tr, vi, zh-CN, zh-TW
-- The VSCode extension has two main areas that require localization:
-    - Core Extension: src/i18n/locales/ (extension backend)
-    - WebView UI: webview-ui/src/i18n/locales/ (user interface)
-
-# 2. VOICE, STYLE AND TONE
-
-- Always use informal speech (e.g., "du" instead of "Sie" in German) for all translations
-- Maintain a direct and concise style that mirrors the tone of the original text
-- Carefully account for colloquialisms and idiomatic expressions in both source and target languages
-- Aim for culturally relevant and meaningful translations rather than literal translations
-- Preserve the personality and voice of the original content
-- Use natural-sounding language that feels native to speakers of the target language
-- Don't translate the word "token" as it means something specific in English that all languages will understand
-- Don't translate domain-specific words (especially technical terms like "Prompt") that are commonly used in English in the target language
-
-# 3. CORE EXTENSION LOCALIZATION (src/)
-
-- Located in src/i18n/locales/
-- NOT ALL strings in core source need internationalization - only user-facing messages
-- Internal error messages, debugging logs, and developer-facing messages should remain in English
-- The t() function is used with namespaces like 'core:errors.missingToolParameter'
-- Be careful when modifying interpolation variables; they must remain consistent across all translations
-- Some strings in formatResponse.ts are intentionally not internationalized since they're internal
-- When updating strings in core.json, maintain all existing interpolation variables
-- Check string usages in the codebase before making changes to ensure you're not breaking functionality
-
-# 4. WEBVIEW UI LOCALIZATION (webview-ui/src/)
-
-- Located in webview-ui/src/i18n/locales/
-- Uses standard React i18next patterns with the useTranslation hook
-- All user interface strings should be internationalized
-- Always use the Trans component with named components for text with embedded components
-
-<Trans> example:
-
-`"changeSettings": "You can always change this at the bottom of the <settingsLink>settings</settingsLink>",`
-
-```
-  <Trans
-    i18nKey="welcome:telemetry.changeSettings"
-    components={{
-      settingsLink: <VSCodeLink href="#" onClick={handleOpenSettings} />
-    }}
-  />
-```
-
-# 5. TECHNICAL IMPLEMENTATION
-
-- Use namespaces to organize translations logically
-- Handle pluralization using i18next's built-in capabilities
-- Implement proper interpolation for variables using {{variable}} syntax
-- Don't include defaultValue. The `en` translations are the fallback
-- Always use apply_diff instead of write_to_file when editing existing translation files (much faster and more reliable)
-- When using apply_diff, carefully identify the exact JSON structure to edit to avoid syntax errors
-- Placeholders (like {{variable}}) must remain exactly identical to the English source to maintain code integration and prevent syntax errors
-
-# 6. WORKFLOW AND APPROACH
-
-- First add or modify English strings, then ask for confirmation before translating to all other languages
-- Use this process for each localization task:
-    1. Identify where the string appears in the UI/codebase
-    2. Understand the context and purpose of the string
-    3. Update English translation first
-    4. Use the `<search_files>` tool to find JSON keys that are near new keys in English translations but do not yet exist in the other language files for `<apply_diff>` SEARCH context
-    5. Create appropriate translations for all other supported languages utilizing the `search_files` result using `<apply_diff>` without reading every file.
-    6. Do not output the translated text into the chat, just modify the files.
-    7. Validate your changes with the missing translations script
-- Flag or comment if an English source string is incomplete ("please see this...") to avoid truncated or unclear translations
-- For UI elements, distinguish between:
-    - Button labels: Use short imperative commands ("Save", "Cancel")
-    - Tooltip text: Can be slightly more descriptive
-- Preserve the original perspective: If text is a user command directed at the software, ensure the translation maintains this direction, avoiding language that makes it sound like an instruction from the system to the user
-
-# 7. COMMON PITFALLS TO AVOID
-
-- Switching between formal and informal addressing styles - always stay informal ("du" not "Sie")
-- Translating or altering technical terms and brand names that should remain in English
-- Modifying or removing placeholders like {{variable}} - these must remain identical
-- Translating domain-specific terms that are commonly used in English in the target language
-- Changing the meaning or nuance of instructions or error messages
-- Forgetting to maintain consistent terminology throughout the translation
-
-# 8. QUALITY ASSURANCE
-
-- Maintain consistent terminology across all translations
-- Respect the JSON structure of translation files
-- Watch for placeholders and preserve them in translations
-- Be mindful of text length in UI elements when translating to languages that might require more characters
-- Use context-aware translations when the same string has different meanings
-- Always validate your translation work by running the missing translations script:
-    ```
-    node scripts/find-missing-translations.js
-    ```
-- Address any missing translations identified by the script to ensure complete coverage across all locales
-
-# 9. TRANSLATOR'S CHECKLIST
-
-- ✓ Used informal tone consistently ("du" not "Sie")
-- ✓ Preserved all placeholders exactly as in the English source
-- ✓ Maintained consistent terminology with existing translations
-- ✓ Kept technical terms and brand names unchanged where appropriate
-- ✓ Preserved the original perspective (user→system vs system→user)
-- ✓ Adapted the text appropriately for UI context (buttons vs tooltips)
diff --git a/.roo/rules-translate/instructions-de.md b/.roo/rules-translate/instructions-de.md
deleted file mode 100644
index 126842483..000000000
--- a/.roo/rules-translate/instructions-de.md
+++ /dev/null
@@ -1,14 +0,0 @@
-# German (de) Translation Guidelines
-
-**Key Rule:** Always use informal speech ("du" form) in all German translations without exception.
-
-## Quick Reference
-
-| Category    | Formal (Avoid)            | Informal (Use)      | Example           |
-| ----------- | ------------------------- | ------------------- | ----------------- |
-| Pronouns    | Sie                       | du                  | you               |
-| Possessives | Ihr/Ihre/Ihrem            | dein/deine/deinem   | your              |
-| Verbs       | können Sie, müssen Sie    | kannst du, musst du | you can, you must |
-| Imperatives | Geben Sie ein, Wählen Sie | Gib ein, Wähle      | Enter, Choose     |
-
-**Technical terms** like "API", "token", "prompt" should not be translated.
diff --git a/.roo/rules-translate/instructions-zh-cn.md b/.roo/rules-translate/instructions-zh-cn.md
deleted file mode 100644
index 241ae338d..000000000
--- a/.roo/rules-translate/instructions-zh-cn.md
+++ /dev/null
@@ -1,278 +0,0 @@
-# Simplified Chinese (zh-CN) Translation Guidelines
-
-## Key Terminology
-
-| English Term          | Preferred (zh-CN) | Avoid        | Context/Notes |
-| --------------------- | ----------------- | ------------ | ------------- |
-| API Cost              | API 费用          | API 成本     | 财务相关术语  |
-| Tokens                | Token             | Tokens/令牌  | 保留抽象术语  |
-| Token Usage           | Token 使用量      | Token 用量   | 技术计量单位  |
-| Cache                 | 缓存              | 高速缓存     | 简洁优先      |
-| Context               | 上下文            |              | 保留抽象术语  |
-| Context Menu          | 右键菜单          | 上下文菜单   | 技术术语准确  |
-| Context Window        | 上下文窗口        |              | 技术术语准确  |
-| Proceed While Running | 强制继续          | 运行时继续   | 操作命令      |
-| Enhance Prompt        | 增强提示词        | 优化提示     | AI相关功能    |
-| Auto-approve          | 自动批准          | 始终批准     | 权限相关术语  |
-| Checkpoint            | 存档点            | 检查点/快照  | 技术概念统一  |
-| MCP Server            | MCP 服务          | MCP 服务器   | 技术组件      |
-| Human Relay           | 人工辅助模式      | 人工中继     | 功能描述清晰  |
-| Network Timeout       | 请求超时          | 网络超时     | 更准确描述    |
-| Terminal              | 终端              | 命令行       | 技术术语统一  |
-| diff                  | 差异更新          | 差分/补丁    | 代码变更      |
-| prompt caching        | 提示词缓存        | 提示缓存     | AI功能        |
-| computer use          | 计算机交互        | 计算机使用   | 技术能力      |
-| rate limit            | API 请求频率限制  | 速率限制     | API控制       |
-| Browser Session       | 浏览器会话        | 浏览器进程   | 技术概念      |
-| Run Command           | 运行命令          | 执行命令     | 操作动词      |
-| power steering mode   | 增强导向模式      | 动力转向模式 | 避免直译      |
-| Boomerang Tasks       | 任务拆分          | 回旋镖任务   | 避免直译      |
-
-## Formatting Rules
-
-1. **中英文混排**
-
-    - 添加空格：在中文和英文/数字之间添加空格，如"API 费用"（不是"API费用"）
-    - 单位格式：时间单位统一为"15秒"、"1分钟"（不是"15 seconds"、"1 minute"）
-    - 数字范围："已使用: {{used}} / {{total}}"
-    - 技术符号保留原样："{{amount}} tokens"→"{{amount}}"
-
-2. **标点符号**
-
-    - 使用中文全角标点
-    - 列表项使用中文顿号："创建、编辑文件"
-
-3. **UI文本优化**
-
-    - 按钮文本：使用简洁动词，如"展开"优于"查看更多"
-    - 操作说明：使用步骤式说明（1. 2. 3.）替代长段落
-    - 错误提示：使用"确认删除？此操作不可逆"替代"Are you sure...?"
-    - 操作说明要简洁："Shift+拖拽文件"优于长描述
-    - 按钮文本控制在2-4个汉字："展开"优于"查看更多"
-
-4. **技术描述**
-
-    - 保留英文缩写：如"MCP"不翻译
-    - 统一术语：整个系统中相同概念使用相同译法
-    - 长句拆分为短句
-    - 被动语态转为主动语态
-    - 功能名称统一："计算机交互"优于"计算机使用"
-    - 参数说明："差异更新"优于"差分/补丁"
-
-5. **变量占位符**
-    - 保持原格式：`{{variable}}`
-    - 中文说明放在变量外："Token 使用量: {{used}}"
-
-## UI Element Translation Standards
-
-1. **按钮(Buttons)**
-
-    - 确认类：确定/取消/应用/保存
-    - 操作类：添加/删除/编辑/导出
-    - 状态类：启用/禁用/展开/收起
-    - 长度限制：2-4个汉字
-
-2. **菜单(Menus)**
-
-    - 主菜单：文件/编辑/视图/帮助
-    - 子菜单：使用">"连接，如"文件>打开"
-    - 快捷键：保留英文，如"Ctrl+S"
-
-3. **标签(Labels)**
-
-    - 设置项：描述功能，如"自动保存间隔"
-    - 状态提示：简洁明确，如"正在处理..."
-    - 单位说明：放在括号内，如"超时时间(秒)"
-
-4. **工具提示(Tooltips)**
-
-    - 功能说明：简洁描述，如"复制选中内容"
-    - 操作指引：步骤明确，如"双击编辑单元格"
-    - 长度限制：不超过50个汉字
-
-5. **对话框(Dialogs)**
-    - 标题：说明对话框用途
-    - 正文：分段落说明
-    - 按钮：使用动词，如"确认删除"
-
-## Contextual Translation Principles
-
-1. **根据UI位置调整**
-
-    - 按钮文本：简洁动词 (如"展开", "收起")
-    - 设置项：描述性 (如"自动批准写入操作")
-    - 帮助文本：完整说明 (如"开启后自动创建任务存档点，方便回溯修改")
-
-2. **技术文档风格**
-
-    - 使用主动语态：如"自动创建和编辑文件"
-    - 避免口语化表达
-    - 复杂功能使用分点说明
-    - 说明操作结果：如"无需二次确认"
-    - 参数说明清晰：如"延迟一段时间再自动批准写入"
-
-3. **品牌/产品名称**
-
-    - 保留英文品牌名
-    - 技术术语保持一致性
-    - 保留英文专有名词：如"AWS Bedrock ARN"
-
-4. **用户操作**
-    - 操作动词统一：
-        - "Click"→"点击"
-        - "Type"→"输入"
-        - "Scroll"→"滚动"
-    - 按钮状态：
-        - "Enabled"→"已启用"
-        - "Disabled"→"已禁用"
-
-## Technical Documentation Guidelines
-
-1. **技术术语**
-
-    - 统一使用"Token"而非"令牌"
-    - 保留英文专有名词：如"Model Context Protocol"
-    - 功能名称统一：如"计算机功能调用"优于"计算机使用"
-
-2. **API文档**
-
-    - 端点(Endpoint)：保留原始路径
-    - 参数说明：表格形式展示
-    - 示例：保留代码格式
-    - 参数标签：
-        - 单位明确：如"最大输出 Token 数"
-        - 范围说明完整：如"模型可以处理的总 Token 数"
-
-3. **代码相关翻译**
-
-    - 代码注释：
-        - 保留技术术语：如"// Initialize MCP client"
-        - 简短说明：如"检查文件是否存在"
-    - 错误信息：
-        - 包含错误代码：如"Error 404: 文件未找到"
-        - 提供解决方案：如"请检查文件权限"
-    - 命令行：
-        - 保留原生命令：如"git commit -m 'message'"
-        - 参数说明：如"-v: 显示详细输出"
-
-4. **配置指南**
-    - 设置项命名：如"Enable prompt caching"→"启用提示词缓存"
-    - 价格描述：
-        - 单位统一：如"每百万 Token 的成本"
-        - 说明影响：如"这会影响生成内容和补全的成本"
-    - 操作说明：
-        - 使用编号步骤：如"1. 注册Google Cloud账号"
-        - 步骤动词一致：如"安装配置Google Cloud CLI工具"
-
-## Common Patterns
-
-```markdown
-<<<<<<< BEFORE
-"dragFiles": "按住shift拖动文件"
-=======
-"dragFiles": "Shift+拖拽文件"
-
-> > > > > > > AFTER
-
-<<<<<<< BEFORE
-"description": "启用后，Roo 将能够与 MCP 服务器交互以获取高级功能。"
-=======
-"description": "启用后 Roo 可与 MCP 服务交互获取高级功能。"
-
-> > > > > > > AFTER
-
-<<<<<<< BEFORE
-"cannotUndo": "此操作无法撤消。"
-=======
-"cannotUndo": "此操作不可逆。"
-
-> > > > > > > AFTER
-
-<<<<<<< BEFORE
-"hold shift to drag in files" → "按住shift拖动文件"
-=======
-"hold shift to drag in files" → "Shift+拖拽文件"
-
-> > > > > > > AFTER
-
-<<<<<<< BEFORE
-"Double click to edit" → "双击进行编辑"
-=======
-"Double click to edit" → "双击编辑"
-
-> > > > > > > AFTER
-```
-
-## Common Pitfalls
-
-1. 避免过度直译导致生硬
-
-    - ✗ "Do more with Boomerang Tasks" → "使用回旋镖任务完成更多工作"
-    - ✓ "Do more with Boomerang Tasks" → "允许任务拆分"
-
-2. 保持功能描述准确
-
-    - ✗ "Enhance prompt with additional context" → "使用附加上下文增强提示"
-    - ✓ "Enhance prompt with additional context" → "增强提示词"
-
-3. 操作指引清晰
-
-    - ✗ "hold shift to drag in files" → "按住shift拖动文件"
-    - ✓ "hold shift to drag in files" → "Shift+拖拽文件"
-
-4. 确保术语一致性
-
-    - ✗ 同一文档中混用"Token"/"令牌"/"代币"
-    - ✓ 统一使用"Token"作为技术术语
-
-5. 注意文化适应性
-
-    - ✗ "Kill the process" → "杀死进程"(过于暴力)
-    - ✓ "Kill the process" → "终止进程"
-
-6. 技术文档特殊处理
-    - 代码示例中的注释：
-      ✗ 翻译后破坏代码结构
-      ✓ 保持代码注释原样或仅翻译说明部分
-    - 命令行参数：
-      ✗ 翻译参数名称导致无法使用
-      ✓ 保持参数名称英文，仅翻译说明
-
-## Best Practices
-
-1. **翻译工作流程**
-
-    - 通读全文理解上下文
-    - 标记并统一技术术语
-    - 分段翻译并检查一致性
-    - 最终整体审校
-
-2. **质量检查要点**
-
-    - 术语一致性
-    - 功能描述准确性
-    - UI元素长度适配性
-    - 文化适应性
-
-3. **工具使用建议**
-
-    - 建立项目术语库
-    - 使用翻译记忆工具
-    - 维护风格指南
-    - 定期更新翻译资源
-
-4. **审校流程**
-    - 初翻 → 技术审校 → 语言润色 → 最终确认
-    - 重点关注技术准确性、语言流畅度和UI显示效果
-
-## Quality Checklist
-
-1. 术语是否全文一致？
-2. 是否符合中文技术文档习惯？
-3. UI控件文本是否简洁明确？
-4. 长句是否已合理拆分？
-5. 变量占位符是否保留原格式？
-6. 技术描述是否准确无误？
-7. 文化表达是否恰当？
-8. 是否保持了原文的精确含义？
-9. 特殊格式(如变量、代码)是否正确保留？
diff --git a/.roo/rules-translate/instructions-zh-tw.md b/.roo/rules-translate/instructions-zh-tw.md
deleted file mode 100644
index ee4d07a07..000000000
--- a/.roo/rules-translate/instructions-zh-tw.md
+++ /dev/null
@@ -1,18 +0,0 @@
-# Traditional Chinese (zh-TW) Translation Guidelines
-
-## Key Terminology
-
-| English Term  | Use (zh-TW) | Avoid (Mainland) |
-| ------------- | ----------- | ---------------- |
-| file          | 檔案        | 文件             |
-| task          | 工作        | 任務             |
-| project       | 專案        | 項目             |
-| configuration | 設定        | 配置             |
-| server        | 伺服器      | 服務器           |
-| import/export | 匯入/匯出   | 導入/導出        |
-
-## Formatting Rules
-
-- Add spaces between Chinese and English/numbers: "AI 驅動" (not "AI驅動")
-- Use Traditional Chinese quotation marks: 「範例文字」(not "範例文字")
-- Use Taiwanese computing conventions rather than mainland terminology
diff --git a/.roo/rules/rules.md b/.roo/rules/rules.md
deleted file mode 100644
index 5726770a2..000000000
--- a/.roo/rules/rules.md
+++ /dev/null
@@ -1,24 +0,0 @@
-# Code Quality Rules
-
-1. Test Coverage:
-
-    - Before attempting completion, always make sure that any code changes have test coverage
-    - Ensure all tests pass before submitting changes
-    - The vitest framework is used for testing; the `vi`, `describe`, `test`, `it`, etc functions are defined by default in `tsconfig.json` and therefore don't need to be imported from `vitest`
-    - Tests must be run from the same directory as the `package.json` file that specifies `vitest` in `devDependencies`
-    - Run tests with: `npx vitest run <relative-path-from-workspace-root>`
-    - Do NOT run tests from project root - this causes "vitest: command not found" error
-    - Tests must be run from inside the correct workspace:
-        - Backend tests: `cd src && npx vitest run path/to/test-file` (don't include `src/` in path)
-        - UI tests: `cd webview-ui && npx vitest run src/path/to/test-file`
-    - Example: For `src/tests/user.test.ts`, run `cd src && npx vitest run tests/user.test.ts` NOT `npx vitest run src/tests/user.test.ts`
-
-2. Lint Rules:
-
-    - Never disable any lint rules without explicit user approval
-
-3. Styling Guidelines:
-
-    - Use Tailwind CSS classes instead of inline style objects for new markup
-    - VSCode CSS variables must be added to webview-ui/src/index.css before using them in Tailwind classes
-    - Example: `<div className="text-md text-vscode-descriptionForeground mb-2" />` instead of style objects
diff --git a/scripts/clear-modes-cache.js b/scripts/clear-modes-cache.js
new file mode 100644
index 000000000..c565ed556
--- /dev/null
+++ b/scripts/clear-modes-cache.js
@@ -0,0 +1,41 @@
+#!/usr/bin/env node
+
+/**
+ * Script to clear modes cache and restart the extension
+ * This helps when DEFAULT_MODES are not updating properly
+ */
+
+const fs = require('fs');
+const path = require('path');
+
+console.log('🧹 Clearing Neira Coder modes cache...\n');
+
+// Paths to clear
+const pathsToClear = [
+  // VS Code extension storage
+  path.join(process.env.HOME || process.env.USERPROFILE, '.vscode-oss/extensions/neiracoderinc.neira-*/globalStorage/neiracoderinc.neira'),
+  path.join(process.env.HOME || process.env.USERPROFILE, '.vscode/extensions/neiracoderinc.neira-*/globalStorage/neiracoderinc.neira'),
+  
+  // Project-specific cache
+  path.join(process.cwd(), '.neira'),
+  	path.join(process.cwd(), '.neira', '.neira-modes'),
+];
+
+console.log('Paths to clear:');
+pathsToClear.forEach(p => console.log(`  - ${p}`));
+
+console.log('\nTo clear the cache:');
+console.log('1. Close VS Code completely');
+console.log('2. Delete the extension storage folders (if they exist):');
+console.log('   - ~/.vscode-oss/extensions/neiracoderinc.neira-*/globalStorage/neiracoderinc.neira');
+console.log('   - ~/.vscode/extensions/neiracoderinc.neira-*/globalStorage/neiracoderinc.neira');
+console.log('3. Reopen VS Code');
+console.log('4. Run the command: "Neira Coder: Clear Modes Cache"');
+console.log('5. Or use Command Palette (Ctrl+Shift+P) and search for "Clear Modes Cache"');
+
+console.log('\nAlternative solution:');
+console.log('1. Uninstall the extension');
+console.log('2. Delete the extension folder completely');
+console.log('3. Install the extension again');
+
+console.log('\nThis will force the extension to reload all DEFAULT_MODES from the latest version.'); 
\ No newline at end of file
diff --git a/scripts/rename-project.sh b/scripts/rename-project.sh
new file mode 100755
index 000000000..6f64086b9
--- /dev/null
+++ b/scripts/rename-project.sh
@@ -0,0 +1,246 @@
+#!/bin/bash
+
+# Скрипт для переименования проекта roo-code → neira-coder
+# Использование: ./scripts/rename-project.sh [--dry-run] [--backup]
+
+set -e
+
+# Цвета для вывода
+RED='\033[0;31m'
+GREEN='\033[0;32m'
+YELLOW='\033[1;33m'
+BLUE='\033[0;34m'
+NC='\033[0m' # No Color
+
+# Переменные
+OLD_NAME="roo-code"
+NEW_NAME="neira-coder"
+OLD_ORG="roo-code"
+NEW_ORG="neira-coder"
+OLD_DOMAIN="roocode.com"
+NEW_DOMAIN="neira-coder.com"
+OLD_EMAIL="roocode.com"
+NEW_EMAIL="neira-coder.com"
+
+DRY_RUN=false
+CREATE_BACKUP=false
+
+# Функции
+log_info() {
+    echo -e "${BLUE}[INFO]${NC} $1"
+}
+
+log_success() {
+    echo -e "${GREEN}[SUCCESS]${NC} $1"
+}
+
+log_warning() {
+    echo -e "${YELLOW}[WARNING]${NC} $1"
+}
+
+log_error() {
+    echo -e "${RED}[ERROR]${NC} $1"
+}
+
+# Парсинг аргументов
+while [[ $# -gt 0 ]]; do
+    case $1 in
+        --dry-run)
+            DRY_RUN=true
+            shift
+            ;;
+        --backup)
+            CREATE_BACKUP=true
+            shift
+            ;;
+        *)
+            log_error "Неизвестный аргумент: $1"
+            exit 1
+            ;;
+    esac
+done
+
+# Проверка, что мы в корневой директории проекта
+if [[ ! -f "package.json" ]] || [[ ! -f "pnpm-workspace.yaml" ]]; then
+    log_error "Скрипт должен быть запущен из корневой директории проекта"
+    exit 1
+fi
+
+log_info "Начинаем переименование проекта $OLD_NAME → $NEW_NAME"
+if [[ "$DRY_RUN" == "true" ]]; then
+    log_warning "Режим DRY RUN - изменения не будут применены"
+fi
+
+# Создание резервной копии
+if [[ "$CREATE_BACKUP" == "true" ]]; then
+    log_info "Создание резервной копии..."
+    BACKUP_DIR="backup-$(date +%Y%m%d-%H%M%S)"
+    if [[ "$DRY_RUN" == "false" ]]; then
+        git checkout -b "backup/$OLD_NAME-original"
+        cp -r . "../$BACKUP_DIR"
+        log_success "Резервная копия создана: ../$BACKUP_DIR"
+    else
+        log_info "DRY RUN: Создана бы резервная копия: ../$BACKUP_DIR"
+    fi
+fi
+
+# Функция для замены в файлах
+replace_in_files() {
+    local pattern="$1"
+    local replacement="$2"
+    local file_pattern="$3"
+    
+    log_info "Замена '$pattern' → '$replacement' в файлах $file_pattern"
+    
+    if [[ "$DRY_RUN" == "true" ]]; then
+        find . -name "$file_pattern" -not -path "./node_modules/*" -not -path "./.git/*" -not -path "./.turbo/*" -exec grep -l "$pattern" {} \; | head -10
+        log_info "DRY RUN: Найдено $(find . -name "$file_pattern" -not -path "./node_modules/*" -not -path "./.git/*" -not -path "./.turbo/*" -exec grep -l "$pattern" {} \; | wc -l) файлов для замены"
+    else
+        if [[ "$OSTYPE" == "darwin"* ]]; then
+            # macOS
+            find . -name "$file_pattern" -not -path "./node_modules/*" -not -path "./.git/*" -not -path "./.turbo/*" -exec sed -i '' "s/$pattern/$replacement/g" {} \;
+        else
+            # Linux
+            find . -name "$file_pattern" -not -path "./node_modules/*" -not -path "./.git/*" -not -path "./.turbo/*" -exec sed -i "s/$pattern/$replacement/g" {} \;
+        fi
+        log_success "Замена завершена"
+    fi
+}
+
+# Функция для переименования директорий
+rename_directory() {
+    local old_path="$1"
+    local new_path="$2"
+    
+    if [[ -d "$old_path" ]]; then
+        log_info "Переименование директории: $old_path → $new_path"
+        if [[ "$DRY_RUN" == "false" ]]; then
+            mv "$old_path" "$new_path"
+            log_success "Директория переименована"
+        else
+            log_info "DRY RUN: Директория была бы переименована"
+        fi
+    else
+        log_warning "Директория $old_path не найдена"
+    fi
+}
+
+# Шаг 1: Замена в package.json файлах
+log_info "=== Шаг 1: Обновление package.json файлов ==="
+
+# Корневой package.json
+if [[ "$DRY_RUN" == "false" ]]; then
+    if [[ "$OSTYPE" == "darwin"* ]]; then
+        sed -i '' "s/\"name\": \"$OLD_NAME\"/\"name\": \"$NEW_NAME\"/g" package.json
+    else
+        sed -i "s/\"name\": \"$OLD_NAME\"/\"name\": \"$NEW_NAME\"/g" package.json
+    fi
+fi
+
+# Замена имен пакетов в package.json
+replace_in_files "@$OLD_ORG/" "@$NEW_ORG/" "package.json"
+
+# Шаг 2: Замена импортов в коде
+log_info "=== Шаг 2: Обновление импортов в коде ==="
+
+# TypeScript/JavaScript файлы
+replace_in_files "from \"@$OLD_ORG/" "from \"@$NEW_ORG/" "*.ts"
+replace_in_files "from \"@$OLD_ORG/" "from \"@$NEW_ORG/" "*.tsx"
+replace_in_files "from \"@$OLD_ORG/" "from \"@$NEW_ORG/" "*.js"
+replace_in_files "from \"@$OLD_ORG/" "from \"@$NEW_ORG/" "*.jsx"
+
+# Шаг 3: Обновление конфигурационных файлов
+log_info "=== Шаг 3: Обновление конфигурационных файлов ==="
+
+# tsconfig.json
+replace_in_files "\"extends\": \"@$OLD_ORG/" "\"extends\": \"@$NEW_ORG/" "tsconfig.json"
+
+# turbo.json
+replace_in_files "@$OLD_ORG/" "@$NEW_ORG/" "turbo.json"
+
+# Шаг 4: Переименование директорий
+log_info "=== Шаг 4: Переименование директорий ==="
+
+# Переименование web-roo-code → web-neira-coder
+rename_directory "apps/web-roo-code" "apps/web-neira-coder"
+
+# Шаг 5: Обновление URL и доменов
+log_info "=== Шаг 5: Обновление URL и доменов ==="
+
+# Замена доменов
+replace_in_files "$OLD_DOMAIN" "$NEW_DOMAIN" "*.ts"
+replace_in_files "$OLD_DOMAIN" "$NEW_DOMAIN" "*.tsx"
+replace_in_files "$OLD_DOMAIN" "$NEW_DOMAIN" "*.js"
+replace_in_files "$OLD_DOMAIN" "$NEW_DOMAIN" "*.json"
+replace_in_files "$OLD_DOMAIN" "$NEW_DOMAIN" "*.md"
+
+# Замена GitHub URLs
+replace_in_files "github.com/RooCodeInc/Roo-Code" "github.com/NeiraCoderInc/Neira-Coder" "*.ts"
+replace_in_files "github.com/RooCodeInc/Roo-Code" "github.com/NeiraCoderInc/Neira-Coder" "*.tsx"
+replace_in_files "github.com/RooCodeInc/Roo-Code" "github.com/NeiraCoderInc/Neira-Coder" "*.js"
+replace_in_files "github.com/RooCodeInc/Roo-Code" "github.com/NeiraCoderInc/Neira-Coder" "*.json"
+replace_in_files "github.com/RooCodeInc/Roo-Code" "github.com/NeiraCoderInc/Neira-Coder" "*.md"
+
+# Замена email адресов
+replace_in_files "@$OLD_EMAIL" "@$NEW_EMAIL" "*.ts"
+replace_in_files "@$OLD_EMAIL" "@$NEW_EMAIL" "*.tsx"
+replace_in_files "@$OLD_EMAIL" "@$NEW_EMAIL" "*.js"
+replace_in_files "@$OLD_EMAIL" "@$NEW_EMAIL" "*.json"
+replace_in_files "@$OLD_EMAIL" "@$NEW_EMAIL" "*.md"
+
+# Шаг 6: Обновление локализации
+log_info "=== Шаг 6: Обновление локализации ==="
+
+# Обновление файлов локализации
+replace_in_files "roo-code-settings.json" "neira-coder-settings.json" "*.json"
+replace_in_files "RooCode" "NeiraCoder" "*.json"
+
+# Шаг 7: Очистка и переустановка зависимостей
+if [[ "$DRY_RUN" == "false" ]]; then
+    log_info "=== Шаг 7: Очистка и переустановка зависимостей ==="
+    
+    log_info "Удаление node_modules и pnpm-lock.yaml..."
+    rm -rf node_modules
+    rm -f pnpm-lock.yaml
+    
+    log_info "Установка зависимостей..."
+    pnpm install
+    
+    log_success "Зависимости переустановлены"
+else
+    log_info "DRY RUN: Зависимости не переустанавливались"
+fi
+
+# Финальная проверка
+log_info "=== Финальная проверка ==="
+
+if [[ "$DRY_RUN" == "false" ]]; then
+    log_info "Проверка сборки..."
+    if pnpm build > /dev/null 2>&1; then
+        log_success "Сборка прошла успешно"
+    else
+        log_error "Ошибка при сборке"
+        exit 1
+    fi
+    
+    log_info "Проверка типов..."
+    if pnpm check-types > /dev/null 2>&1; then
+        log_success "Проверка типов прошла успешно"
+    else
+        log_warning "Есть ошибки типов - проверьте вручную"
+    fi
+else
+    log_info "DRY RUN: Проверки не выполнялись"
+fi
+
+log_success "Переименование проекта завершено!"
+log_info "Следующие шаги:"
+log_info "1. Проверьте все изменения: git diff"
+log_info "2. Запустите тесты: pnpm test"
+log_info "3. Проверьте линтер: pnpm lint"
+log_info "4. Протестируйте приложения: pnpm dev"
+log_info "5. Создайте коммит с изменениями"
+
+if [[ "$DRY_RUN" == "true" ]]; then
+    log_warning "Это был DRY RUN. Для применения изменений запустите скрипт без --dry-run"
+fi 
\ No newline at end of file
diff --git a/scripts/rollback-rename.sh b/scripts/rollback-rename.sh
new file mode 100755
index 000000000..358df5e06
--- /dev/null
+++ b/scripts/rollback-rename.sh
@@ -0,0 +1,178 @@
+#!/bin/bash
+
+# Скрипт для отката переименования проекта neira-coder → roo-code
+# Использование: ./scripts/rollback-rename.sh [--backup-dir=path]
+
+set -e
+
+# Цвета для вывода
+RED='\033[0;31m'
+GREEN='\033[0;32m'
+YELLOW='\033[1;33m'
+BLUE='\033[0;34m'
+NC='\033[0m' # No Color
+
+# Переменные
+OLD_NAME="neira-coder"
+NEW_NAME="roo-code"
+OLD_ORG="neira-coder"
+NEW_ORG="roo-code"
+OLD_DOMAIN="neira-coder.com"
+NEW_DOMAIN="roocode.com"
+OLD_EMAIL="neira-coder.com"
+NEW_EMAIL="roocode.com"
+
+BACKUP_DIR=""
+
+# Функции
+log_info() {
+    echo -e "${BLUE}[INFO]${NC} $1"
+}
+
+log_success() {
+    echo -e "${GREEN}[SUCCESS]${NC} $1"
+}
+
+log_warning() {
+    echo -e "${YELLOW}[WARNING]${NC} $1"
+}
+
+log_error() {
+    echo -e "${RED}[ERROR]${NC} $1"
+}
+
+# Парсинг аргументов
+while [[ $# -gt 0 ]]; do
+    case $1 in
+        --backup-dir=*)
+            BACKUP_DIR="${1#*=}"
+            shift
+            ;;
+        *)
+            log_error "Неизвестный аргумент: $1"
+            exit 1
+            ;;
+    esac
+done
+
+# Проверка, что мы в корневой директории проекта
+if [[ ! -f "package.json" ]] || [[ ! -f "pnpm-workspace.yaml" ]]; then
+    log_error "Скрипт должен быть запущен из корневой директории проекта"
+    exit 1
+fi
+
+log_info "Начинаем откат переименования проекта $OLD_NAME → $NEW_NAME"
+
+# Проверка наличия резервной копии
+if [[ -z "$BACKUP_DIR" ]]; then
+    # Поиск последней резервной копии
+    BACKUP_DIR=$(find .. -maxdepth 1 -name "backup-*" -type d | sort | tail -1)
+    if [[ -z "$BACKUP_DIR" ]]; then
+        log_error "Резервная копия не найдена. Укажите путь к резервной копии: --backup-dir=path"
+        exit 1
+    fi
+    log_info "Найдена резервная копия: $BACKUP_DIR"
+fi
+
+if [[ ! -d "$BACKUP_DIR" ]]; then
+    log_error "Директория резервной копии не существует: $BACKUP_DIR"
+    exit 1
+fi
+
+# Подтверждение отката
+log_warning "ВНИМАНИЕ: Это действие откатит все изменения переименования!"
+log_warning "Резервная копия: $BACKUP_DIR"
+echo
+read -p "Вы уверены, что хотите продолжить? (y/N): " -n 1 -r
+echo
+if [[ ! $REPLY =~ ^[Yy]$ ]]; then
+    log_info "Откат отменен"
+    exit 0
+fi
+
+# Создание резервной копии текущего состояния
+CURRENT_BACKUP="backup-current-$(date +%Y%m%d-%H%M%S)"
+log_info "Создание резервной копии текущего состояния: $CURRENT_BACKUP"
+cp -r . "../$CURRENT_BACKUP"
+log_success "Текущее состояние сохранено в: ../$CURRENT_BACKUP"
+
+# Очистка текущей директории (кроме .git)
+log_info "Очистка текущей директории..."
+find . -mindepth 1 -not -path "./.git" -not -path "./.git/*" -delete
+
+# Восстановление из резервной копии
+log_info "Восстановление из резервной копии..."
+cp -r "$BACKUP_DIR"/* .
+cp -r "$BACKUP_DIR"/.* . 2>/dev/null || true
+
+# Восстановление .git директории
+if [[ -d "$CURRENT_BACKUP/.git" ]]; then
+    log_info "Восстановление .git директории..."
+    rm -rf .git
+    cp -r "$CURRENT_BACKUP/.git" .
+fi
+
+log_success "Восстановление завершено"
+
+# Проверка восстановления
+log_info "=== Проверка восстановления ==="
+
+# Проверка основных файлов
+if [[ -f "package.json" ]]; then
+    if grep -q "\"name\": \"$NEW_NAME\"" package.json; then
+        log_success "✅ Корневой package.json восстановлен"
+    else
+        log_error "❌ Ошибка в корневом package.json"
+    fi
+else
+    log_error "❌ package.json не найден"
+fi
+
+# Проверка директорий
+if [[ -d "apps/web-roo-code" ]]; then
+    log_success "✅ Директория apps/web-roo-code восстановлена"
+else
+    log_error "❌ Директория apps/web-roo-code не найдена"
+fi
+
+# Проверка workspace пакетов
+packages=("types" "cloud" "ipc" "telemetry" "evals" "build" "config-eslint" "config-typescript")
+for pkg in "${packages[@]}"; do
+    if [[ -d "packages/$pkg" ]]; then
+        log_success "✅ Пакет packages/$pkg восстановлен"
+    else
+        log_error "❌ Пакет packages/$pkg не найден"
+    fi
+done
+
+# Переустановка зависимостей
+log_info "Переустановка зависимостей..."
+rm -rf node_modules
+rm -f pnpm-lock.yaml
+pnpm install
+
+# Проверка сборки
+log_info "Проверка сборки..."
+if pnpm build > /dev/null 2>&1; then
+    log_success "✅ Сборка прошла успешно"
+else
+    log_warning "⚠️  Есть проблемы со сборкой"
+fi
+
+# Проверка типов
+log_info "Проверка типов..."
+if pnpm check-types > /dev/null 2>&1; then
+    log_success "✅ Проверка типов прошла успешно"
+else
+    log_warning "⚠️  Есть ошибки типов"
+fi
+
+log_success "Откат переименования завершен!"
+log_info "Проект восстановлен из резервной копии: $BACKUP_DIR"
+log_info "Текущее состояние сохранено в: ../$CURRENT_BACKUP"
+log_info ""
+log_info "Следующие шаги:"
+log_info "1. Проверьте все изменения: git status"
+log_info "2. Запустите тесты: pnpm test"
+log_info "3. Проверьте линтер: pnpm lint"
+log_info "4. Протестируйте приложения: pnpm dev" 
\ No newline at end of file
diff --git a/scripts/verify-rename.sh b/scripts/verify-rename.sh
new file mode 100755
index 000000000..fb9a3778d
--- /dev/null
+++ b/scripts/verify-rename.sh
@@ -0,0 +1,205 @@
+#!/bin/bash
+
+# Скрипт для проверки результатов переименования проекта
+# Использование: ./scripts/verify-rename.sh
+
+set -e
+
+# Цвета для вывода
+RED='\033[0;31m'
+GREEN='\033[0;32m'
+YELLOW='\033[1;33m'
+BLUE='\033[0;34m'
+NC='\033[0m' # No Color
+
+# Переменные
+OLD_NAME="roo-code"
+NEW_NAME="neira-coder"
+OLD_ORG="roo-code"
+NEW_ORG="neira-coder"
+
+# Функции
+log_info() {
+    echo -e "${BLUE}[INFO]${NC} $1"
+}
+
+log_success() {
+    echo -e "${GREEN}[SUCCESS]${NC} $1"
+}
+
+log_warning() {
+    echo -e "${YELLOW}[WARNING]${NC} $1"
+}
+
+log_error() {
+    echo -e "${RED}[ERROR]${NC} $1"
+}
+
+# Проверка, что мы в корневой директории проекта
+if [[ ! -f "package.json" ]] || [[ ! -f "pnpm-workspace.yaml" ]]; then
+    log_error "Скрипт должен быть запущен из корневой директории проекта"
+    exit 1
+fi
+
+log_info "Проверка результатов переименования проекта..."
+
+# Функция для подсчета вхождений
+count_occurrences() {
+    local pattern="$1"
+    local file_pattern="$2"
+    local count=$(find . -name "$file_pattern" -not -path "./node_modules/*" -not -path "./.git/*" -not -path "./.turbo/*" -exec grep -l "$pattern" {} \; 2>/dev/null | wc -l)
+    echo $count
+}
+
+# Функция для проверки файла
+check_file() {
+    local file="$1"
+    local pattern="$2"
+    local description="$3"
+    
+    if [[ -f "$file" ]]; then
+        if grep -q "$pattern" "$file" 2>/dev/null; then
+            log_error "❌ $description: найдено в $file"
+            return 1
+        else
+            log_success "✅ $description: OK в $file"
+            return 0
+        fi
+    else
+        log_warning "⚠️  Файл $file не найден"
+        return 0
+    fi
+}
+
+# Функция для проверки директории
+check_directory() {
+    local dir="$1"
+    local description="$2"
+    
+    if [[ -d "$dir" ]]; then
+        log_success "✅ $description: директория $dir существует"
+        return 0
+    else
+        log_error "❌ $description: директория $dir не найдена"
+        return 1
+    fi
+}
+
+# Счетчики
+old_occurrences=0
+new_occurrences=0
+errors=0
+
+log_info "=== Проверка основных файлов ==="
+
+# Проверка корневого package.json
+check_file "package.json" "\"name\": \"$OLD_NAME\"" "Старое имя проекта" || ((errors++))
+check_file "package.json" "\"name\": \"$NEW_NAME\"" "Новое имя проекта" || ((errors++))
+
+# Проверка workspace пакетов
+packages=("types" "cloud" "ipc" "telemetry" "evals" "build" "config-eslint" "config-typescript")
+for pkg in "${packages[@]}"; do
+    check_file "packages/$pkg/package.json" "\"name\": \"@$OLD_ORG/$pkg\"" "Старое имя пакета @$OLD_ORG/$pkg" || ((errors++))
+    check_file "packages/$pkg/package.json" "\"name\": \"@$NEW_ORG/$pkg\"" "Новое имя пакета @$NEW_ORG/$pkg" || ((errors++))
+done
+
+# Проверка приложений
+check_file "apps/web-neira-coder/package.json" "\"name\": \"@$NEW_ORG/web-neira-coder\"" "Новое имя приложения web-neira-coder" || ((errors++))
+check_file "apps/web-evals/package.json" "\"name\": \"@$NEW_ORG/web-evals\"" "Новое имя приложения web-evals" || ((errors++))
+check_file "webview-ui/package.json" "\"name\": \"@$NEW_ORG/vscode-webview\"" "Новое имя пакета vscode-webview" || ((errors++))
+
+log_info "=== Проверка директорий ==="
+
+# Проверка переименованных директорий
+check_directory "apps/web-neira-coder" "Переименованное приложение" || ((errors++))
+check_directory "apps/web-roo-code" "Старое приложение (должно быть удалено)" && ((errors++))
+
+log_info "=== Проверка конфигурационных файлов ==="
+
+# Проверка tsconfig.json файлов
+check_file "packages/types/tsconfig.json" "\"extends\": \"@$OLD_ORG/" "Старые extends в types/tsconfig.json" || ((errors++))
+check_file "packages/types/tsconfig.json" "\"extends\": \"@$NEW_ORG/" "Новые extends в types/tsconfig.json" || ((errors++))
+
+# Проверка turbo.json
+check_file "turbo.json" "@$OLD_ORG/" "Старые зависимости в turbo.json" || ((errors++))
+check_file "turbo.json" "@$NEW_ORG/" "Новые зависимости в turbo.json" || ((errors++))
+
+log_info "=== Проверка импортов в коде ==="
+
+# Подсчет оставшихся старых импортов
+old_imports=$(count_occurrences "from \"@$OLD_ORG/" "*.ts")
+old_imports_tsx=$(count_occurrences "from \"@$OLD_ORG/" "*.tsx")
+old_imports_js=$(count_occurrences "from \"@$OLD_ORG/" "*.js")
+old_imports_jsx=$(count_occurrences "from \"@$OLD_ORG/" "*.jsx")
+total_old_imports=$((old_imports + old_imports_tsx + old_imports_js + old_imports_jsx))
+
+# Подсчет новых импортов
+new_imports=$(count_occurrences "from \"@$NEW_ORG/" "*.ts")
+new_imports_tsx=$(count_occurrences "from \"@$NEW_ORG/" "*.tsx")
+new_imports_js=$(count_occurrences "from \"@$NEW_ORG/" "*.js")
+new_imports_jsx=$(count_occurrences "from \"@$NEW_ORG/" "*.jsx")
+total_new_imports=$((new_imports + new_imports_tsx + new_imports_js + new_imports_jsx))
+
+if [[ $total_old_imports -gt 0 ]]; then
+    log_error "❌ Найдено $total_old_imports файлов со старыми импортами @$OLD_ORG/"
+    ((errors++))
+else
+    log_success "✅ Все старые импорты @$OLD_ORG/ заменены"
+fi
+
+if [[ $total_new_imports -gt 0 ]]; then
+    log_success "✅ Найдено $total_new_imports файлов с новыми импортами @$NEW_ORG/"
+else
+    log_warning "⚠️  Не найдено новых импортов @$NEW_ORG/"
+fi
+
+log_info "=== Проверка сборки ==="
+
+# Проверка, что проект собирается
+if pnpm build > /dev/null 2>&1; then
+    log_success "✅ Сборка проекта прошла успешно"
+else
+    log_error "❌ Ошибка при сборке проекта"
+    ((errors++))
+fi
+
+log_info "=== Проверка типов ==="
+
+# Проверка типов TypeScript
+if pnpm check-types > /dev/null 2>&1; then
+    log_success "✅ Проверка типов прошла успешно"
+else
+    log_warning "⚠️  Есть ошибки типов - проверьте вручную"
+fi
+
+log_info "=== Проверка тестов ==="
+
+# Проверка тестов
+if pnpm test > /dev/null 2>&1; then
+    log_success "✅ Тесты прошли успешно"
+else
+    log_warning "⚠️  Есть ошибки в тестах - проверьте вручную"
+fi
+
+log_info "=== Проверка линтера ==="
+
+# Проверка линтера
+if pnpm lint > /dev/null 2>&1; then
+    log_success "✅ Линтер прошел успешно"
+else
+    log_warning "⚠️  Есть ошибки линтера - проверьте вручную"
+fi
+
+log_info "=== Финальный отчет ==="
+
+if [[ $errors -eq 0 ]]; then
+    log_success "🎉 Все проверки прошли успешно! Переименование завершено корректно."
+    exit 0
+else
+    log_error "❌ Найдено $errors ошибок. Проверьте их вручную."
+    log_info "Рекомендации:"
+    log_info "1. Проверьте все файлы с ошибками"
+    log_info "2. Запустите скрипт переименования еще раз"
+    log_info "3. Проверьте вручную все импорты и зависимости"
+    exit 1
+fi 
\ No newline at end of file
